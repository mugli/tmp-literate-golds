<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: bundler.go in package google.golang.org/api/support/bundler</title>
<link href="../../../../../css/lightLiterate-v0.3.2-preview.css" rel="stylesheet">
<script src="../../../../../jvs/golds-v0.3.2-preview.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	bundler.go

<span class="title">Belonging Package</span>
	<a href="../../../../../pkg/google.golang.org/api/support/bundler.html">google.golang.org/api/support/bundler</a>
</code></pre>
<style>input[type=radio] {display: none;}
input[id=r0]:checked ~pre label[for=r0],
input[id=r1]:checked ~pre label[for=r1],
input[id=r2]:checked ~pre label[for=r2],
input[id=r3]:checked ~pre label[for=r3],
input[id=r4]:checked ~pre label[for=r4],
input[id=r5]:checked ~pre label[for=r5],
input[id=r6]:checked ~pre label[for=r6],
input[id=r7]:checked ~pre label[for=r7],
input[id=r8]:checked ~pre label[for=r8],
input[id=r9]:checked ~pre label[for=r9],
input[id=r10]:checked ~pre label[for=r10],
input[id=r11]:checked ~pre label[for=r11],
input[id=r12]:checked ~pre label[for=r12],
input[id=r13]:checked ~pre label[for=r13],
input[id=r14]:checked ~pre label[for=r14],
input[id=r15]:checked ~pre label[for=r15],
input[id=r16]:checked ~pre label[for=r16],
input[id=r17]:checked ~pre label[for=r17],
input[id=r18]:checked ~pre label[for=r18],
input[id=r19]:checked ~pre label[for=r19],
input[id=r20]:checked ~pre label[for=r20],
input[id=r21]:checked ~pre label[for=r21],
input[id=r22]:checked ~pre label[for=r22],
input[id=r23]:checked ~pre label[for=r23],
input[id=r24]:checked ~pre label[for=r24],
input[id=r25]:checked ~pre label[for=r25],
input[id=r26]:checked ~pre label[for=r26],
input[id=r27]:checked ~pre label[for=r27],
input[id=r28]:checked ~pre label[for=r28],
input[id=r29]:checked ~pre label[for=r29],
input[id=r30]:checked ~pre label[for=r30],
input[id=r31]:checked ~pre label[for=r31],
input[id=r32]:checked ~pre label[for=r32],
input[id=r33]:checked ~pre label[for=r33],
input[id=r34]:checked ~pre label[for=r34],
input[id=r35]:checked ~pre label[for=r35],
input[id=r36]:checked ~pre label[for=r36],
input[id=r37]:checked ~pre label[for=r37],
input[id=r38]:checked ~pre label[for=r38],
input[id=r39]:checked ~pre label[for=r39],
input[id=r40]:checked ~pre label[for=r40],
input[id=r41]:checked ~pre label[for=r41],
input[id=r42]:checked ~pre label[for=r42],
input[id=r43]:checked ~pre label[for=r43],
input[id=r44]:checked ~pre label[for=r44],
input[id=r45]:checked ~pre label[for=r45],
input[id=r46]:checked ~pre label[for=r46],
input[id=r47]:checked ~pre label[for=r47],
input[id=r48]:checked ~pre label[for=r48],
input[id=r49]:checked ~pre label[for=r49],
input[id=r50]:checked ~pre label[for=r50]
{background: #226; color: #ff8;}
input[id=i0]:checked ~pre .i0,
input[id=i1]:checked ~pre .i1,
input[id=i2]:checked ~pre .i2,
input[id=i3]:checked ~pre .i3,
input[id=i4]:checked ~pre .i4,
input[id=i5]:checked ~pre .i5
{background: brown; color: #eed;}
</style><input id="r0" type="radio" name="g"/>
<input id="r1" type="radio" name="g"/>
<input id="r2" type="radio" name="g"/>
<input id="r3" type="radio" name="g"/>
<input id="r4" type="radio" name="g"/>
<input id="r5" type="radio" name="g"/>
<input id="r6" type="radio" name="g"/>
<input id="r7" type="radio" name="g"/>
<input id="r8" type="radio" name="g"/>
<input id="r9" type="radio" name="g"/>
<input id="r10" type="radio" name="g"/>
<input id="r11" type="radio" name="g"/>
<input id="r12" type="radio" name="g"/>
<input id="r13" type="radio" name="g"/>
<input id="r14" type="radio" name="g"/>
<input id="r15" type="radio" name="g"/>
<input id="r16" type="radio" name="g"/>
<input id="r17" type="radio" name="g"/>
<input id="r18" type="radio" name="g"/>
<input id="r19" type="radio" name="g"/>
<input id="r20" type="radio" name="g"/>
<input id="r21" type="radio" name="g"/>
<input id="r22" type="radio" name="g"/>
<input id="r23" type="radio" name="g"/>
<input id="r24" type="radio" name="g"/>
<input id="r25" type="radio" name="g"/>
<input id="r26" type="radio" name="g"/>
<input id="r27" type="radio" name="g"/>
<input id="r28" type="radio" name="g"/>
<input id="r29" type="radio" name="g"/>
<input id="r30" type="radio" name="g"/>
<input id="r31" type="radio" name="g"/>
<input id="r32" type="radio" name="g"/>
<input id="r33" type="radio" name="g"/>
<input id="r34" type="radio" name="g"/>
<input id="r35" type="radio" name="g"/>
<input id="r36" type="radio" name="g"/>
<input id="r37" type="radio" name="g"/>
<input id="r38" type="radio" name="g"/>
<input id="r39" type="radio" name="g"/>
<input id="r40" type="radio" name="g"/>
<input id="r41" type="radio" name="g"/>
<input id="r42" type="radio" name="g"/>
<input id="r43" type="radio" name="g"/>
<input id="r44" type="radio" name="g"/>
<input id="r45" type="radio" name="g"/>
<input id="r46" type="radio" name="g"/>
<input id="r47" type="radio" name="g"/>
<input id="r48" type="radio" name="g"/>
<input id="r49" type="radio" name="g"/>
<input id="r50" type="radio" name="g"/>
<input id="i0" type="radio" name="i"/>
<input id="i1" type="radio" name="i"/>
<input id="i2" type="radio" name="i"/>
<input id="i3" type="radio" name="i"/>
<input id="i4" type="radio" name="i"/>
<input id="i5" type="radio" name="i"/>
<div id="container"><div class="section">
<div class="doc">
<span class="comment"> Copyright 2016 Google LLC.</span><span class="comment"> Use of this source code is governed by a BSD-style</span><span class="comment"> license that can be found in the LICENSE file.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Package bundler supports bundling (batching) of items. Bundling amortizes an</span><span class="comment"> action with fixed costs over multiple items. For example, if an API provides</span><span class="comment"> an RPC that accepts a list of items as input, but clients would prefer</span><span class="comment"> adding items one at a time, then a Bundler can accept individual items from</span><span class="comment"> the client and bundle many of them into a single RPC.</span><span class="comment"></span><span class="comment"> This package is experimental and subject to change without notice.</span></div>
<div class="code"><pre><code><span class="keyword">package</span> bundler

<span class="keyword">import</span> (
	<label for="i0"><span class="lit-string i0">"context"</span></label>
	<label for="i1"><span class="lit-string i1">"errors"</span></label>
	<label for="i2"><span class="lit-string i2">"reflect"</span></label>
	<label for="i3"><span class="lit-string i3">"sync"</span></label>
	<label for="i4"><span class="lit-string i4">"time"</span></label>

	<label for="i5"><span class="lit-string i5">"golang.org/x/sync/semaphore"</span></label>
)

<span class="keyword">type</span> <a href="../../../../../pkg/google.golang.org/api/support/bundler.html#name-mode" class="ident">mode</a> <a href="../../../../../pkg/builtin.html#name-int" class="ident">int</a>

<span class="keyword">const</span> (
	<a href="../../../../../pkg/google.golang.org/api/support/bundler.html#name-DefaultDelayThreshold" class="ident">DefaultDelayThreshold</a>       = <a href="../../../../../pkg/time.html" class="ident i4">time</a>.<a href="../../../../time/time.go.html#line-605" class="ident">Second</a>
	<a href="../../../../../pkg/google.golang.org/api/support/bundler.html#name-DefaultBundleCountThreshold" class="ident">DefaultBundleCountThreshold</a> = <span class="lit-number">10</span>
	<a href="../../../../../pkg/google.golang.org/api/support/bundler.html#name-DefaultBundleByteThreshold" class="ident">DefaultBundleByteThreshold</a>  = <span class="lit-number">1e6</span> <span class="comment">// 1M</span>
	<a href="../../../../../pkg/google.golang.org/api/support/bundler.html#name-DefaultBufferedByteLimit" class="ident">DefaultBufferedByteLimit</a>    = <span class="lit-number">1e9</span> <span class="comment">// 1G</span>
)

<span class="keyword">const</span> (
	<a href="../../../../../pkg/google.golang.org/api/support/bundler.html#name-none" class="ident">none</a> <a href="#line-24" class="ident">mode</a> = <a href="../../../../../pkg/builtin.html#name-iota" class="ident">iota</a>
	<a href="../../../../../pkg/google.golang.org/api/support/bundler.html#name-add" class="ident">add</a>
	<a href="../../../../../pkg/google.golang.org/api/support/bundler.html#name-addWait" class="ident">addWait</a>
)

</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> ErrOverflow indicates that Bundler's stored bytes exceeds its BufferedByteLimit.</span></div>
<div class="code"><pre><code>	<a href="../../../../../pkg/google.golang.org/api/support/bundler.html#name-ErrOverflow" class="ident">ErrOverflow</a> = <a href="../../../../../pkg/errors.html" class="ident i1">errors</a>.<a href="../../../../errors/errors.go.html#line-58" class="ident">New</a>(<span class="lit-string">"bundler reached buffered byte limit"</span>)
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> ErrOversizedItem indicates that an item's size exceeds the maximum bundle size.</span></div>
<div class="code"><pre><code>	<a href="../../../../../pkg/google.golang.org/api/support/bundler.html#name-ErrOversizedItem" class="ident">ErrOversizedItem</a> = <a href="../../../../../pkg/errors.html" class="ident i1">errors</a>.<a href="../../../../errors/errors.go.html#line-58" class="ident">New</a>(<span class="lit-string">"item size exceeds bundle byte limit"</span>)
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> errMixedMethods indicates that mutually exclusive methods has been</span><span class="comment">	 called subsequently.</span></div>
<div class="code"><pre><code>	<a href="../../../../../pkg/google.golang.org/api/support/bundler.html#name-errMixedMethods" class="ident">errMixedMethods</a> = <a href="../../../../../pkg/errors.html" class="ident i1">errors</a>.<a href="../../../../errors/errors.go.html#line-58" class="ident">New</a>(<span class="lit-string">"calls to Add and AddWait cannot be mixed"</span>)
)
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> A Bundler collects items added to it into a bundle until the bundle</span><span class="comment"> exceeds a given size, then calls a user-provided function to handle the</span><span class="comment"> bundle.</span><span class="comment"></span><span class="comment"> The exported fields are only safe to modify prior to the first call to Add</span><span class="comment"> or AddWait.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Starting from the time that the first message is added to a bundle, once</span><span class="comment">	 this delay has passed, handle the bundle. The default is DefaultDelayThreshold.</span></div>
<div class="code"><pre><code>	<a href="../../../../../use/google.golang.org/api/support/bundler..Bundler.DelayThreshold.html" class="ident">DelayThreshold</a> <a href="../../../../../pkg/time.html" class="ident i4">time</a>.<a href="../../../../time/time.go.html#line-583" class="ident">Duration</a>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Once a bundle has this many items, handle the bundle. Since only one</span><span class="comment">	 item at a time is added to a bundle, no bundle will exceed this</span><span class="comment">	 threshold, so it also serves as a limit. The default is</span><span class="comment">	 DefaultBundleCountThreshold.</span></div>
<div class="code"><pre><code>	<a href="../../../../../use/google.golang.org/api/support/bundler..Bundler.BundleCountThreshold.html" class="ident">BundleCountThreshold</a> <a href="../../../../../pkg/builtin.html#name-int" class="ident">int</a>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Once the number of bytes in current bundle reaches this threshold, handle</span><span class="comment">	 the bundle. The default is DefaultBundleByteThreshold. This triggers handling,</span><span class="comment">	 but does not cap the total size of a bundle.</span></div>
<div class="code"><pre><code>	<a href="../../../../../use/google.golang.org/api/support/bundler..Bundler.BundleByteThreshold.html" class="ident">BundleByteThreshold</a> <a href="../../../../../pkg/builtin.html#name-int" class="ident">int</a>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> The maximum size of a bundle, in bytes. Zero means unlimited.</span></div>
<div class="code"><pre><code>	<a href="../../../../../use/google.golang.org/api/support/bundler..Bundler.BundleByteLimit.html" class="ident">BundleByteLimit</a> <a href="../../../../../pkg/builtin.html#name-int" class="ident">int</a>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> The maximum number of bytes that the Bundler will keep in memory before</span><span class="comment">	 returning ErrOverflow. The default is DefaultBufferedByteLimit.</span></div>
<div class="code"><pre><code>	<a href="../../../../../use/google.golang.org/api/support/bundler..Bundler.BufferedByteLimit.html" class="ident">BufferedByteLimit</a> <a href="../../../../../pkg/builtin.html#name-int" class="ident">int</a>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> The maximum number of handler invocations that can be running at once.</span><span class="comment">	 The default is 1.</span></div>
<div class="code"><pre><code>	<a href="../../../../../use/google.golang.org/api/support/bundler..Bundler.HandlerLimit.html" class="ident">HandlerLimit</a> <a href="../../../../../pkg/builtin.html#name-int" class="ident">int</a>

	<a href="../../../../../use/google.golang.org/api/support/bundler..Bundler.handler*31283.html" class="ident">handler</a>       <span class="keyword">func</span>(<span class="keyword">interface</span>{}) <span class="comment">// called to handle a bundle</span>
	<a href="../../../../../use/google.golang.org/api/support/bundler..Bundler.itemSliceZero*6f512.html" class="ident">itemSliceZero</a> <a href="../../../../../pkg/reflect.html" class="ident i2">reflect</a>.<a href="../../../../reflect/value.go.html#line-37" class="ident">Value</a>     <span class="comment">// nil (zero value) for slice of items</span>

	<a href="../../../../../use/google.golang.org/api/support/bundler..Bundler.mu*19503.html" class="ident">mu</a>           <a href="../../../../../pkg/sync.html" class="ident i3">sync</a>.<a href="../../../../sync/mutex.go.html#line-25" class="ident">Mutex</a>          <span class="comment">// guards access to fields below</span>
	<a href="../../../../../use/google.golang.org/api/support/bundler..Bundler.flushTimer*aef46.html" class="ident">flushTimer</a>   *<a href="../../../../../pkg/time.html" class="ident i4">time</a>.<a href="../../../../time/sleep.go.html#line-50" class="ident">Timer</a>         <span class="comment">// implements DelayThreshold</span>
	<a href="../../../../../use/google.golang.org/api/support/bundler..Bundler.handlerCount*30d73.html" class="ident">handlerCount</a> <a href="../../../../../pkg/builtin.html#name-int" class="ident">int</a>                 <span class="comment">// # of bundles currently being handled (i.e. handler is invoked on them)</span>
	<a href="../../../../../use/google.golang.org/api/support/bundler..Bundler.sem*e604f.html" class="ident">sem</a>          *<a href="../../../../../pkg/golang.org/x/sync/semaphore.html" class="ident i5">semaphore</a>.<a href="../../../../golang.org/x/sync/semaphore/semaphore.go.html#line-28" class="ident">Weighted</a> <span class="comment">// enforces BufferedByteLimit</span>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> The current bundle we're adding items to. Not yet in the queue.</span><span class="comment">	 Appended to the queue once the flushTimer fires or the bundle</span><span class="comment">	 thresholds/limits are reached. If curBundle is nil and tail is</span><span class="comment">	 not, we first try to add items to tail. Once tail is full or handled,</span><span class="comment">	 we create a new curBundle for the incoming item.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> The next bundle in the queue to be handled. Nil if the queue is</span><span class="comment">	 empty.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> The last bundle in the queue to be handled. Nil if the queue is</span><span class="comment">	 empty. If curBundle is nil and tail isn't, we attempt to add new</span><span class="comment">	 items to the tail until if becomes full or has been passed to the</span><span class="comment">	 handler.</span></div>
<div class="code"><pre><code>	<a href="../../../../../use/google.golang.org/api/support/bundler..Bundler.tail*0c62f.html" class="ident">tail</a>      *<a href="#line-118" class="ident">bundle</a>
	<a href="../../../../../use/google.golang.org/api/support/bundler..Bundler.curFlush*5705d.html" class="ident">curFlush</a>  *<a href="../../../../../pkg/sync.html" class="ident i3">sync</a>.<a href="../../../../sync/waitgroup.go.html#line-20" class="ident">WaitGroup</a> <span class="comment">// counts outstanding bundles since last flush</span>
	<a href="../../../../../use/google.golang.org/api/support/bundler..Bundler.prevFlush*fd860.html" class="ident">prevFlush</a> <span class="keyword">chan</span> <a href="../../../../../pkg/builtin.html#name-bool" class="ident">bool</a>       <span class="comment">// signal used to wait for prior flush</span>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> The first call to Add or AddWait, mode will be add or addWait respectively.</span><span class="comment">	 If there wasn't call yet then mode is none.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> TODO: consider alternative queue implementation for head/tail bundle. see:</span><span class="comment">	 https://code-review.googlesource.com/c/google-api-go-client/+/47991/4/support/bundler/bundler.go#74</span></div>
<div class="code"><pre><code>}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> A bundle is a group of items that were added individually and will be passed</span><span class="comment"> to a handler as a slice.</span></div>
<div class="code"><pre><code><span class="keyword">type</span> <a href="../../../../../pkg/google.golang.org/api/support/bundler.html#name-bundle" class="ident">bundle</a> <span class="keyword">struct</span> {
	<a href="../../../../../use/google.golang.org/api/support/bundler..bundle*1e6ed.items*5f3c4.html" class="ident">items</a> <a href="../../../../../pkg/reflect.html" class="ident i2">reflect</a>.<a href="../../../../reflect/value.go.html#line-37" class="ident">Value</a>   <span class="comment">// slice of T</span>
	<a href="../../../../../use/google.golang.org/api/support/bundler..bundle*1e6ed.size*ccdcb.html" class="ident">size</a>  <a href="../../../../../pkg/builtin.html#name-int" class="ident">int</a>             <span class="comment">// size in bytes of all items</span>
	<a href="../../../../../use/google.golang.org/api/support/bundler..bundle*1e6ed.next*c6c1c.html" class="ident">next</a>  *<a href="#line-118" class="ident">bundle</a>         <span class="comment">// bundles are handled in order as a linked list queue</span>
	<a href="../../../../../use/google.golang.org/api/support/bundler..bundle*1e6ed.flush*f5617.html" class="ident">flush</a> *<a href="../../../../../pkg/sync.html" class="ident i3">sync</a>.<a href="../../../../sync/waitgroup.go.html#line-20" class="ident">WaitGroup</a> <span class="comment">// the counter that tracks flush completion</span>
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> add appends item to this bundle and increments the total size. It requires</span><span class="comment"> that b.mu is locked.</span></div>
<div class="code"><pre><code><span class="keyword">func</span> (<label for="r0" class="ident">bu</label> *<a href="#line-118" class="ident">bundle</a>) <label for="r1" class="ident"><a href="../../../../../use/google.golang.org/api/support/bundler..bundle*1e6ed.add*7e9e5.html" class="ident">add</a></label>(<label for="r2" class="ident">item</label> <span class="keyword">interface</span>{}, <label for="r3" class="ident">size</label> <a href="../../../../../pkg/builtin.html#name-int" class="ident">int</a>) {
	<label for="r0" class="ident">bu</label>.<a href="#line-119" class="ident">items</a> = <a href="../../../../../pkg/reflect.html" class="ident i2">reflect</a>.<a href="../../../../reflect/value.go.html#line-2047" class="ident">Append</a>(<label for="r0" class="ident">bu</label>.<a href="#line-119" class="ident">items</a>, <a href="../../../../../pkg/reflect.html" class="ident i2">reflect</a>.<a href="../../../../reflect/value.go.html#line-2351" class="ident">ValueOf</a>(<label for="r2" class="ident">item</label>))
	<label for="r0" class="ident">bu</label>.<a href="#line-120" class="ident">size</a> += <label for="r3" class="ident">size</label>
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> NewBundler creates a new Bundler.</span><span class="comment"></span><span class="comment"> itemExample is a value of the type that will be bundled. For example, if you</span><span class="comment"> want to create bundles of *Entry, you could pass &amp;Entry{} for itemExample.</span><span class="comment"></span><span class="comment"> handler is a function that will be called on each bundle. If itemExample is</span><span class="comment"> of type T, the argument to handler is of type []T. handler is always called</span><span class="comment"> sequentially for each bundle, and never in parallel.</span><span class="comment"></span><span class="comment"> Configure the Bundler by setting its thresholds and limits before calling</span><span class="comment"> any of its methods.</span></div>
<div class="code"><pre><code><span class="keyword">func</span> <label for="r4" class="ident"><a href="../../../../../pkg/google.golang.org/api/support/bundler.html#name-NewBundler" class="ident">NewBundler</a></label>(<label for="r5" class="ident">itemExample</label> <span class="keyword">interface</span>{}, <label for="r6" class="ident">handler</label> <span class="keyword">func</span>(<span class="keyword">interface</span>{})) *<a href="#line-57" class="ident">Bundler</a> {
	<label for="r7" class="ident">b</label> := &amp;<a href="#line-57" class="ident">Bundler</a>{
		<a href="#line-60" class="ident">DelayThreshold</a>:       <a href="#line-27" class="ident">DefaultDelayThreshold</a>,
		<a href="#line-66" class="ident">BundleCountThreshold</a>: <a href="#line-28" class="ident">DefaultBundleCountThreshold</a>,
		<a href="#line-71" class="ident">BundleByteThreshold</a>:  <a href="#line-29" class="ident">DefaultBundleByteThreshold</a>,
		<a href="#line-78" class="ident">BufferedByteLimit</a>:    <a href="#line-30" class="ident">DefaultBufferedByteLimit</a>,
		<a href="#line-82" class="ident">HandlerLimit</a>:         <span class="lit-number">1</span>,

		<a href="#line-84" class="ident">handler</a>:       <label for="r6" class="ident">handler</label>,
		<a href="#line-85" class="ident">itemSliceZero</a>: <a href="../../../../../pkg/reflect.html" class="ident i2">reflect</a>.<a href="../../../../reflect/value.go.html#line-2370" class="ident">Zero</a>(<a href="../../../../../pkg/reflect.html" class="ident i2">reflect</a>.<a href="../../../../reflect/type.go.html#line-2287" class="ident">SliceOf</a>(<a href="../../../../../pkg/reflect.html" class="ident i2">reflect</a>.<a href="../../../../reflect/type.go.html#line-1368" class="ident">TypeOf</a>(<label for="r5" class="ident">itemExample</label>))),
		<a href="#line-106" class="ident">curFlush</a>:      &amp;<a href="../../../../../pkg/sync.html" class="ident i3">sync</a>.<a href="../../../../sync/waitgroup.go.html#line-20" class="ident">WaitGroup</a>{},
	}
	<span class="keyword">return</span> <label for="r7" class="ident">b</label>
}

</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Create the semaphores lazily, because the user may set limits</span><span class="comment">	 after NewBundler.</span></div>
<div class="code"><pre><code>	<label for="r8" class="ident">b</label>.<a href="#line-91" class="ident">semOnce</a>.<a href="../../../../sync/once.go.html#line-42" class="ident">Do</a>(<span class="keyword">func</span>() {
		<label for="r8" class="ident">b</label>.<a href="#line-90" class="ident">sem</a> = <a href="../../../../../pkg/golang.org/x/sync/semaphore.html" class="ident i5">semaphore</a>.<a href="../../../../golang.org/x/sync/semaphore/semaphore.go.html#line-21" class="ident">NewWeighted</a>(<a href="../../../../../pkg/builtin.html#name-int64" class="ident">int64</a>(<label for="r8" class="ident">b</label>.<a href="#line-78" class="ident">BufferedByteLimit</a>))
	})
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> enqueueCurBundle moves curBundle to the end of the queue. The bundle may be</span><span class="comment"> handled immediately if we are below HandlerLimit. It requires that b.mu is</span><span class="comment"> locked.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> We don't require callers to check if there is a pending bundle. It</span><span class="comment">	 may have already been appended to the queue. If so, return early.</span></div>
<div class="code"><pre><code>	<span class="keyword">if</span> <label for="r10" class="ident">b</label>.<a href="#line-97" class="ident">curBundle</a> == <a href="../../../../../pkg/builtin.html#name-nil" class="ident">nil</a> {
		<span class="keyword">return</span>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> If we are below the HandlerLimit, the queue must be empty. Handle</span><span class="comment">	 immediately with a new goroutine.</span></div>
<div class="code"><pre><code>	<span class="keyword">if</span> <label for="r10" class="ident">b</label>.<a href="#line-89" class="ident">handlerCount</a> &lt; <label for="r10" class="ident">b</label>.<a href="#line-82" class="ident">HandlerLimit</a> {
		<label for="r10" class="ident">b</label>.<a href="#line-89" class="ident">handlerCount</a>++
		<span class="keyword">go</span> <label for="r10" class="ident">b</label>.<a href="#line-322" class="ident">handle</a>(<label for="r10" class="ident">b</label>.<a href="#line-97" class="ident">curBundle</a>)
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> There are bundles on the queue, so append to the end</span></div>
<div class="code"><pre><code>		<label for="r10" class="ident">b</label>.<a href="#line-105" class="ident">tail</a>.<a href="#line-121" class="ident">next</a> = <label for="r10" class="ident">b</label>.<a href="#line-97" class="ident">curBundle</a>
		<label for="r10" class="ident">b</label>.<a href="#line-105" class="ident">tail</a> = <label for="r10" class="ident">b</label>.<a href="#line-97" class="ident">curBundle</a>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> The queue is empty, so initialize the queue</span></div>
<div class="code"><pre><code>		<label for="r10" class="ident">b</label>.<a href="#line-100" class="ident">head</a> = <label for="r10" class="ident">b</label>.<a href="#line-97" class="ident">curBundle</a>
		<label for="r10" class="ident">b</label>.<a href="#line-105" class="ident">tail</a> = <label for="r10" class="ident">b</label>.<a href="#line-97" class="ident">curBundle</a>
	}
	<label for="r10" class="ident">b</label>.<a href="#line-97" class="ident">curBundle</a> = <a href="../../../../../pkg/builtin.html#name-nil" class="ident">nil</a>
	<span class="keyword">if</span> <label for="r10" class="ident">b</label>.<a href="#line-88" class="ident">flushTimer</a> != <a href="../../../../../pkg/builtin.html#name-nil" class="ident">nil</a> {
		<label for="r10" class="ident">b</label>.<a href="#line-88" class="ident">flushTimer</a>.<a href="../../../../time/sleep.go.html#line-77" class="ident">Stop</a>()
		<label for="r10" class="ident">b</label>.<a href="#line-88" class="ident">flushTimer</a> = <a href="../../../../../pkg/builtin.html#name-nil" class="ident">nil</a>
	}
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> setMode sets the state of Bundler's mode. If mode was defined before</span><span class="comment"> and passed state is different from it then return an error.</span></div>
<div class="code"><pre><code><span class="keyword">func</span> (<label for="r12" class="ident">b</label> *<a href="#line-57" class="ident">Bundler</a>) <label for="r13" class="ident"><a href="../../../../../use/google.golang.org/api/support/bundler..Bundler.setMode*99131.html" class="ident">setMode</a></label>(<label for="r14" class="ident">m</label> <a href="#line-24" class="ident">mode</a>) <a href="../../../../../pkg/builtin.html#name-error" class="ident">error</a> {
	<label for="r12" class="ident">b</label>.<a href="#line-87" class="ident">mu</a>.<a href="../../../../sync/mutex.go.html#line-72" class="ident">Lock</a>()
	<span class="keyword">defer</span> <label for="r12" class="ident">b</label>.<a href="#line-87" class="ident">mu</a>.<a href="../../../../sync/mutex.go.html#line-179" class="ident">Unlock</a>()
	<span class="keyword">if</span> <label for="r12" class="ident">b</label>.<a href="#line-111" class="ident">mode</a> == <label for="r14" class="ident">m</label> || <label for="r12" class="ident">b</label>.<a href="#line-111" class="ident">mode</a> == <a href="#line-34" class="ident">none</a> {
		<label for="r12" class="ident">b</label>.<a href="#line-111" class="ident">mode</a> = <label for="r14" class="ident">m</label>
		<span class="keyword">return</span> <a href="../../../../../pkg/builtin.html#name-nil" class="ident">nil</a>
	}
	<span class="keyword">return</span> <a href="#line-48" class="ident">errMixedMethods</a>
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> canFit returns true if bu can fit an additional item of size bytes based</span><span class="comment"> on the limits of Bundler b.</span></div>
<div class="code"><pre><code><span class="keyword">func</span> (<label for="r15" class="ident">b</label> *<a href="#line-57" class="ident">Bundler</a>) <label for="r16" class="ident"><a href="../../../../../use/google.golang.org/api/support/bundler..Bundler.canFit*17842.html" class="ident">canFit</a></label>(<label for="r17" class="ident">bu</label> *<a href="#line-118" class="ident">bundle</a>, <label for="r18" class="ident">size</label> <a href="../../../../../pkg/builtin.html#name-int" class="ident">int</a>) <a href="../../../../../pkg/builtin.html#name-bool" class="ident">bool</a> {
	<span class="keyword">return</span> (<label for="r15" class="ident">b</label>.<a href="#line-74" class="ident">BundleByteLimit</a> &lt;= <span class="lit-number">0</span> || <label for="r17" class="ident">bu</label>.<a href="#line-120" class="ident">size</a>+<label for="r18" class="ident">size</label> &lt;= <label for="r15" class="ident">b</label>.<a href="#line-74" class="ident">BundleByteLimit</a>) &amp;&amp;
		(<label for="r15" class="ident">b</label>.<a href="#line-66" class="ident">BundleCountThreshold</a> &lt;= <span class="lit-number">0</span> || <label for="r17" class="ident">bu</label>.<a href="#line-119" class="ident">items</a>.<a href="../../../../reflect/value.go.html#line-1146" class="ident">Len</a>() &lt; <label for="r15" class="ident">b</label>.<a href="#line-66" class="ident">BundleCountThreshold</a>)
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Add adds item to the current bundle. It marks the bundle for handling and</span><span class="comment"> starts a new one if any of the thresholds or limits are exceeded.</span><span class="comment"> The type of item must be assignable to the itemExample parameter of the NewBundler</span><span class="comment"> method, otherwise there will be a panic.</span><span class="comment"></span><span class="comment"> If the item's size exceeds the maximum bundle size (Bundler.BundleByteLimit), then</span><span class="comment"> the item can never be handled. Add returns ErrOversizedItem in this case.</span><span class="comment"></span><span class="comment"> If adding the item would exceed the maximum memory allowed</span><span class="comment"> (Bundler.BufferedByteLimit) or an AddWait call is blocked waiting for</span><span class="comment"> memory, Add returns ErrOverflow.</span><span class="comment"></span><span class="comment"> Add never blocks.</span></div>
<div class="code"><pre><code><span class="keyword">func</span> (<label for="r19" class="ident">b</label> *<a href="#line-57" class="ident">Bundler</a>) <label for="r20" class="ident"><a href="../../../../../use/google.golang.org/api/support/bundler..Bundler.Add.html" class="ident">Add</a></label>(<label for="r21" class="ident">item</label> <span class="keyword">interface</span>{}, <label for="r22" class="ident">size</label> <a href="../../../../../pkg/builtin.html#name-int" class="ident">int</a>) <a href="../../../../../pkg/builtin.html#name-error" class="ident">error</a> {
	<span class="keyword">if</span> <label for="r23" class="ident">err</label> := <label for="r19" class="ident">b</label>.<a href="#line-198" class="ident">setMode</a>(<a href="#line-35" class="ident">add</a>); <label for="r23" class="ident">err</label> != <a href="../../../../../pkg/builtin.html#name-nil" class="ident">nil</a> {
		<span class="keyword">return</span> <label for="r23" class="ident">err</label>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> If this item exceeds the maximum size of a bundle,</span><span class="comment">	 we can never send it.</span></div>
<div class="code"><pre><code>	<span class="keyword">if</span> <label for="r19" class="ident">b</label>.<a href="#line-74" class="ident">BundleByteLimit</a> &gt; <span class="lit-number">0</span> &amp;&amp; <label for="r22" class="ident">size</label> &gt; <label for="r19" class="ident">b</label>.<a href="#line-74" class="ident">BundleByteLimit</a> {
		<span class="keyword">return</span> <a href="#line-44" class="ident">ErrOversizedItem</a>
	}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> If adding this item would exceed our allotted memory</span><span class="comment">	 footprint, we can't accept it.</span><span class="comment">	 (TryAcquire also returns false if anything is waiting on the semaphore,</span><span class="comment">	 so calls to Add and AddWait shouldn't be mixed.)</span></div>
<div class="code"><pre><code>	<label for="r19" class="ident">b</label>.<a href="#line-158" class="ident">initSemaphores</a>()
	<span class="keyword">if</span> !<label for="r19" class="ident">b</label>.<a href="#line-90" class="ident">sem</a>.<a href="../../../../golang.org/x/sync/semaphore/semaphore.go.html#line-87" class="ident">TryAcquire</a>(<a href="../../../../../pkg/builtin.html#name-int64" class="ident">int64</a>(<label for="r22" class="ident">size</label>)) {
		<span class="keyword">return</span> <a href="#line-41" class="ident">ErrOverflow</a>
	}

	<label for="r19" class="ident">b</label>.<a href="#line-87" class="ident">mu</a>.<a href="../../../../sync/mutex.go.html#line-72" class="ident">Lock</a>()
	<span class="keyword">defer</span> <label for="r19" class="ident">b</label>.<a href="#line-87" class="ident">mu</a>.<a href="../../../../sync/mutex.go.html#line-179" class="ident">Unlock</a>()
	<span class="keyword">return</span> <label for="r19" class="ident">b</label>.<a href="#line-256" class="ident">add</a>(<label for="r21" class="ident">item</label>, <label for="r22" class="ident">size</label>)
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> add adds item to the tail of the bundle queue or curBundle depending on space</span><span class="comment"> and nil-ness (see inline comments). It marks curBundle for handling (by</span><span class="comment"> appending it to the queue) if any of the thresholds or limits are exceeded.</span><span class="comment"> curBundle is lazily initialized. It requires that b.mu is locked.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> If we don't have a curBundle, see if we can add to the queue tail.</span></div>
<div class="code"><pre><code>	<span class="keyword">if</span> <label for="r24" class="ident">b</label>.<a href="#line-105" class="ident">tail</a> != <a href="../../../../../pkg/builtin.html#name-nil" class="ident">nil</a> &amp;&amp; <label for="r24" class="ident">b</label>.<a href="#line-97" class="ident">curBundle</a> == <a href="../../../../../pkg/builtin.html#name-nil" class="ident">nil</a> &amp;&amp; <label for="r24" class="ident">b</label>.<a href="#line-210" class="ident">canFit</a>(<label for="r24" class="ident">b</label>.<a href="#line-105" class="ident">tail</a>, <label for="r27" class="ident">size</label>) {
		<label for="r24" class="ident">b</label>.<a href="#line-105" class="ident">tail</a>.<a href="#line-127" class="ident">add</a>(<label for="r26" class="ident">item</label>, <label for="r27" class="ident">size</label>)
		<span class="keyword">return</span> <a href="../../../../../pkg/builtin.html#name-nil" class="ident">nil</a>
	}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> If we can't fit in the existing curBundle, move it onto the queue.</span></div>
<div class="code"><pre><code>	<span class="keyword">if</span> <label for="r24" class="ident">b</label>.<a href="#line-97" class="ident">curBundle</a> != <a href="../../../../../pkg/builtin.html#name-nil" class="ident">nil</a> &amp;&amp; !<label for="r24" class="ident">b</label>.<a href="#line-210" class="ident">canFit</a>(<label for="r24" class="ident">b</label>.<a href="#line-97" class="ident">curBundle</a>, <label for="r27" class="ident">size</label>) {
		<label for="r24" class="ident">b</label>.<a href="#line-169" class="ident">enqueueCurBundle</a>()
	}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Create a curBundle if we don't have one.</span></div>
<div class="code"><pre><code>	<span class="keyword">if</span> <label for="r24" class="ident">b</label>.<a href="#line-97" class="ident">curBundle</a> == <a href="../../../../../pkg/builtin.html#name-nil" class="ident">nil</a> {
		<label for="r24" class="ident">b</label>.<a href="#line-106" class="ident">curFlush</a>.<a href="../../../../sync/waitgroup.go.html#line-53" class="ident">Add</a>(<span class="lit-number">1</span>)
		<label for="r24" class="ident">b</label>.<a href="#line-97" class="ident">curBundle</a> = &amp;<a href="#line-118" class="ident">bundle</a>{
			<a href="#line-119" class="ident">items</a>: <label for="r24" class="ident">b</label>.<a href="#line-85" class="ident">itemSliceZero</a>,
			<a href="#line-122" class="ident">flush</a>: <label for="r24" class="ident">b</label>.<a href="#line-106" class="ident">curFlush</a>,
		}
	}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Add the item.</span></div>
<div class="code"><pre><code>	<label for="r24" class="ident">b</label>.<a href="#line-97" class="ident">curBundle</a>.<a href="#line-127" class="ident">add</a>(<label for="r26" class="ident">item</label>, <label for="r27" class="ident">size</label>)
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> If curBundle is ready for handling, move it to the queue.</span></div>
<div class="code"><pre><code>	<span class="keyword">if</span> <label for="r24" class="ident">b</label>.<a href="#line-97" class="ident">curBundle</a>.<a href="#line-120" class="ident">size</a> &gt;= <label for="r24" class="ident">b</label>.<a href="#line-71" class="ident">BundleByteThreshold</a> ||
		<label for="r24" class="ident">b</label>.<a href="#line-97" class="ident">curBundle</a>.<a href="#line-119" class="ident">items</a>.<a href="../../../../reflect/value.go.html#line-1146" class="ident">Len</a>() == <label for="r24" class="ident">b</label>.<a href="#line-66" class="ident">BundleCountThreshold</a> {
		<label for="r24" class="ident">b</label>.<a href="#line-169" class="ident">enqueueCurBundle</a>()
	}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> If we created a new bundle and it wasn't immediately handled, set a timer</span></div>
<div class="code"><pre><code>	<span class="keyword">if</span> <label for="r24" class="ident">b</label>.<a href="#line-97" class="ident">curBundle</a> != <a href="../../../../../pkg/builtin.html#name-nil" class="ident">nil</a> &amp;&amp; <label for="r24" class="ident">b</label>.<a href="#line-88" class="ident">flushTimer</a> == <a href="../../../../../pkg/builtin.html#name-nil" class="ident">nil</a> {
		<label for="r24" class="ident">b</label>.<a href="#line-88" class="ident">flushTimer</a> = <a href="../../../../../pkg/time.html" class="ident i4">time</a>.<a href="../../../../time/sleep.go.html#line-167" class="ident">AfterFunc</a>(<label for="r24" class="ident">b</label>.<a href="#line-60" class="ident">DelayThreshold</a>, <label for="r24" class="ident">b</label>.<a href="#line-296" class="ident">tryHandleBundles</a>)
	}

	<span class="keyword">return</span> <a href="../../../../../pkg/builtin.html#name-nil" class="ident">nil</a>
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> tryHandleBundles is the timer callback that handles or queues any current</span><span class="comment"> bundle after DelayThreshold time, even if the bundle isn't completely full.</span></div>
<div class="code"><pre><code><span class="keyword">func</span> (<label for="r28" class="ident">b</label> *<a href="#line-57" class="ident">Bundler</a>) <label for="r29" class="ident"><a href="../../../../../use/google.golang.org/api/support/bundler..Bundler.tryHandleBundles*b792b.html" class="ident">tryHandleBundles</a></label>() {
	<label for="r28" class="ident">b</label>.<a href="#line-87" class="ident">mu</a>.<a href="../../../../sync/mutex.go.html#line-72" class="ident">Lock</a>()
	<label for="r28" class="ident">b</label>.<a href="#line-169" class="ident">enqueueCurBundle</a>()
	<label for="r28" class="ident">b</label>.<a href="#line-87" class="ident">mu</a>.<a href="../../../../sync/mutex.go.html#line-179" class="ident">Unlock</a>()
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> next returns the next bundle that is ready for handling and removes it from</span><span class="comment"> the internal queue. It requires that b.mu is locked.</span></div>
<div class="code"><pre><code><span class="keyword">func</span> (<label for="r30" class="ident">b</label> *<a href="#line-57" class="ident">Bundler</a>) <label for="r31" class="ident"><a href="../../../../../use/google.golang.org/api/support/bundler..Bundler.next*c6c1c.html" class="ident">next</a></label>() *<a href="#line-118" class="ident">bundle</a> {
	<span class="keyword">if</span> <label for="r30" class="ident">b</label>.<a href="#line-100" class="ident">head</a> == <a href="../../../../../pkg/builtin.html#name-nil" class="ident">nil</a> {
		<span class="keyword">return</span> <a href="../../../../../pkg/builtin.html#name-nil" class="ident">nil</a>
	}
	<label for="r32" class="ident">out</label> := <label for="r30" class="ident">b</label>.<a href="#line-100" class="ident">head</a>
	<label for="r30" class="ident">b</label>.<a href="#line-100" class="ident">head</a> = <label for="r30" class="ident">b</label>.<a href="#line-100" class="ident">head</a>.<a href="#line-121" class="ident">next</a>
	<span class="keyword">if</span> <label for="r30" class="ident">b</label>.<a href="#line-100" class="ident">head</a> == <a href="../../../../../pkg/builtin.html#name-nil" class="ident">nil</a> {
		<label for="r30" class="ident">b</label>.<a href="#line-105" class="ident">tail</a> = <a href="../../../../../pkg/builtin.html#name-nil" class="ident">nil</a>
	}
	<label for="r32" class="ident">out</label>.<a href="#line-121" class="ident">next</a> = <a href="../../../../../pkg/builtin.html#name-nil" class="ident">nil</a>
	<span class="keyword">return</span> <label for="r32" class="ident">out</label>
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> handle calls the user-specified handler on the given bundle. handle is</span><span class="comment"> intended to be run as a goroutine. After the handler returns, we update the</span><span class="comment"> byte total. handle continues processing additional bundles that are ready.</span><span class="comment"> If no more bundles are ready, the handler count is decremented and the</span><span class="comment"> goroutine ends.</span></div>
<div class="code"><pre><code><span class="keyword">func</span> (<label for="r33" class="ident">b</label> *<a href="#line-57" class="ident">Bundler</a>) <label for="r34" class="ident"><a href="../../../../../use/google.golang.org/api/support/bundler..Bundler.handle*c2a11.html" class="ident">handle</a></label>(<label for="r35" class="ident">bu</label> *<a href="#line-118" class="ident">bundle</a>) {
	<span class="keyword">for</span> <label for="r35" class="ident">bu</label> != <a href="../../../../../pkg/builtin.html#name-nil" class="ident">nil</a> {
		<label for="r33" class="ident">b</label>.<a href="#line-84" class="ident">handler</a>(<label for="r35" class="ident">bu</label>.<a href="#line-119" class="ident">items</a>.<a href="../../../../reflect/value.go.html#line-1015" class="ident">Interface</a>())
		<label for="r35" class="ident">bu</label> = <label for="r33" class="ident">b</label>.<a href="#line-329" class="ident">postHandle</a>(<label for="r35" class="ident">bu</label>)
	}
}

<span class="keyword">func</span> (<label for="r36" class="ident">b</label> *<a href="#line-57" class="ident">Bundler</a>) <label for="r37" class="ident"><a href="../../../../../use/google.golang.org/api/support/bundler..Bundler.postHandle*58735.html" class="ident">postHandle</a></label>(<label for="r38" class="ident">bu</label> *<a href="#line-118" class="ident">bundle</a>) *<a href="#line-118" class="ident">bundle</a> {
	<label for="r36" class="ident">b</label>.<a href="#line-87" class="ident">mu</a>.<a href="../../../../sync/mutex.go.html#line-72" class="ident">Lock</a>()
	<span class="keyword">defer</span> <label for="r36" class="ident">b</label>.<a href="#line-87" class="ident">mu</a>.<a href="../../../../sync/mutex.go.html#line-179" class="ident">Unlock</a>()

	<label for="r36" class="ident">b</label>.<a href="#line-90" class="ident">sem</a>.<a href="../../../../golang.org/x/sync/semaphore/semaphore.go.html#line-98" class="ident">Release</a>(<a href="../../../../../pkg/builtin.html#name-int64" class="ident">int64</a>(<label for="r38" class="ident">bu</label>.<a href="#line-120" class="ident">size</a>))
	<label for="r38" class="ident">bu</label>.<a href="#line-122" class="ident">flush</a>.<a href="../../../../sync/waitgroup.go.html#line-98" class="ident">Done</a>()

	<label for="r38" class="ident">bu</label> = <label for="r36" class="ident">b</label>.<a href="#line-304" class="ident">next</a>()
	<span class="keyword">if</span> <label for="r38" class="ident">bu</label> == <a href="../../../../../pkg/builtin.html#name-nil" class="ident">nil</a> {
		<label for="r36" class="ident">b</label>.<a href="#line-89" class="ident">handlerCount</a>--
	}
	<span class="keyword">return</span> <label for="r38" class="ident">bu</label>
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> AddWait adds item to the current bundle. It marks the bundle for handling and</span><span class="comment"> starts a new one if any of the thresholds or limits are exceeded.</span><span class="comment"></span><span class="comment"> If the item's size exceeds the maximum bundle size (Bundler.BundleByteLimit), then</span><span class="comment"> the item can never be handled. AddWait returns ErrOversizedItem in this case.</span><span class="comment"></span><span class="comment"> If adding the item would exceed the maximum memory allowed (Bundler.BufferedByteLimit),</span><span class="comment"> AddWait blocks until space is available or ctx is done.</span><span class="comment"></span><span class="comment"> Calls to Add and AddWait should not be mixed on the same Bundler.</span></div>
<div class="code"><pre><code><span class="keyword">func</span> (<label for="r39" class="ident">b</label> *<a href="#line-57" class="ident">Bundler</a>) <label for="r40" class="ident"><a href="../../../../../use/google.golang.org/api/support/bundler..Bundler.AddWait.html" class="ident">AddWait</a></label>(<label for="r41" class="ident">ctx</label> <a href="../../../../../pkg/context.html" class="ident i0">context</a>.<a href="../../../../context/context.go.html#line-62" class="ident">Context</a>, <label for="r42" class="ident">item</label> <span class="keyword">interface</span>{}, <label for="r43" class="ident">size</label> <a href="../../../../../pkg/builtin.html#name-int" class="ident">int</a>) <a href="../../../../../pkg/builtin.html#name-error" class="ident">error</a> {
	<span class="keyword">if</span> <label for="r44" class="ident">err</label> := <label for="r39" class="ident">b</label>.<a href="#line-198" class="ident">setMode</a>(<a href="#line-36" class="ident">addWait</a>); <label for="r44" class="ident">err</label> != <a href="../../../../../pkg/builtin.html#name-nil" class="ident">nil</a> {
		<span class="keyword">return</span> <label for="r44" class="ident">err</label>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> If this item exceeds the maximum size of a bundle,</span><span class="comment">	 we can never send it.</span></div>
<div class="code"><pre><code>	<span class="keyword">if</span> <label for="r39" class="ident">b</label>.<a href="#line-74" class="ident">BundleByteLimit</a> &gt; <span class="lit-number">0</span> &amp;&amp; <label for="r43" class="ident">size</label> &gt; <label for="r39" class="ident">b</label>.<a href="#line-74" class="ident">BundleByteLimit</a> {
		<span class="keyword">return</span> <a href="#line-44" class="ident">ErrOversizedItem</a>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> If adding this item would exceed our allotted memory footprint, block</span><span class="comment">	 until space is available. The semaphore is FIFO, so there will be no</span><span class="comment">	 starvation.</span></div>
<div class="code"><pre><code>	<label for="r39" class="ident">b</label>.<a href="#line-158" class="ident">initSemaphores</a>()
	<span class="keyword">if</span> <label for="r45" class="ident">err</label> := <label for="r39" class="ident">b</label>.<a href="#line-90" class="ident">sem</a>.<a href="../../../../golang.org/x/sync/semaphore/semaphore.go.html#line-40" class="ident">Acquire</a>(<label for="r41" class="ident">ctx</label>, <a href="../../../../../pkg/builtin.html#name-int64" class="ident">int64</a>(<label for="r43" class="ident">size</label>)); <label for="r45" class="ident">err</label> != <a href="../../../../../pkg/builtin.html#name-nil" class="ident">nil</a> {
		<span class="keyword">return</span> <label for="r45" class="ident">err</label>
	}

	<label for="r39" class="ident">b</label>.<a href="#line-87" class="ident">mu</a>.<a href="../../../../sync/mutex.go.html#line-72" class="ident">Lock</a>()
	<span class="keyword">defer</span> <label for="r39" class="ident">b</label>.<a href="#line-87" class="ident">mu</a>.<a href="../../../../sync/mutex.go.html#line-179" class="ident">Unlock</a>()
	<span class="keyword">return</span> <label for="r39" class="ident">b</label>.<a href="#line-256" class="ident">add</a>(<label for="r42" class="ident">item</label>, <label for="r43" class="ident">size</label>)
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Flush invokes the handler for all remaining items in the Bundler and waits</span><span class="comment"> for it to return.</span></div>
<div class="code"><pre><code><span class="keyword">func</span> (<label for="r46" class="ident">b</label> *<a href="#line-57" class="ident">Bundler</a>) <label for="r47" class="ident"><a href="../../../../../use/google.golang.org/api/support/bundler..Bundler.Flush.html" class="ident">Flush</a></label>() {
	<label for="r46" class="ident">b</label>.<a href="#line-87" class="ident">mu</a>.<a href="../../../../sync/mutex.go.html#line-72" class="ident">Lock</a>()
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> If a curBundle is pending, move it to the queue.</span></div>
<div class="code"><pre><code>	<label for="r46" class="ident">b</label>.<a href="#line-169" class="ident">enqueueCurBundle</a>()
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Store a pointer to the WaitGroup that counts outstanding bundles</span><span class="comment">	 in the current flush and create a new one to track the next flush.</span></div>
<div class="code"><pre><code>	<label for="r48" class="ident">wg</label> := <label for="r46" class="ident">b</label>.<a href="#line-106" class="ident">curFlush</a>
	<label for="r46" class="ident">b</label>.<a href="#line-106" class="ident">curFlush</a> = &amp;<a href="../../../../../pkg/sync.html" class="ident i3">sync</a>.<a href="../../../../sync/waitgroup.go.html#line-20" class="ident">WaitGroup</a>{}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Flush must wait for all prior, outstanding flushes to complete.</span><span class="comment">	 We use a channel to communicate completion between each flush in</span><span class="comment">	 the sequence.</span></div>
<div class="code"><pre><code>	<label for="r49" class="ident">prev</label> := <label for="r46" class="ident">b</label>.<a href="#line-107" class="ident">prevFlush</a>
	<label for="r50" class="ident">next</label> := <a href="../../../../runtime/chan.go.html#line-71">make</a>(<span class="keyword">chan</span> <a href="../../../../../pkg/builtin.html#name-bool" class="ident">bool</a>)
	<label for="r46" class="ident">b</label>.<a href="#line-107" class="ident">prevFlush</a> = <label for="r50" class="ident">next</label>

	<label for="r46" class="ident">b</label>.<a href="#line-87" class="ident">mu</a>.<a href="../../../../sync/mutex.go.html#line-179" class="ident">Unlock</a>()
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Wait until the previous flush is finished.</span></div>
<div class="code"><pre><code>	<span class="keyword">if</span> <label for="r49" class="ident">prev</label> != <a href="../../../../../pkg/builtin.html#name-nil" class="ident">nil</a> {
		&lt;-<label for="r49" class="ident">prev</label>
	}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Wait until this flush is finished.</span></div>
<div class="code"><pre><code>	<label for="r48" class="ident">wg</label>.<a href="../../../../sync/waitgroup.go.html#line-103" class="ident">Wait</a>()
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Allow the next flush to finish.</span></div>
<div class="code"><pre><code>	<a href="../../../../../pkg/builtin.html#name-close" class="ident">close</a>(<label for="r50" class="ident">next</label>)
</code></pre></div></div>

</div><pre id="footer">
<table><tr><td><img src="../../../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/article/tool-golds.html"><b>Golds</b></a> <i>v0.3.2-preview</i>. (GOOS=darwin GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>