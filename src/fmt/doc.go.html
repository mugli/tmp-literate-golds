<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: doc.go in package fmt</title>
<link href="../../css/lightLiterate-v0.3.2-preview.css" rel="stylesheet">
<script src="../../jvs/golds-v0.3.2-preview.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	doc.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/fmt.html">fmt</a>
</code></pre>
<div id="container"><div class="section">
<div class="doc">
<span class="comment"> Copyright 2009 The Go Authors. All rights reserved.</span><span class="comment"> Use of this source code is governed by a BSD-style</span><span class="comment"> license that can be found in the LICENSE file.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"></span><span class="comment">	Package fmt implements formatted I/O with functions analogous</span><span class="comment">	to C's printf and scanf.  The format 'verbs' are derived from C's but</span><span class="comment">	are simpler.</span></div>
<div class="code"><pre><code>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	Printing</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	The verbs:</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	General:</span><span class="comment">		%v	the value in a default format</span><span class="comment">			when printing structs, the plus flag (%+v) adds field names</span><span class="comment">		%#v	a Go-syntax representation of the value</span><span class="comment">		%T	a Go-syntax representation of the type of the value</span><span class="comment">		%%	a literal percent sign; consumes no value</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	Boolean:</span><span class="comment">		%t	the word true or false</span><span class="comment">	Integer:</span><span class="comment">		%b	base 2</span><span class="comment">		%c	the character represented by the corresponding Unicode code point</span><span class="comment">		%d	base 10</span><span class="comment">		%o	base 8</span><span class="comment">		%O	base 8 with 0o prefix</span><span class="comment">		%q	a single-quoted character literal safely escaped with Go syntax.</span><span class="comment">		%x	base 16, with lower-case letters for a-f</span><span class="comment">		%X	base 16, with upper-case letters for A-F</span><span class="comment">		%U	Unicode format: U+1234; same as "U+%04X"</span><span class="comment">	Floating-point and complex constituents:</span><span class="comment">		%b	decimalless scientific notation with exponent a power of two,</span><span class="comment">			in the manner of strconv.FormatFloat with the 'b' format,</span><span class="comment">			e.g. -123456p-78</span><span class="comment">		%e	scientific notation, e.g. -1.234456e+78</span><span class="comment">		%E	scientific notation, e.g. -1.234456E+78</span><span class="comment">		%f	decimal point but no exponent, e.g. 123.456</span><span class="comment">		%F	synonym for %f</span><span class="comment">		%g	%e for large exponents, %f otherwise. Precision is discussed below.</span><span class="comment">		%G	%E for large exponents, %F otherwise</span><span class="comment">		%x	hexadecimal notation (with decimal power of two exponent), e.g. -0x1.23abcp+20</span><span class="comment">		%X	upper-case hexadecimal notation, e.g. -0X1.23ABCP+20</span><span class="comment">	String and slice of bytes (treated equivalently with these verbs):</span><span class="comment">		%s	the uninterpreted bytes of the string or slice</span><span class="comment">		%q	a double-quoted string safely escaped with Go syntax</span><span class="comment">		%x	base 16, lower-case, two characters per byte</span><span class="comment">		%X	base 16, upper-case, two characters per byte</span><span class="comment">	Slice:</span><span class="comment">		%p	address of 0th element in base 16 notation, with leading 0x</span><span class="comment">	Pointer:</span><span class="comment">		%p	base 16 notation, with leading 0x</span><span class="comment">		The %b, %d, %o, %x and %X verbs also work with pointers,</span><span class="comment">		formatting the value exactly as if it were an integer.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	The default format for %v is:</span><span class="comment">		bool:                    %t</span><span class="comment">		int, int8 etc.:          %d</span><span class="comment">		uint, uint8 etc.:        %d, %#x if printed with %#v</span><span class="comment">		float32, complex64, etc: %g</span><span class="comment">		string:                  %s</span><span class="comment">		chan:                    %p</span><span class="comment">		pointer:                 %p</span><span class="comment">	For compound objects, the elements are printed using these rules, recursively,</span><span class="comment">	laid out like this:</span><span class="comment">		struct:             {field0 field1 ...}</span><span class="comment">		array, slice:       [elem0 elem1 ...]</span><span class="comment">		maps:               map[key1:value1 key2:value2 ...]</span><span class="comment">		pointer to above:   &amp;{}, &amp;[], &amp;map[]</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	Width is specified by an optional decimal number immediately preceding the verb.</span><span class="comment">	If absent, the width is whatever is necessary to represent the value.</span><span class="comment">	Precision is specified after the (optional) width by a period followed by a</span><span class="comment">	decimal number. If no period is present, a default precision is used.</span><span class="comment">	A period with no following number specifies a precision of zero.</span><span class="comment">	Examples:</span><span class="comment">		%f     default width, default precision</span><span class="comment">		%9f    width 9, default precision</span><span class="comment">		%.2f   default width, precision 2</span><span class="comment">		%9.2f  width 9, precision 2</span><span class="comment">		%9.f   width 9, precision 0</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	Width and precision are measured in units of Unicode code points,</span><span class="comment">	that is, runes. (This differs from C's printf where the</span><span class="comment">	units are always measured in bytes.) Either or both of the flags</span><span class="comment">	may be replaced with the character '*', causing their values to be</span><span class="comment">	obtained from the next operand (preceding the one to format),</span><span class="comment">	which must be of type int.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	For most values, width is the minimum number of runes to output,</span><span class="comment">	padding the formatted form with spaces if necessary.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	For strings, byte slices and byte arrays, however, precision</span><span class="comment">	limits the length of the input to be formatted (not the size of</span><span class="comment">	the output), truncating if necessary. Normally it is measured in</span><span class="comment">	runes, but for these types when formatted with the %x or %X format</span><span class="comment">	it is measured in bytes.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	For floating-point values, width sets the minimum width of the field and</span><span class="comment">	precision sets the number of places after the decimal, if appropriate,</span><span class="comment">	except that for %g/%G precision sets the maximum number of significant</span><span class="comment">	digits (trailing zeros are removed). For example, given 12.345 the format</span><span class="comment">	%6.3f prints 12.345 while %.3g prints 12.3. The default precision for %e, %f</span><span class="comment">	and %#g is 6; for %g it is the smallest number of digits necessary to identify</span><span class="comment">	the value uniquely.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	For complex numbers, the width and precision apply to the two</span><span class="comment">	components independently and the result is parenthesized, so %f applied</span><span class="comment">	to 1.2+3.4i produces (1.200000+3.400000i).</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	Other flags:</span><span class="comment">		+	always print a sign for numeric values;</span><span class="comment">			guarantee ASCII-only output for %q (%+q)</span><span class="comment">		-	pad with spaces on the right rather than the left (left-justify the field)</span><span class="comment">		#	alternate format: add leading 0b for binary (%#b), 0 for octal (%#o),</span><span class="comment">			0x or 0X for hex (%#x or %#X); suppress 0x for %p (%#p);</span><span class="comment">			for %q, print a raw (backquoted) string if strconv.CanBackquote</span><span class="comment">			returns true;</span><span class="comment">			always print a decimal point for %e, %E, %f, %F, %g and %G;</span><span class="comment">			do not remove trailing zeros for %g and %G;</span><span class="comment">			write e.g. U+0078 'x' if the character is printable for %U (%#U).</span><span class="comment">		' '	(space) leave a space for elided sign in numbers (% d);</span><span class="comment">			put spaces between bytes printing strings or slices in hex (% x, % X)</span><span class="comment">		0	pad with leading zeros rather than spaces;</span><span class="comment">			for numbers, this moves the padding after the sign</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	Flags are ignored by verbs that do not expect them.</span><span class="comment">	For example there is no alternate decimal format, so %#d and %d</span><span class="comment">	behave identically.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	For each Printf-like function, there is also a Print function</span><span class="comment">	that takes no format and is equivalent to saying %v for every</span><span class="comment">	operand.  Another variant Println inserts blanks between</span><span class="comment">	operands and appends a newline.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	Regardless of the verb, if an operand is an interface value,</span><span class="comment">	the internal concrete value is used, not the interface itself.</span><span class="comment">	Thus:</span><span class="comment">		var i interface{} = 23</span><span class="comment">		fmt.Printf("%v\n", i)</span><span class="comment">	will print 23.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	Except when printed using the verbs %T and %p, special</span><span class="comment">	formatting considerations apply for operands that implement</span><span class="comment">	certain interfaces. In order of application:</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	1. If the operand is a reflect.Value, the operand is replaced by the</span><span class="comment">	concrete value that it holds, and printing continues with the next rule.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	2. If an operand implements the Formatter interface, it will</span><span class="comment">	be invoked. In this case the interpretation of verbs and flags is</span><span class="comment">	controlled by that implementation.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	3. If the %v verb is used with the # flag (%#v) and the operand</span><span class="comment">	implements the GoStringer interface, that will be invoked.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	If the format (which is implicitly %v for Println etc.) is valid</span><span class="comment">	for a string (%s %q %v %x %X), the following two rules apply:</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	4. If an operand implements the error interface, the Error method</span><span class="comment">	will be invoked to convert the object to a string, which will then</span><span class="comment">	be formatted as required by the verb (if any).</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	5. If an operand implements method String() string, that method</span><span class="comment">	will be invoked to convert the object to a string, which will then</span><span class="comment">	be formatted as required by the verb (if any).</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	For compound operands such as slices and structs, the format</span><span class="comment">	applies to the elements of each operand, recursively, not to the</span><span class="comment">	operand as a whole. Thus %q will quote each element of a slice</span><span class="comment">	of strings, and %6.2f will control formatting for each element</span><span class="comment">	of a floating-point array.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	However, when printing a byte slice with a string-like verb</span><span class="comment">	(%s %q %x %X), it is treated identically to a string, as a single item.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	To avoid recursion in cases such as</span><span class="comment">		type X string</span><span class="comment">		func (x X) String() string { return Sprintf("&lt;%s&gt;", x) }</span><span class="comment">	convert the value before recurring:</span><span class="comment">		func (x X) String() string { return Sprintf("&lt;%s&gt;", string(x)) }</span><span class="comment">	Infinite recursion can also be triggered by self-referential data</span><span class="comment">	structures, such as a slice that contains itself as an element, if</span><span class="comment">	that type has a String method. Such pathologies are rare, however,</span><span class="comment">	and the package does not protect against them.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	When printing a struct, fmt cannot and therefore does not invoke</span><span class="comment">	formatting methods such as Error or String on unexported fields.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	Explicit argument indexes:</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	In Printf, Sprintf, and Fprintf, the default behavior is for each</span><span class="comment">	formatting verb to format successive arguments passed in the call.</span><span class="comment">	However, the notation [n] immediately before the verb indicates that the</span><span class="comment">	nth one-indexed argument is to be formatted instead. The same notation</span><span class="comment">	before a '*' for a width or precision selects the argument index holding</span><span class="comment">	the value. After processing a bracketed expression [n], subsequent verbs</span><span class="comment">	will use arguments n+1, n+2, etc. unless otherwise directed.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	For example,</span><span class="comment">		fmt.Sprintf("%[2]d %[1]d\n", 11, 22)</span><span class="comment">	will yield "22 11", while</span><span class="comment">		fmt.Sprintf("%[3]*.[2]*[1]f", 12.0, 2, 6)</span><span class="comment">	equivalent to</span><span class="comment">		fmt.Sprintf("%6.2f", 12.0)</span><span class="comment">	will yield " 12.00". Because an explicit index affects subsequent verbs,</span><span class="comment">	this notation can be used to print the same values multiple times</span><span class="comment">	by resetting the index for the first argument to be repeated:</span><span class="comment">		fmt.Sprintf("%d %d %#[1]x %#x", 16, 17)</span><span class="comment">	will yield "16 17 0x10 0x11".</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	Format errors:</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	If an invalid argument is given for a verb, such as providing</span><span class="comment">	a string to %d, the generated string will contain a</span><span class="comment">	description of the problem, as in these examples:</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">		Wrong type or unknown verb: %!verb(type=value)</span><span class="comment">			Printf("%d", "hi"):        %!d(string=hi)</span><span class="comment">		Too many arguments: %!(EXTRA type=value)</span><span class="comment">			Printf("hi", "guys"):      hi%!(EXTRA string=guys)</span><span class="comment">		Too few arguments: %!verb(MISSING)</span><span class="comment">			Printf("hi%d"):            hi%!d(MISSING)</span><span class="comment">		Non-int for width or precision: %!(BADWIDTH) or %!(BADPREC)</span><span class="comment">			Printf("%*s", 4.5, "hi"):  %!(BADWIDTH)hi</span><span class="comment">			Printf("%.*s", 4.5, "hi"): %!(BADPREC)hi</span><span class="comment">		Invalid or invalid use of argument index: %!(BADINDEX)</span><span class="comment">			Printf("%*[2]d", 7):       %!d(BADINDEX)</span><span class="comment">			Printf("%.[2]d", 7):       %!d(BADINDEX)</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	All errors begin with the string "%!" followed sometimes</span><span class="comment">	by a single character (the verb) and end with a parenthesized</span><span class="comment">	description.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	If an Error or String method triggers a panic when called by a</span><span class="comment">	print routine, the fmt package reformats the error message</span><span class="comment">	from the panic, decorating it with an indication that it came</span><span class="comment">	through the fmt package.  For example, if a String method</span><span class="comment">	calls panic("bad"), the resulting formatted message will look</span><span class="comment">	like</span><span class="comment">		%!s(PANIC=bad)</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	The %!s just shows the print verb in use when the failure</span><span class="comment">	occurred. If the panic is caused by a nil receiver to an Error</span><span class="comment">	or String method, however, the output is the undecorated</span><span class="comment">	string, "&lt;nil&gt;".</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	Scanning</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	An analogous set of functions scans formatted text to yield</span><span class="comment">	values.  Scan, Scanf and Scanln read from os.Stdin; Fscan,</span><span class="comment">	Fscanf and Fscanln read from a specified io.Reader; Sscan,</span><span class="comment">	Sscanf and Sscanln read from an argument string.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	Scan, Fscan, Sscan treat newlines in the input as spaces.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	Scanln, Fscanln and Sscanln stop scanning at a newline and</span><span class="comment">	require that the items be followed by a newline or EOF.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	Scanf, Fscanf, and Sscanf parse the arguments according to a</span><span class="comment">	format string, analogous to that of Printf. In the text that</span><span class="comment">	follows, 'space' means any Unicode whitespace character</span><span class="comment">	except newline.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	In the format string, a verb introduced by the % character</span><span class="comment">	consumes and parses input; these verbs are described in more</span><span class="comment">	detail below. A character other than %, space, or newline in</span><span class="comment">	the format consumes exactly that input character, which must</span><span class="comment">	be present. A newline with zero or more spaces before it in</span><span class="comment">	the format string consumes zero or more spaces in the input</span><span class="comment">	followed by a single newline or the end of the input. A space</span><span class="comment">	following a newline in the format string consumes zero or more</span><span class="comment">	spaces in the input. Otherwise, any run of one or more spaces</span><span class="comment">	in the format string consumes as many spaces as possible in</span><span class="comment">	the input. Unless the run of spaces in the format string</span><span class="comment">	appears adjacent to a newline, the run must consume at least</span><span class="comment">	one space from the input or find the end of the input.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	The handling of spaces and newlines differs from that of C's</span><span class="comment">	scanf family: in C, newlines are treated as any other space,</span><span class="comment">	and it is never an error when a run of spaces in the format</span><span class="comment">	string finds no spaces to consume in the input.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	The verbs behave analogously to those of Printf.</span><span class="comment">	For example, %x will scan an integer as a hexadecimal number,</span><span class="comment">	and %v will scan the default representation format for the value.</span><span class="comment">	The Printf verbs %p and %T and the flags # and + are not implemented.</span><span class="comment">	For floating-point and complex values, all valid formatting verbs</span><span class="comment">	(%b %e %E %f %F %g %G %x %X and %v) are equivalent and accept</span><span class="comment">	both decimal and hexadecimal notation (for example: "2.3e+7", "0x4.5p-8")</span><span class="comment">	and digit-separating underscores (for example: "3.14159_26535_89793").</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	Input processed by verbs is implicitly space-delimited: the</span><span class="comment">	implementation of every verb except %c starts by discarding</span><span class="comment">	leading spaces from the remaining input, and the %s verb</span><span class="comment">	(and %v reading into a string) stops consuming input at the first</span><span class="comment">	space or newline character.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	The familiar base-setting prefixes 0b (binary), 0o and 0 (octal),</span><span class="comment">	and 0x (hexadecimal) are accepted when scanning integers</span><span class="comment">	without a format or with the %v verb, as are digit-separating</span><span class="comment">	underscores.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	Width is interpreted in the input text but there is no</span><span class="comment">	syntax for scanning with a precision (no %5.2f, just %5f).</span><span class="comment">	If width is provided, it applies after leading spaces are</span><span class="comment">	trimmed and specifies the maximum number of runes to read</span><span class="comment">	to satisfy the verb. For example,</span><span class="comment">	   Sscanf(" 1234567 ", "%5s%d", &amp;s, &amp;i)</span><span class="comment">	will set s to "12345" and i to 67 while</span><span class="comment">	   Sscanf(" 12 34 567 ", "%5s%d", &amp;s, &amp;i)</span><span class="comment">	will set s to "12" and i to 34.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	In all the scanning functions, a carriage return followed</span><span class="comment">	immediately by a newline is treated as a plain newline</span><span class="comment">	(\r\n means the same as \n).</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	In all the scanning functions, if an operand implements method</span><span class="comment">	Scan (that is, it implements the Scanner interface) that</span><span class="comment">	method will be used to scan the text for that operand.  Also,</span><span class="comment">	if the number of arguments scanned is less than the number of</span><span class="comment">	arguments provided, an error is returned.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	All arguments to be scanned must be either pointers to basic</span><span class="comment">	types or implementations of the Scanner interface.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	Like Scanf and Fscanf, Sscanf need not consume its entire input.</span><span class="comment">	There is no way to recover how much of the input string Sscanf used.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	Note: Fscan etc. can read one character (rune) past the input</span><span class="comment">	they return, which means that a loop calling a scan routine</span><span class="comment">	may skip some of the input.  This is usually a problem only</span><span class="comment">	when there is no space between input values.  If the reader</span><span class="comment">	provided to Fscan implements ReadRune, that method will be used</span><span class="comment">	to read characters.  If the reader also implements UnreadRune,</span><span class="comment">	that method will be used to save the character and successive</span><span class="comment">	calls will not lose data.  To attach ReadRune and UnreadRune</span><span class="comment">	methods to a reader without that capability, use</span><span class="comment">	bufio.NewReader.</span><span class="comment"></span></div>
<div class="code"><pre><code></code></pre></div></div>

</div><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/article/tool-golds.html"><b>Golds</b></a> <i>v0.3.2-preview</i>. (GOOS=darwin GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>