<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: doc.go in package github.com/lib/pq</title>
<link href="../../../../css/lightLiterate-v0.3.2-preview.css" rel="stylesheet">
<script src="../../../../jvs/golds-v0.3.2-preview.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	doc.go

<span class="title">Belonging Package</span>
	<a href="../../../../pkg/github.com/lib/pq.html">github.com/lib/pq</a>
</code></pre>
<div id="container"><div class="section">
<div class="doc">
<span class="comment"></span><span class="comment">Package pq is a pure Go Postgres driver for the database/sql package.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">In most cases clients will use the database/sql package instead of</span><span class="comment">using this package directly. For example:</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	import (</span><span class="comment">		"database/sql"</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">		_ "github.com/lib/pq"</span><span class="comment">	)</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	func main() {</span><span class="comment">		connStr := "user=pqgotest dbname=pqgotest sslmode=verify-full"</span><span class="comment">		db, err := sql.Open("postgres", connStr)</span><span class="comment">		if err != nil {</span><span class="comment">			log.Fatal(err)</span><span class="comment">		}</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">		age := 21</span><span class="comment">		rows, err := db.Query("SELECT name FROM users WHERE age = $1", age)</span><span class="comment">		â€¦</span><span class="comment">	}</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">You can also connect to a database using a URL. For example:</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	connStr := "postgres:pqgotest:password@localhost/pqgotest?sslmode=verify-full"</span><span class="comment">	db, err := sql.Open("postgres", connStr)</span></div>
<div class="code"><pre><code>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">Connection String Parameters</span></div>
<div class="code"><pre><code>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">Similarly to libpq, when establishing a connection using pq you are expected to</span><span class="comment">supply a connection string containing zero or more parameters.</span><span class="comment">A subset of the connection parameters supported by libpq are also supported by pq.</span><span class="comment">Additionally, pq also lets you specify run-time parameters (such as search_path or work_mem)</span><span class="comment">directly in the connection string.  This is different from libpq, which does not allow</span><span class="comment">run-time parameters in the connection string, instead requiring you to supply</span><span class="comment">them in the options parameter.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">For compatibility with libpq, the following special connection parameters are</span><span class="comment">supported:</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	* dbname - The name of the database to connect to</span><span class="comment">	* user - The user to sign in as</span><span class="comment">	* password - The user's password</span><span class="comment">	* host - The host to connect to. Values that start with / are for unix</span><span class="comment">	  domain sockets. (default is localhost)</span><span class="comment">	* port - The port to bind to. (default is 5432)</span><span class="comment">	* sslmode - Whether or not to use SSL (default is require, this is not</span><span class="comment">	  the default for libpq)</span><span class="comment">	* fallback_application_name - An application_name to fall back to if one isn't provided.</span><span class="comment">	* connect_timeout - Maximum wait for connection, in seconds. Zero or</span><span class="comment">	  not specified means wait indefinitely.</span><span class="comment">	* sslcert - Cert file location. The file must contain PEM encoded data.</span><span class="comment">	* sslkey - Key file location. The file must contain PEM encoded data.</span><span class="comment">	* sslrootcert - The location of the root certificate file. The file</span><span class="comment">	  must contain PEM encoded data.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">Valid values for sslmode are:</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	* disable - No SSL</span><span class="comment">	* require - Always SSL (skip verification)</span><span class="comment">	* verify-ca - Always SSL (verify that the certificate presented by the</span><span class="comment">	  server was signed by a trusted CA)</span><span class="comment">	* verify-full - Always SSL (verify that the certification presented by</span><span class="comment">	  the server was signed by a trusted CA and the server host name</span><span class="comment">	  matches the one in the certificate)</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">See http:www.postgresql.org/docs/current/static/libpq-connect.html#LIBPQ-CONNSTRING</span><span class="comment">for more information about connection string parameters.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">Use single quotes for values that contain whitespace:</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">    "user=pqgotest password='with spaces'"</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">A backslash will escape the next character in values:</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">    "user=space\ man password='it\'s valid'"</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">Note that the connection parameter client_encoding (which sets the</span><span class="comment">text encoding for the connection) may be set but must be "UTF8",</span><span class="comment">matching with the same rules as Postgres. It is an error to provide</span><span class="comment">any other value.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">In addition to the parameters listed above, any run-time parameter that can be</span><span class="comment">set at backend start time can be set in the connection string.  For more</span><span class="comment">information, see</span><span class="comment">http:www.postgresql.org/docs/current/static/runtime-config.html.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">Most environment variables as specified at http:www.postgresql.org/docs/current/static/libpq-envars.html</span><span class="comment">supported by libpq are also supported by pq.  If any of the environment</span><span class="comment">variables not supported by pq are set, pq will panic during connection</span><span class="comment">establishment.  Environment variables have a lower precedence than explicitly</span><span class="comment">provided connection parameters.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">The pgpass mechanism as described in http:www.postgresql.org/docs/current/static/libpq-pgpass.html</span><span class="comment">is supported, but on Windows PGPASSFILE must be specified explicitly.</span></div>
<div class="code"><pre><code>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">Queries</span></div>
<div class="code"><pre><code>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">database/sql does not dictate any specific format for parameter</span><span class="comment">markers in query strings, and pq uses the Postgres-native ordinal markers,</span><span class="comment">as shown above. The same marker can be reused for the same parameter:</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	rows, err := db.Query(`SELECT name FROM users WHERE favorite_fruit = $1</span><span class="comment">		OR age BETWEEN $2 AND $2 + 3`, "orange", 64)</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">pq does not support the LastInsertId() method of the Result type in database/sql.</span><span class="comment">To return the identifier of an INSERT (or UPDATE or DELETE), use the Postgres</span><span class="comment">RETURNING clause with a standard Query or QueryRow call:</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	var userid int</span><span class="comment">	err := db.QueryRow(`INSERT INTO users(name, favorite_fruit, age)</span><span class="comment">		VALUES('beatrice', 'starfruit', 93) RETURNING id`).Scan(&amp;userid)</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">For more details on RETURNING, see the Postgres documentation:</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	http:www.postgresql.org/docs/current/static/sql-insert.html</span><span class="comment">	http:www.postgresql.org/docs/current/static/sql-update.html</span><span class="comment">	http:www.postgresql.org/docs/current/static/sql-delete.html</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">For additional instructions on querying see the documentation for the database/sql package.</span></div>
<div class="code"><pre><code>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">Data Types</span></div>
<div class="code"><pre><code>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">Parameters pass through driver.DefaultParameterConverter before they are handled</span><span class="comment">by this package. When the binary_parameters connection option is enabled,</span><span class="comment">[]byte values are sent directly to the backend as data in binary format.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">This package returns the following types for values from the PostgreSQL backend:</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	- integer types smallint, integer, and bigint are returned as int64</span><span class="comment">	- floating-point types real and double precision are returned as float64</span><span class="comment">	- character types char, varchar, and text are returned as string</span><span class="comment">	- temporal types date, time, timetz, timestamp, and timestamptz are</span><span class="comment">	  returned as time.Time</span><span class="comment">	- the boolean type is returned as bool</span><span class="comment">	- the bytea type is returned as []byte</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">All other types are returned directly from the backend as []byte values in text format.</span></div>
<div class="code"><pre><code>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">Errors</span></div>
<div class="code"><pre><code>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">pq may return errors of type *pq.Error which can be interrogated for error details:</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">        if err, ok := err.(*pq.Error); ok {</span><span class="comment">            fmt.Println("pq error:", err.Code.Name())</span><span class="comment">        }</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">See the pq.Error type for details.</span></div>
<div class="code"><pre><code>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">Bulk imports</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">You can perform bulk imports by preparing a statement returned by pq.CopyIn (or</span><span class="comment">pq.CopyInSchema) in an explicit transaction (sql.Tx). The returned statement</span><span class="comment">handle can then be repeatedly "executed" to copy data into the target table.</span><span class="comment">After all data has been processed you should call Exec() once with no arguments</span><span class="comment">to flush all buffered data. Any call to Exec() might return an error which</span><span class="comment">should be handled appropriately, but because of the internal buffering an error</span><span class="comment">returned by Exec() might not be related to the data passed in the call that</span><span class="comment">failed.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">CopyIn uses COPY FROM internally. It is not possible to COPY outside of an</span><span class="comment">explicit transaction in pq.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">Usage example:</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	txn, err := db.Begin()</span><span class="comment">	if err != nil {</span><span class="comment">		log.Fatal(err)</span><span class="comment">	}</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	stmt, err := txn.Prepare(pq.CopyIn("users", "name", "age"))</span><span class="comment">	if err != nil {</span><span class="comment">		log.Fatal(err)</span><span class="comment">	}</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	for _, user := range users {</span><span class="comment">		_, err = stmt.Exec(user.Name, int64(user.Age))</span><span class="comment">		if err != nil {</span><span class="comment">			log.Fatal(err)</span><span class="comment">		}</span><span class="comment">	}</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	_, err = stmt.Exec()</span><span class="comment">	if err != nil {</span><span class="comment">		log.Fatal(err)</span><span class="comment">	}</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	err = stmt.Close()</span><span class="comment">	if err != nil {</span><span class="comment">		log.Fatal(err)</span><span class="comment">	}</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">	err = txn.Commit()</span><span class="comment">	if err != nil {</span><span class="comment">		log.Fatal(err)</span><span class="comment">	}</span></div>
<div class="code"><pre><code>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">Notifications</span></div>
<div class="code"><pre><code>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">PostgreSQL supports a simple publish/subscribe model over database</span><span class="comment">connections.  See http:www.postgresql.org/docs/current/static/sql-notify.html</span><span class="comment">for more information about the general mechanism.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">To start listening for notifications, you first have to open a new connection</span><span class="comment">to the database by calling NewListener.  This connection can not be used for</span><span class="comment">anything other than LISTEN / NOTIFY.  Calling Listen will open a "notification</span><span class="comment">channel"; once a notification channel is open, a notification generated on that</span><span class="comment">channel will effect a send on the Listener.Notify channel.  A notification</span><span class="comment">channel will remain open until Unlisten is called, though connection loss might</span><span class="comment">result in some notifications being lost.  To solve this problem, Listener sends</span><span class="comment">a nil pointer over the Notify channel any time the connection is re-established</span><span class="comment">following a connection loss.  The application can get information about the</span><span class="comment">state of the underlying connection by setting an event callback in the call to</span><span class="comment">NewListener.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">A single Listener can safely be used from concurrent goroutines, which means</span><span class="comment">that there is often no need to create more than one Listener in your</span><span class="comment">application.  However, a Listener is always connected to a single database, so</span><span class="comment">you will need to create a new Listener instance for every database you want to</span><span class="comment">receive notifications in.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">The channel name in both Listen and Unlisten is case sensitive, and can contain</span><span class="comment">any characters legal in an identifier (see</span><span class="comment">http:www.postgresql.org/docs/current/static/sql-syntax-lexical.html#SQL-SYNTAX-IDENTIFIERS</span><span class="comment">for more information).  Note that the channel name will be truncated to 63</span><span class="comment">bytes by the PostgreSQL server.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">You can find a complete, working example of Listener usage at</span><span class="comment">https:godoc.org/github.com/lib/pq/example/listen.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"></span></div>
<div class="code"><pre><code></code></pre></div></div>

</div><pre id="footer">
<table><tr><td><img src="../../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/article/tool-golds.html"><b>Golds</b></a> <i>v0.3.2-preview</i>. (GOOS=darwin GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>