<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: doc.go in package github.com/go-git/gcfg</title>
<link href="../../../../css/lightLiterate-v0.3.2-preview.css" rel="stylesheet">
<script src="../../../../jvs/golds-v0.3.2-preview.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	doc.go

<span class="title">Belonging Package</span>
	<a href="../../../../pkg/github.com/go-git/gcfg.html">github.com/go-git/gcfg</a>
</code></pre>
<div id="container"><div class="section">
<div class="doc">
<span class="comment"> Package gcfg reads "INI-style" text-based configuration files with</span><span class="comment"> "name=value" pairs grouped into sections (gcfg files).</span><span class="comment"></span><span class="comment"> This package is still a work in progress; see the sections below for planned</span><span class="comment"> changes.</span><span class="comment"></span><span class="comment"> Syntax</span><span class="comment"></span><span class="comment"> The syntax is based on that used by git config:</span><span class="comment"> http://git-scm.com/docs/git-config#_syntax .</span><span class="comment"> There are some (planned) differences compared to the git config format:</span><span class="comment">  - improve data portability:</span><span class="comment">    - must be encoded in UTF-8 (for now) and must not contain the 0 byte</span><span class="comment">    - include and "path" type is not supported</span><span class="comment">      (path type may be implementable as a user-defined type)</span><span class="comment">  - internationalization</span><span class="comment">    - section and variable names can contain unicode letters, unicode digits</span><span class="comment">      (as defined in http://golang.org/ref/spec#Characters ) and hyphens</span><span class="comment">      (U+002D), starting with a unicode letter</span><span class="comment">  - disallow potentially ambiguous or misleading definitions:</span><span class="comment">    - `[sec.sub]` format is not allowed (deprecated in gitconfig)</span><span class="comment">    - `[sec ""]` is not allowed</span><span class="comment">      - use `[sec]` for section name "sec" and empty subsection name</span><span class="comment">    - (planned) within a single file, definitions must be contiguous for each:</span><span class="comment">      - section: '[secA]' -&gt; '[secB]' -&gt; '[secA]' is an error</span><span class="comment">      - subsection: '[sec "A"]' -&gt; '[sec "B"]' -&gt; '[sec "A"]' is an error</span><span class="comment">      - multivalued variable: 'multi=a' -&gt; 'other=x' -&gt; 'multi=b' is an error</span><span class="comment"></span><span class="comment"> Data structure</span><span class="comment"></span><span class="comment"> The functions in this package read values into a user-defined struct.</span><span class="comment"> Each section corresponds to a struct field in the config struct, and each</span><span class="comment"> variable in a section corresponds to a data field in the section struct.</span><span class="comment"> The mapping of each section or variable name to fields is done either based</span><span class="comment"> on the "gcfg" struct tag or by matching the name of the section or variable,</span><span class="comment"> ignoring case. In the latter case, hyphens '-' in section and variable names</span><span class="comment"> correspond to underscores '_' in field names.</span><span class="comment"> Fields must be exported; to use a section or variable name starting with a</span><span class="comment"> letter that is neither upper- or lower-case, prefix the field name with 'X'.</span><span class="comment"> (See https://code.google.com/p/go/issues/detail?id=5763#c4 .)</span><span class="comment"></span><span class="comment"> For sections with subsections, the corresponding field in config must be a</span><span class="comment"> map, rather than a struct, with string keys and pointer-to-struct values.</span><span class="comment"> Values for subsection variables are stored in the map with the subsection</span><span class="comment"> name used as the map key.</span><span class="comment"> (Note that unlike section and variable names, subsection names are case</span><span class="comment"> sensitive.)</span><span class="comment"> When using a map, and there is a section with the same section name but</span><span class="comment"> without a subsection name, its values are stored with the empty string used</span><span class="comment"> as the key.</span><span class="comment"> It is possible to provide default values for subsections in the section</span><span class="comment"> "default-&lt;sectionname&gt;" (or by setting values in the corresponding struct</span><span class="comment"> field "Default_&lt;sectionname&gt;").</span><span class="comment"></span><span class="comment"> The functions in this package panic if config is not a pointer to a struct,</span><span class="comment"> or when a field is not of a suitable type (either a struct or a map with</span><span class="comment"> string keys and pointer-to-struct values).</span><span class="comment"></span><span class="comment"> Parsing of values</span><span class="comment"></span><span class="comment"> The section structs in the config struct may contain single-valued or</span><span class="comment"> multi-valued variables. Variables of unnamed slice type (that is, a type</span><span class="comment"> starting with `[]`) are treated as multi-value; all others (including named</span><span class="comment"> slice types) are treated as single-valued variables.</span><span class="comment"></span><span class="comment"> Single-valued variables are handled based on the type as follows.</span><span class="comment"> Unnamed pointer types (that is, types starting with `*`) are dereferenced,</span><span class="comment"> and if necessary, a new instance is allocated.</span><span class="comment"></span><span class="comment"> For types implementing the encoding.TextUnmarshaler interface, the</span><span class="comment"> UnmarshalText method is used to set the value. Implementing this method is</span><span class="comment"> the recommended way for parsing user-defined types.</span><span class="comment"></span><span class="comment"> For fields of string kind, the value string is assigned to the field, after</span><span class="comment"> unquoting and unescaping as needed.</span><span class="comment"> For fields of bool kind, the field is set to true if the value is "true",</span><span class="comment"> "yes", "on" or "1", and set to false if the value is "false", "no", "off" or</span><span class="comment"> "0", ignoring case. In addition, single-valued bool fields can be specified</span><span class="comment"> with a "blank" value (variable name without equals sign and value); in such</span><span class="comment"> case the value is set to true.</span><span class="comment"></span><span class="comment"> Predefined integer types [u]int(|8|16|32|64) and big.Int are parsed as</span><span class="comment"> decimal or hexadecimal (if having '0x' prefix). (This is to prevent</span><span class="comment"> unintuitively handling zero-padded numbers as octal.) Other types having</span><span class="comment"> [u]int* as the underlying type, such as os.FileMode and uintptr allow</span><span class="comment"> decimal, hexadecimal, or octal values.</span><span class="comment"> Parsing mode for integer types can be overridden using the struct tag option</span><span class="comment"> ",int=mode" where mode is a combination of the 'd', 'h', and 'o' characters</span><span class="comment"> (each standing for decimal, hexadecimal, and octal, respectively.)</span><span class="comment"></span><span class="comment"> All other types are parsed using fmt.Sscanf with the "%v" verb.</span><span class="comment"></span><span class="comment"> For multi-valued variables, each individual value is parsed as above and</span><span class="comment"> appended to the slice. If the first value is specified as a "blank" value</span><span class="comment"> (variable name without equals sign and value), a new slice is allocated;</span><span class="comment"> that is any values previously set in the slice will be ignored.</span><span class="comment"></span><span class="comment"> The types subpackage for provides helpers for parsing "enum-like" and integer</span><span class="comment"> types.</span><span class="comment"></span><span class="comment"> Error handling</span><span class="comment"></span><span class="comment"> There are 3 types of errors:</span><span class="comment"></span><span class="comment">  - programmer errors / panics:</span><span class="comment">    - invalid configuration structure</span><span class="comment">  - data errors:</span><span class="comment">    - fatal errors:</span><span class="comment">      - invalid configuration syntax</span><span class="comment">    - warnings:</span><span class="comment">      - data that doesn't belong to any part of the config structure</span><span class="comment"></span><span class="comment"> Programmer errors trigger panics. These are should be fixed by the programmer</span><span class="comment"> before releasing code that uses gcfg.</span><span class="comment"></span><span class="comment"> Data errors cause gcfg to return a non-nil error value. This includes the</span><span class="comment"> case when there are extra unknown key-value definitions in the configuration</span><span class="comment"> data (extra data).</span><span class="comment"> However, in some occasions it is desirable to be able to proceed in</span><span class="comment"> situations when the only data error is that of extra data.</span><span class="comment"> These errors are handled at a different (warning) priority and can be</span><span class="comment"> filtered out programmatically. To ignore extra data warnings, wrap the</span><span class="comment"> gcfg.Read*Into invocation into a call to gcfg.FatalOnly.</span><span class="comment"></span><span class="comment"> TODO</span><span class="comment"></span><span class="comment"> The following is a list of changes under consideration:</span><span class="comment">  - documentation</span><span class="comment">    - self-contained syntax documentation</span><span class="comment">    - more practical examples</span><span class="comment">    - move TODOs to issue tracker (eventually)</span><span class="comment">  - syntax</span><span class="comment">    - reconsider valid escape sequences</span><span class="comment">      (gitconfig doesn't support \r in value, \t in subsection name, etc.)</span><span class="comment">  - reading / parsing gcfg files</span><span class="comment">    - define internal representation structure</span><span class="comment">    - support multiple inputs (readers, strings, files)</span><span class="comment">    - support declaring encoding (?)</span><span class="comment">    - support varying fields sets for subsections (?)</span><span class="comment">  - writing gcfg files</span><span class="comment">  - error handling</span><span class="comment">    - make error context accessible programmatically?</span><span class="comment">    - limit input size?</span><span class="comment"></span></div>
<div class="code"><pre><code></code></pre></div></div>

</div><pre id="footer">
<table><tr><td><img src="../../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/article/tool-golds.html"><b>Golds</b></a> <i>v0.3.2-preview</i>. (GOOS=darwin GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>