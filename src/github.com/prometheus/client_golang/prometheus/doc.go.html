<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: doc.go in package github.com/prometheus/client_golang/prometheus</title>
<link href="../../../../../css/lightLiterate-v0.3.2-preview.css" rel="stylesheet">
<script src="../../../../../jvs/golds-v0.3.2-preview.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	doc.go

<span class="title">Belonging Package</span>
	<a href="../../../../../pkg/github.com/prometheus/client_golang/prometheus.html">github.com/prometheus/client_golang/prometheus</a>
</code></pre>
<div id="container"><div class="section">
<div class="doc">
<span class="comment"> Copyright 2014 The Prometheus Authors</span><span class="comment"> Licensed under the Apache License, Version 2.0 (the "License");</span><span class="comment"> you may not use this file except in compliance with the License.</span><span class="comment"> You may obtain a copy of the License at</span><span class="comment"></span><span class="comment"> http://www.apache.org/licenses/LICENSE-2.0</span><span class="comment"></span><span class="comment"> Unless required by applicable law or agreed to in writing, software</span><span class="comment"> distributed under the License is distributed on an "AS IS" BASIS,</span><span class="comment"> WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><span class="comment"> See the License for the specific language governing permissions and</span><span class="comment"> limitations under the License.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Package prometheus is the core instrumentation package. It provides metrics</span><span class="comment"> primitives to instrument code for monitoring. It also offers a registry for</span><span class="comment"> metrics. Sub-packages allow to expose the registered metrics via HTTP</span><span class="comment"> (package promhttp) or push them to a Pushgateway (package push). There is</span><span class="comment"> also a sub-package promauto, which provides metrics constructors with</span><span class="comment"> automatic registration.</span><span class="comment"></span><span class="comment"> All exported functions and methods are safe to be used concurrently unless</span><span class="comment"> specified otherwise.</span><span class="comment"></span><span class="comment"> A Basic Example</span><span class="comment"></span><span class="comment"> As a starting point, a very basic usage example:</span><span class="comment"></span><span class="comment">    package main</span><span class="comment"></span><span class="comment">    import (</span><span class="comment">    	"log"</span><span class="comment">    	"net/http"</span><span class="comment"></span><span class="comment">    	"github.com/prometheus/client_golang/prometheus"</span><span class="comment">    	"github.com/prometheus/client_golang/prometheus/promhttp"</span><span class="comment">    )</span><span class="comment"></span><span class="comment">    var (</span><span class="comment">    	cpuTemp = prometheus.NewGauge(prometheus.GaugeOpts{</span><span class="comment">    		Name: "cpu_temperature_celsius",</span><span class="comment">    		Help: "Current temperature of the CPU.",</span><span class="comment">    	})</span><span class="comment">    	hdFailures = prometheus.NewCounterVec(</span><span class="comment">    		prometheus.CounterOpts{</span><span class="comment">    			Name: "hd_errors_total",</span><span class="comment">    			Help: "Number of hard-disk errors.",</span><span class="comment">    		},</span><span class="comment">    		[]string{"device"},</span><span class="comment">    	)</span><span class="comment">    )</span><span class="comment"></span><span class="comment">    func init() {</span><span class="comment">    	// Metrics have to be registered to be exposed:</span><span class="comment">    	prometheus.MustRegister(cpuTemp)</span><span class="comment">    	prometheus.MustRegister(hdFailures)</span><span class="comment">    }</span><span class="comment"></span><span class="comment">    func main() {</span><span class="comment">    	cpuTemp.Set(65.3)</span><span class="comment">    	hdFailures.With(prometheus.Labels{"device":"/dev/sda"}).Inc()</span><span class="comment"></span><span class="comment">    	// The Handler function provides a default handler to expose metrics</span><span class="comment">    	// via an HTTP server. "/metrics" is the usual endpoint for that.</span><span class="comment">    	http.Handle("/metrics", promhttp.Handler())</span><span class="comment">    	log.Fatal(http.ListenAndServe(":8080", nil))</span><span class="comment">    }</span><span class="comment"></span><span class="comment"></span><span class="comment"> This is a complete program that exports two metrics, a Gauge and a Counter,</span><span class="comment"> the latter with a label attached to turn it into a (one-dimensional) vector.</span><span class="comment"></span><span class="comment"> Metrics</span><span class="comment"></span><span class="comment"> The number of exported identifiers in this package might appear a bit</span><span class="comment"> overwhelming. However, in addition to the basic plumbing shown in the example</span><span class="comment"> above, you only need to understand the different metric types and their</span><span class="comment"> vector versions for basic usage. Furthermore, if you are not concerned with</span><span class="comment"> fine-grained control of when and how to register metrics with the registry,</span><span class="comment"> have a look at the promauto package, which will effectively allow you to</span><span class="comment"> ignore registration altogether in simple cases.</span><span class="comment"></span><span class="comment"> Above, you have already touched the Counter and the Gauge. There are two more</span><span class="comment"> advanced metric types: the Summary and Histogram. A more thorough description</span><span class="comment"> of those four metric types can be found in the Prometheus docs:</span><span class="comment"> https://prometheus.io/docs/concepts/metric_types/</span><span class="comment"></span><span class="comment"> A fifth "type" of metric is Untyped. It behaves like a Gauge, but signals the</span><span class="comment"> Prometheus server not to assume anything about its type.</span><span class="comment"></span><span class="comment"> In addition to the fundamental metric types Gauge, Counter, Summary,</span><span class="comment"> Histogram, and Untyped, a very important part of the Prometheus data model is</span><span class="comment"> the partitioning of samples along dimensions called labels, which results in</span><span class="comment"> metric vectors. The fundamental types are GaugeVec, CounterVec, SummaryVec,</span><span class="comment"> HistogramVec, and UntypedVec.</span><span class="comment"></span><span class="comment"> While only the fundamental metric types implement the Metric interface, both</span><span class="comment"> the metrics and their vector versions implement the Collector interface. A</span><span class="comment"> Collector manages the collection of a number of Metrics, but for convenience,</span><span class="comment"> a Metric can also “collect itself”. Note that Gauge, Counter, Summary,</span><span class="comment"> Histogram, and Untyped are interfaces themselves while GaugeVec, CounterVec,</span><span class="comment"> SummaryVec, HistogramVec, and UntypedVec are not.</span><span class="comment"></span><span class="comment"> To create instances of Metrics and their vector versions, you need a suitable</span><span class="comment"> …Opts struct, i.e. GaugeOpts, CounterOpts, SummaryOpts, HistogramOpts, or</span><span class="comment"> UntypedOpts.</span><span class="comment"></span><span class="comment"> Custom Collectors and constant Metrics</span><span class="comment"></span><span class="comment"> While you could create your own implementations of Metric, most likely you</span><span class="comment"> will only ever implement the Collector interface on your own. At a first</span><span class="comment"> glance, a custom Collector seems handy to bundle Metrics for common</span><span class="comment"> registration (with the prime example of the different metric vectors above,</span><span class="comment"> which bundle all the metrics of the same name but with different labels).</span><span class="comment"></span><span class="comment"> There is a more involved use case, too: If you already have metrics</span><span class="comment"> available, created outside of the Prometheus context, you don't need the</span><span class="comment"> interface of the various Metric types. You essentially want to mirror the</span><span class="comment"> existing numbers into Prometheus Metrics during collection. An own</span><span class="comment"> implementation of the Collector interface is perfect for that. You can create</span><span class="comment"> Metric instances “on the fly” using NewConstMetric, NewConstHistogram, and</span><span class="comment"> NewConstSummary (and their respective Must… versions). That will happen in</span><span class="comment"> the Collect method. The Describe method has to return separate Desc</span><span class="comment"> instances, representative of the “throw-away” metrics to be created later.</span><span class="comment"> NewDesc comes in handy to create those Desc instances. Alternatively, you</span><span class="comment"> could return no Desc at all, which will mark the Collector “unchecked”.  No</span><span class="comment"> checks are performed at registration time, but metric consistency will still</span><span class="comment"> be ensured at scrape time, i.e. any inconsistencies will lead to scrape</span><span class="comment"> errors. Thus, with unchecked Collectors, the responsibility to not collect</span><span class="comment"> metrics that lead to inconsistencies in the total scrape result lies with the</span><span class="comment"> implementer of the Collector. While this is not a desirable state, it is</span><span class="comment"> sometimes necessary. The typical use case is a situation where the exact</span><span class="comment"> metrics to be returned by a Collector cannot be predicted at registration</span><span class="comment"> time, but the implementer has sufficient knowledge of the whole system to</span><span class="comment"> guarantee metric consistency.</span><span class="comment"></span><span class="comment"> The Collector example illustrates the use case. You can also look at the</span><span class="comment"> source code of the processCollector (mirroring process metrics), the</span><span class="comment"> goCollector (mirroring Go metrics), or the expvarCollector (mirroring expvar</span><span class="comment"> metrics) as examples that are used in this package itself.</span><span class="comment"></span><span class="comment"> If you just need to call a function to get a single float value to collect as</span><span class="comment"> a metric, GaugeFunc, CounterFunc, or UntypedFunc might be interesting</span><span class="comment"> shortcuts.</span><span class="comment"></span><span class="comment"> Advanced Uses of the Registry</span><span class="comment"></span><span class="comment"> While MustRegister is the by far most common way of registering a Collector,</span><span class="comment"> sometimes you might want to handle the errors the registration might cause.</span><span class="comment"> As suggested by the name, MustRegister panics if an error occurs. With the</span><span class="comment"> Register function, the error is returned and can be handled.</span><span class="comment"></span><span class="comment"> An error is returned if the registered Collector is incompatible or</span><span class="comment"> inconsistent with already registered metrics. The registry aims for</span><span class="comment"> consistency of the collected metrics according to the Prometheus data model.</span><span class="comment"> Inconsistencies are ideally detected at registration time, not at collect</span><span class="comment"> time. The former will usually be detected at start-up time of a program,</span><span class="comment"> while the latter will only happen at scrape time, possibly not even on the</span><span class="comment"> first scrape if the inconsistency only becomes relevant later. That is the</span><span class="comment"> main reason why a Collector and a Metric have to describe themselves to the</span><span class="comment"> registry.</span><span class="comment"></span><span class="comment"> So far, everything we did operated on the so-called default registry, as it</span><span class="comment"> can be found in the global DefaultRegisterer variable. With NewRegistry, you</span><span class="comment"> can create a custom registry, or you can even implement the Registerer or</span><span class="comment"> Gatherer interfaces yourself. The methods Register and Unregister work in the</span><span class="comment"> same way on a custom registry as the global functions Register and Unregister</span><span class="comment"> on the default registry.</span><span class="comment"></span><span class="comment"> There are a number of uses for custom registries: You can use registries with</span><span class="comment"> special properties, see NewPedanticRegistry. You can avoid global state, as</span><span class="comment"> it is imposed by the DefaultRegisterer. You can use multiple registries at</span><span class="comment"> the same time to expose different metrics in different ways.  You can use</span><span class="comment"> separate registries for testing purposes.</span><span class="comment"></span><span class="comment"> Also note that the DefaultRegisterer comes registered with a Collector for Go</span><span class="comment"> runtime metrics (via NewGoCollector) and a Collector for process metrics (via</span><span class="comment"> NewProcessCollector). With a custom registry, you are in control and decide</span><span class="comment"> yourself about the Collectors to register.</span><span class="comment"></span><span class="comment"> HTTP Exposition</span><span class="comment"></span><span class="comment"> The Registry implements the Gatherer interface. The caller of the Gather</span><span class="comment"> method can then expose the gathered metrics in some way. Usually, the metrics</span><span class="comment"> are served via HTTP on the /metrics endpoint. That's happening in the example</span><span class="comment"> above. The tools to expose metrics via HTTP are in the promhttp sub-package.</span><span class="comment"></span><span class="comment"> Pushing to the Pushgateway</span><span class="comment"></span><span class="comment"> Function for pushing to the Pushgateway can be found in the push sub-package.</span><span class="comment"></span><span class="comment"> Graphite Bridge</span><span class="comment"></span><span class="comment"> Functions and examples to push metrics from a Gatherer to Graphite can be</span><span class="comment"> found in the graphite sub-package.</span><span class="comment"></span><span class="comment"> Other Means of Exposition</span><span class="comment"></span><span class="comment"> More ways of exposing metrics can easily be added by following the approaches</span><span class="comment"> of the existing implementations.</span></div>
<div class="code"><pre><code></code></pre></div></div>

</div><pre id="footer">
<table><tr><td><img src="../../../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/article/tool-golds.html"><b>Golds</b></a> <i>v0.3.2-preview</i>. (GOOS=darwin GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>