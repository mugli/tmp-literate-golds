<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: trace.go in package runtime/trace</title>
<link href="../../../css/lightLiterate-v0.3.2-preview.css" rel="stylesheet">
<script src="../../../jvs/golds-v0.3.2-preview.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	trace.go

<span class="title">Belonging Package</span>
	<a href="../../../pkg/runtime/trace.html">runtime/trace</a>
</code></pre>
<style>input[type=radio] {display: none;}
input[id=r0]:checked ~pre label[for=r0],
input[id=r1]:checked ~pre label[for=r1],
input[id=r2]:checked ~pre label[for=r2],
input[id=r3]:checked ~pre label[for=r3],
input[id=r4]:checked ~pre label[for=r4]
{background: #226; color: #ff8;}
input[id=i0]:checked ~pre .i0,
input[id=i1]:checked ~pre .i1,
input[id=i2]:checked ~pre .i2,
input[id=i3]:checked ~pre .i3
{background: brown; color: #eed;}
</style><input id="r0" type="radio" name="g"/>
<input id="r1" type="radio" name="g"/>
<input id="r2" type="radio" name="g"/>
<input id="r3" type="radio" name="g"/>
<input id="r4" type="radio" name="g"/>
<input id="i0" type="radio" name="i"/>
<input id="i1" type="radio" name="i"/>
<input id="i2" type="radio" name="i"/>
<input id="i3" type="radio" name="i"/>
<div id="container"><div class="section">
<div class="doc">
<span class="comment"> Copyright 2015 The Go Authors. All rights reserved.</span><span class="comment"> Use of this source code is governed by a BSD-style</span><span class="comment"> license that can be found in the LICENSE file.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Package trace contains facilities for programs to generate traces</span><span class="comment"> for the Go execution tracer.</span><span class="comment"></span><span class="comment"> Tracing runtime activities</span><span class="comment"></span><span class="comment"> The execution trace captures a wide range of execution events such as</span><span class="comment"> goroutine creation/blocking/unblocking, syscall enter/exit/block,</span><span class="comment"> GC-related events, changes of heap size, processor start/stop, etc.</span><span class="comment"> A precise nanosecond-precision timestamp and a stack trace is</span><span class="comment"> captured for most events. The generated trace can be interpreted</span><span class="comment"> using `go tool trace`.</span><span class="comment"></span><span class="comment"> Support for tracing tests and benchmarks built with the standard</span><span class="comment"> testing package is built into `go test`. For example, the following</span><span class="comment"> command runs the test in the current directory and writes the trace</span><span class="comment"> file (trace.out).</span><span class="comment"></span><span class="comment">    go test -trace=trace.out</span><span class="comment"></span><span class="comment"> This runtime/trace package provides APIs to add equivalent tracing</span><span class="comment"> support to a standalone program. See the Example that demonstrates</span><span class="comment"> how to use this API to enable tracing.</span><span class="comment"></span><span class="comment"> There is also a standard HTTP interface to trace data. Adding the</span><span class="comment"> following line will install a handler under the /debug/pprof/trace URL</span><span class="comment"> to download a live trace:</span><span class="comment"></span><span class="comment">     import _ "net/http/pprof"</span><span class="comment"></span><span class="comment"> See the net/http/pprof package for more details about all of the</span><span class="comment"> debug endpoints installed by this import.</span><span class="comment"></span><span class="comment"> User annotation</span><span class="comment"></span><span class="comment"> Package trace provides user annotation APIs that can be used to</span><span class="comment"> log interesting events during execution.</span><span class="comment"></span><span class="comment"> There are three types of user annotations: log messages, regions,</span><span class="comment"> and tasks.</span><span class="comment"></span><span class="comment"> Log emits a timestamped message to the execution trace along with</span><span class="comment"> additional information such as the category of the message and</span><span class="comment"> which goroutine called Log. The execution tracer provides UIs to filter</span><span class="comment"> and group goroutines using the log category and the message supplied</span><span class="comment"> in Log.</span><span class="comment"></span><span class="comment"> A region is for logging a time interval during a goroutine's execution.</span><span class="comment"> By definition, a region starts and ends in the same goroutine.</span><span class="comment"> Regions can be nested to represent subintervals.</span><span class="comment"> For example, the following code records four regions in the execution</span><span class="comment"> trace to trace the durations of sequential steps in a cappuccino making</span><span class="comment"> operation.</span><span class="comment"></span><span class="comment">   trace.WithRegion(ctx, "makeCappuccino", func() {</span><span class="comment"></span><span class="comment">      // orderID allows to identify a specific order</span><span class="comment">      // among many cappuccino order region records.</span><span class="comment">      trace.Log(ctx, "orderID", orderID)</span><span class="comment"></span><span class="comment">      trace.WithRegion(ctx, "steamMilk", steamMilk)</span><span class="comment">      trace.WithRegion(ctx, "extractCoffee", extractCoffee)</span><span class="comment">      trace.WithRegion(ctx, "mixMilkCoffee", mixMilkCoffee)</span><span class="comment">   })</span><span class="comment"></span><span class="comment"> A task is a higher-level component that aids tracing of logical</span><span class="comment"> operations such as an RPC request, an HTTP request, or an</span><span class="comment"> interesting local operation which may require multiple goroutines</span><span class="comment"> working together. Since tasks can involve multiple goroutines,</span><span class="comment"> they are tracked via a context.Context object. NewTask creates</span><span class="comment"> a new task and embeds it in the returned context.Context object.</span><span class="comment"> Log messages and regions are attached to the task, if any, in the</span><span class="comment"> Context passed to Log and WithRegion.</span><span class="comment"></span><span class="comment"> For example, assume that we decided to froth milk, extract coffee,</span><span class="comment"> and mix milk and coffee in separate goroutines. With a task,</span><span class="comment"> the trace tool can identify the goroutines involved in a specific</span><span class="comment"> cappuccino order.</span><span class="comment"></span><span class="comment">      ctx, task := trace.NewTask(ctx, "makeCappuccino")</span><span class="comment">      trace.Log(ctx, "orderID", orderID)</span><span class="comment"></span><span class="comment">      milk := make(chan bool)</span><span class="comment">      espresso := make(chan bool)</span><span class="comment"></span><span class="comment">      go func() {</span><span class="comment">              trace.WithRegion(ctx, "steamMilk", steamMilk)</span><span class="comment">              milk &lt;- true</span><span class="comment">      }()</span><span class="comment">      go func() {</span><span class="comment">              trace.WithRegion(ctx, "extractCoffee", extractCoffee)</span><span class="comment">              espresso &lt;- true</span><span class="comment">      }()</span><span class="comment">      go func() {</span><span class="comment">              defer task.End() // When assemble is done, the order is complete.</span><span class="comment">              &lt;-espresso</span><span class="comment">              &lt;-milk</span><span class="comment">              trace.WithRegion(ctx, "mixMilkCoffee", mixMilkCoffee)</span><span class="comment">      }()</span><span class="comment"></span><span class="comment"></span><span class="comment"> The trace tool computes the latency of a task by measuring the</span><span class="comment"> time between the task creation and the task end and provides</span><span class="comment"> latency distributions for each task type found in the trace.</span></div>
<div class="code"><pre><code><span class="keyword">package</span> trace

<span class="keyword">import</span> (
	<label for="i0"><span class="lit-string i0">"io"</span></label>
	<label for="i1"><span class="lit-string i1">"runtime"</span></label>
	<label for="i2"><span class="lit-string i2">"sync"</span></label>
	<label for="i3"><span class="lit-string i3">"sync/atomic"</span></label>
)
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Start enables tracing for the current program.</span><span class="comment"> While tracing, the trace will be buffered and written to w.</span><span class="comment"> Start returns an error if tracing is already enabled.</span></div>
<div class="code"><pre><code><span class="keyword">func</span> <label for="r0" class="ident"><a href="../../../pkg/runtime/trace.html#name-Start" class="ident">Start</a></label>(<label for="r1" class="ident">w</label> <a href="../../../pkg/io.html" class="ident i0">io</a>.<a href="../../io/io.go.html#line-96" class="ident">Writer</a>) <a href="../../../pkg/builtin.html#name-error" class="ident">error</a> {
	<a href="#line-150" class="ident">tracing</a>.<a href="../../sync/mutex.go.html#line-72" class="ident">Lock</a>()
	<span class="keyword">defer</span> <a href="#line-150" class="ident">tracing</a>.<a href="../../sync/mutex.go.html#line-179" class="ident">Unlock</a>()

	<span class="keyword">if</span> <label for="r2" class="ident">err</label> := <a href="../../../pkg/runtime.html" class="ident i1">runtime</a>.<a href="../trace.go.html#line-183" class="ident">StartTrace</a>(); <label for="r2" class="ident">err</label> != <a href="../../../pkg/builtin.html#name-nil" class="ident">nil</a> {
		<span class="keyword">return</span> <label for="r2" class="ident">err</label>
	}
	<span class="keyword">go</span> <span class="keyword">func</span>() {
		<span class="keyword">for</span> {
			<label for="r3" class="ident">data</label> := <a href="../../../pkg/runtime.html" class="ident i1">runtime</a>.<a href="../trace.go.html#line-376" class="ident">ReadTrace</a>()
			<span class="keyword">if</span> <label for="r3" class="ident">data</label> == <a href="../../../pkg/builtin.html#name-nil" class="ident">nil</a> {
				<span class="keyword">break</span>
			}
			<label for="r1" class="ident">w</label>.<a href="../../io/io.go.html#line-97" class="ident">Write</a>(<label for="r3" class="ident">data</label>)
		}
	}()
	<a href="../../../pkg/sync/atomic.html" class="ident i3">atomic</a>.<a href="../../sync/atomic/doc.go.html#line-129" class="ident">StoreInt32</a>(&amp;<a href="#line-150" class="ident">tracing</a>.<a href="#line-152" class="ident">enabled</a>, <span class="lit-number">1</span>)
	<span class="keyword">return</span> <a href="../../../pkg/builtin.html#name-nil" class="ident">nil</a>
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Stop stops the current tracing, if any.</span><span class="comment"> Stop only returns after all the writes for the trace have completed.</span></div>
<div class="code"><pre><code><span class="keyword">func</span> <label for="r4" class="ident"><a href="../../../pkg/runtime/trace.html#name-Stop" class="ident">Stop</a></label>() {
	<a href="#line-150" class="ident">tracing</a>.<a href="../../sync/mutex.go.html#line-72" class="ident">Lock</a>()
	<span class="keyword">defer</span> <a href="#line-150" class="ident">tracing</a>.<a href="../../sync/mutex.go.html#line-179" class="ident">Unlock</a>()
	<a href="../../../pkg/sync/atomic.html" class="ident i3">atomic</a>.<a href="../../sync/atomic/doc.go.html#line-129" class="ident">StoreInt32</a>(&amp;<a href="#line-150" class="ident">tracing</a>.<a href="#line-152" class="ident">enabled</a>, <span class="lit-number">0</span>)

	<a href="../../../pkg/runtime.html" class="ident i1">runtime</a>.<a href="../trace.go.html#line-283" class="ident">StopTrace</a>()
}

<span class="keyword">var</span> <a href="../../../pkg/runtime/trace.html#name-tracing" class="ident">tracing</a> <span class="keyword">struct</span> {
	<a href="../../../pkg/sync.html" class="ident i2">sync</a>.<a href="../../sync/mutex.go.html#line-25" class="ident">Mutex</a>       <span class="comment">// gate mutators (Start, Stop)</span>
	enabled    <a href="../../../pkg/builtin.html#name-int32" class="ident">int32</a> <span class="comment">// accessed via atomic</span>
</code></pre></div></div>

</div><pre id="footer">
<table><tr><td><img src="../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/article/tool-golds.html"><b>Golds</b></a> <i>v0.3.2-preview</i>. (GOOS=darwin GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>