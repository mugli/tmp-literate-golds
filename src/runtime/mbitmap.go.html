<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: mbitmap.go in package runtime</title>
<link href="../../css/lightLiterate-v0.3.2-preview.css" rel="stylesheet">
<script src="../../jvs/golds-v0.3.2-preview.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	mbitmap.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/runtime.html">runtime</a>
</code></pre>
<style>input[type=radio] {display: none;}
input[id=r0]:checked ~pre label[for=r0],
input[id=r1]:checked ~pre label[for=r1],
input[id=r2]:checked ~pre label[for=r2],
input[id=r3]:checked ~pre label[for=r3],
input[id=r4]:checked ~pre label[for=r4],
input[id=r5]:checked ~pre label[for=r5],
input[id=r6]:checked ~pre label[for=r6],
input[id=r7]:checked ~pre label[for=r7],
input[id=r8]:checked ~pre label[for=r8],
input[id=r9]:checked ~pre label[for=r9],
input[id=r10]:checked ~pre label[for=r10],
input[id=r11]:checked ~pre label[for=r11],
input[id=r12]:checked ~pre label[for=r12],
input[id=r13]:checked ~pre label[for=r13],
input[id=r14]:checked ~pre label[for=r14],
input[id=r15]:checked ~pre label[for=r15],
input[id=r16]:checked ~pre label[for=r16],
input[id=r17]:checked ~pre label[for=r17],
input[id=r18]:checked ~pre label[for=r18],
input[id=r19]:checked ~pre label[for=r19],
input[id=r20]:checked ~pre label[for=r20],
input[id=r21]:checked ~pre label[for=r21],
input[id=r22]:checked ~pre label[for=r22],
input[id=r23]:checked ~pre label[for=r23],
input[id=r24]:checked ~pre label[for=r24],
input[id=r25]:checked ~pre label[for=r25],
input[id=r26]:checked ~pre label[for=r26],
input[id=r27]:checked ~pre label[for=r27],
input[id=r28]:checked ~pre label[for=r28],
input[id=r29]:checked ~pre label[for=r29],
input[id=r30]:checked ~pre label[for=r30],
input[id=r31]:checked ~pre label[for=r31],
input[id=r32]:checked ~pre label[for=r32],
input[id=r33]:checked ~pre label[for=r33],
input[id=r34]:checked ~pre label[for=r34],
input[id=r35]:checked ~pre label[for=r35],
input[id=r36]:checked ~pre label[for=r36],
input[id=r37]:checked ~pre label[for=r37],
input[id=r38]:checked ~pre label[for=r38],
input[id=r39]:checked ~pre label[for=r39],
input[id=r40]:checked ~pre label[for=r40],
input[id=r41]:checked ~pre label[for=r41],
input[id=r42]:checked ~pre label[for=r42],
input[id=r43]:checked ~pre label[for=r43],
input[id=r44]:checked ~pre label[for=r44],
input[id=r45]:checked ~pre label[for=r45],
input[id=r46]:checked ~pre label[for=r46],
input[id=r47]:checked ~pre label[for=r47],
input[id=r48]:checked ~pre label[for=r48],
input[id=r49]:checked ~pre label[for=r49],
input[id=r50]:checked ~pre label[for=r50],
input[id=r51]:checked ~pre label[for=r51],
input[id=r52]:checked ~pre label[for=r52],
input[id=r53]:checked ~pre label[for=r53],
input[id=r54]:checked ~pre label[for=r54],
input[id=r55]:checked ~pre label[for=r55],
input[id=r56]:checked ~pre label[for=r56],
input[id=r57]:checked ~pre label[for=r57],
input[id=r58]:checked ~pre label[for=r58],
input[id=r59]:checked ~pre label[for=r59],
input[id=r60]:checked ~pre label[for=r60],
input[id=r61]:checked ~pre label[for=r61],
input[id=r62]:checked ~pre label[for=r62],
input[id=r63]:checked ~pre label[for=r63],
input[id=r64]:checked ~pre label[for=r64],
input[id=r65]:checked ~pre label[for=r65],
input[id=r66]:checked ~pre label[for=r66],
input[id=r67]:checked ~pre label[for=r67],
input[id=r68]:checked ~pre label[for=r68],
input[id=r69]:checked ~pre label[for=r69],
input[id=r70]:checked ~pre label[for=r70],
input[id=r71]:checked ~pre label[for=r71],
input[id=r72]:checked ~pre label[for=r72],
input[id=r73]:checked ~pre label[for=r73],
input[id=r74]:checked ~pre label[for=r74],
input[id=r75]:checked ~pre label[for=r75],
input[id=r76]:checked ~pre label[for=r76],
input[id=r77]:checked ~pre label[for=r77],
input[id=r78]:checked ~pre label[for=r78],
input[id=r79]:checked ~pre label[for=r79],
input[id=r80]:checked ~pre label[for=r80],
input[id=r81]:checked ~pre label[for=r81],
input[id=r82]:checked ~pre label[for=r82],
input[id=r83]:checked ~pre label[for=r83],
input[id=r84]:checked ~pre label[for=r84],
input[id=r85]:checked ~pre label[for=r85],
input[id=r86]:checked ~pre label[for=r86],
input[id=r87]:checked ~pre label[for=r87],
input[id=r88]:checked ~pre label[for=r88],
input[id=r89]:checked ~pre label[for=r89],
input[id=r90]:checked ~pre label[for=r90],
input[id=r91]:checked ~pre label[for=r91],
input[id=r92]:checked ~pre label[for=r92],
input[id=r93]:checked ~pre label[for=r93],
input[id=r94]:checked ~pre label[for=r94],
input[id=r95]:checked ~pre label[for=r95],
input[id=r96]:checked ~pre label[for=r96],
input[id=r97]:checked ~pre label[for=r97],
input[id=r98]:checked ~pre label[for=r98],
input[id=r99]:checked ~pre label[for=r99],
input[id=r100]:checked ~pre label[for=r100],
input[id=r101]:checked ~pre label[for=r101],
input[id=r102]:checked ~pre label[for=r102],
input[id=r103]:checked ~pre label[for=r103],
input[id=r104]:checked ~pre label[for=r104],
input[id=r105]:checked ~pre label[for=r105],
input[id=r106]:checked ~pre label[for=r106],
input[id=r107]:checked ~pre label[for=r107],
input[id=r108]:checked ~pre label[for=r108],
input[id=r109]:checked ~pre label[for=r109],
input[id=r110]:checked ~pre label[for=r110],
input[id=r111]:checked ~pre label[for=r111],
input[id=r112]:checked ~pre label[for=r112],
input[id=r113]:checked ~pre label[for=r113],
input[id=r114]:checked ~pre label[for=r114],
input[id=r115]:checked ~pre label[for=r115],
input[id=r116]:checked ~pre label[for=r116],
input[id=r117]:checked ~pre label[for=r117],
input[id=r118]:checked ~pre label[for=r118],
input[id=r119]:checked ~pre label[for=r119],
input[id=r120]:checked ~pre label[for=r120],
input[id=r121]:checked ~pre label[for=r121],
input[id=r122]:checked ~pre label[for=r122],
input[id=r123]:checked ~pre label[for=r123],
input[id=r124]:checked ~pre label[for=r124],
input[id=r125]:checked ~pre label[for=r125],
input[id=r126]:checked ~pre label[for=r126],
input[id=r127]:checked ~pre label[for=r127],
input[id=r128]:checked ~pre label[for=r128],
input[id=r129]:checked ~pre label[for=r129],
input[id=r130]:checked ~pre label[for=r130],
input[id=r131]:checked ~pre label[for=r131],
input[id=r132]:checked ~pre label[for=r132],
input[id=r133]:checked ~pre label[for=r133],
input[id=r134]:checked ~pre label[for=r134],
input[id=r135]:checked ~pre label[for=r135],
input[id=r136]:checked ~pre label[for=r136],
input[id=r137]:checked ~pre label[for=r137],
input[id=r138]:checked ~pre label[for=r138],
input[id=r139]:checked ~pre label[for=r139],
input[id=r140]:checked ~pre label[for=r140],
input[id=r141]:checked ~pre label[for=r141],
input[id=r142]:checked ~pre label[for=r142],
input[id=r143]:checked ~pre label[for=r143],
input[id=r144]:checked ~pre label[for=r144],
input[id=r145]:checked ~pre label[for=r145],
input[id=r146]:checked ~pre label[for=r146],
input[id=r147]:checked ~pre label[for=r147],
input[id=r148]:checked ~pre label[for=r148],
input[id=r149]:checked ~pre label[for=r149],
input[id=r150]:checked ~pre label[for=r150],
input[id=r151]:checked ~pre label[for=r151],
input[id=r152]:checked ~pre label[for=r152],
input[id=r153]:checked ~pre label[for=r153],
input[id=r154]:checked ~pre label[for=r154],
input[id=r155]:checked ~pre label[for=r155],
input[id=r156]:checked ~pre label[for=r156],
input[id=r157]:checked ~pre label[for=r157],
input[id=r158]:checked ~pre label[for=r158],
input[id=r159]:checked ~pre label[for=r159],
input[id=r160]:checked ~pre label[for=r160],
input[id=r161]:checked ~pre label[for=r161],
input[id=r162]:checked ~pre label[for=r162],
input[id=r163]:checked ~pre label[for=r163],
input[id=r164]:checked ~pre label[for=r164],
input[id=r165]:checked ~pre label[for=r165],
input[id=r166]:checked ~pre label[for=r166],
input[id=r167]:checked ~pre label[for=r167],
input[id=r168]:checked ~pre label[for=r168],
input[id=r169]:checked ~pre label[for=r169],
input[id=r170]:checked ~pre label[for=r170],
input[id=r171]:checked ~pre label[for=r171],
input[id=r172]:checked ~pre label[for=r172],
input[id=r173]:checked ~pre label[for=r173],
input[id=r174]:checked ~pre label[for=r174],
input[id=r175]:checked ~pre label[for=r175],
input[id=r176]:checked ~pre label[for=r176],
input[id=r177]:checked ~pre label[for=r177],
input[id=r178]:checked ~pre label[for=r178],
input[id=r179]:checked ~pre label[for=r179],
input[id=r180]:checked ~pre label[for=r180],
input[id=r181]:checked ~pre label[for=r181],
input[id=r182]:checked ~pre label[for=r182],
input[id=r183]:checked ~pre label[for=r183],
input[id=r184]:checked ~pre label[for=r184],
input[id=r185]:checked ~pre label[for=r185],
input[id=r186]:checked ~pre label[for=r186],
input[id=r187]:checked ~pre label[for=r187],
input[id=r188]:checked ~pre label[for=r188],
input[id=r189]:checked ~pre label[for=r189],
input[id=r190]:checked ~pre label[for=r190],
input[id=r191]:checked ~pre label[for=r191],
input[id=r192]:checked ~pre label[for=r192],
input[id=r193]:checked ~pre label[for=r193],
input[id=r194]:checked ~pre label[for=r194],
input[id=r195]:checked ~pre label[for=r195],
input[id=r196]:checked ~pre label[for=r196],
input[id=r197]:checked ~pre label[for=r197],
input[id=r198]:checked ~pre label[for=r198],
input[id=r199]:checked ~pre label[for=r199],
input[id=r200]:checked ~pre label[for=r200],
input[id=r201]:checked ~pre label[for=r201],
input[id=r202]:checked ~pre label[for=r202],
input[id=r203]:checked ~pre label[for=r203],
input[id=r204]:checked ~pre label[for=r204],
input[id=r205]:checked ~pre label[for=r205],
input[id=r206]:checked ~pre label[for=r206],
input[id=r207]:checked ~pre label[for=r207],
input[id=r208]:checked ~pre label[for=r208],
input[id=r209]:checked ~pre label[for=r209],
input[id=r210]:checked ~pre label[for=r210],
input[id=r211]:checked ~pre label[for=r211],
input[id=r212]:checked ~pre label[for=r212],
input[id=r213]:checked ~pre label[for=r213],
input[id=r214]:checked ~pre label[for=r214],
input[id=r215]:checked ~pre label[for=r215],
input[id=r216]:checked ~pre label[for=r216],
input[id=r217]:checked ~pre label[for=r217],
input[id=r218]:checked ~pre label[for=r218],
input[id=r219]:checked ~pre label[for=r219],
input[id=r220]:checked ~pre label[for=r220],
input[id=r221]:checked ~pre label[for=r221],
input[id=r222]:checked ~pre label[for=r222],
input[id=r223]:checked ~pre label[for=r223],
input[id=r224]:checked ~pre label[for=r224],
input[id=r225]:checked ~pre label[for=r225],
input[id=r226]:checked ~pre label[for=r226],
input[id=r227]:checked ~pre label[for=r227],
input[id=r228]:checked ~pre label[for=r228],
input[id=r229]:checked ~pre label[for=r229],
input[id=r230]:checked ~pre label[for=r230],
input[id=r231]:checked ~pre label[for=r231],
input[id=r232]:checked ~pre label[for=r232],
input[id=r233]:checked ~pre label[for=r233],
input[id=r234]:checked ~pre label[for=r234],
input[id=r235]:checked ~pre label[for=r235],
input[id=r236]:checked ~pre label[for=r236],
input[id=r237]:checked ~pre label[for=r237],
input[id=r238]:checked ~pre label[for=r238],
input[id=r239]:checked ~pre label[for=r239],
input[id=r240]:checked ~pre label[for=r240],
input[id=r241]:checked ~pre label[for=r241],
input[id=r242]:checked ~pre label[for=r242],
input[id=r243]:checked ~pre label[for=r243],
input[id=r244]:checked ~pre label[for=r244],
input[id=r245]:checked ~pre label[for=r245],
input[id=r246]:checked ~pre label[for=r246],
input[id=r247]:checked ~pre label[for=r247],
input[id=r248]:checked ~pre label[for=r248],
input[id=r249]:checked ~pre label[for=r249],
input[id=r250]:checked ~pre label[for=r250],
input[id=r251]:checked ~pre label[for=r251],
input[id=r252]:checked ~pre label[for=r252],
input[id=r253]:checked ~pre label[for=r253],
input[id=r254]:checked ~pre label[for=r254],
input[id=r255]:checked ~pre label[for=r255],
input[id=r256]:checked ~pre label[for=r256],
input[id=r257]:checked ~pre label[for=r257],
input[id=r258]:checked ~pre label[for=r258],
input[id=r259]:checked ~pre label[for=r259],
input[id=r260]:checked ~pre label[for=r260],
input[id=r261]:checked ~pre label[for=r261],
input[id=r262]:checked ~pre label[for=r262],
input[id=r263]:checked ~pre label[for=r263],
input[id=r264]:checked ~pre label[for=r264],
input[id=r265]:checked ~pre label[for=r265],
input[id=r266]:checked ~pre label[for=r266],
input[id=r267]:checked ~pre label[for=r267],
input[id=r268]:checked ~pre label[for=r268],
input[id=r269]:checked ~pre label[for=r269],
input[id=r270]:checked ~pre label[for=r270],
input[id=r271]:checked ~pre label[for=r271],
input[id=r272]:checked ~pre label[for=r272],
input[id=r273]:checked ~pre label[for=r273],
input[id=r274]:checked ~pre label[for=r274],
input[id=r275]:checked ~pre label[for=r275],
input[id=r276]:checked ~pre label[for=r276],
input[id=r277]:checked ~pre label[for=r277],
input[id=r278]:checked ~pre label[for=r278],
input[id=r279]:checked ~pre label[for=r279],
input[id=r280]:checked ~pre label[for=r280],
input[id=r281]:checked ~pre label[for=r281],
input[id=r282]:checked ~pre label[for=r282],
input[id=r283]:checked ~pre label[for=r283],
input[id=r284]:checked ~pre label[for=r284],
input[id=r285]:checked ~pre label[for=r285],
input[id=r286]:checked ~pre label[for=r286],
input[id=r287]:checked ~pre label[for=r287],
input[id=r288]:checked ~pre label[for=r288],
input[id=r289]:checked ~pre label[for=r289],
input[id=r290]:checked ~pre label[for=r290],
input[id=r291]:checked ~pre label[for=r291],
input[id=r292]:checked ~pre label[for=r292],
input[id=r293]:checked ~pre label[for=r293],
input[id=r294]:checked ~pre label[for=r294],
input[id=r295]:checked ~pre label[for=r295],
input[id=r296]:checked ~pre label[for=r296],
input[id=r297]:checked ~pre label[for=r297],
input[id=r298]:checked ~pre label[for=r298],
input[id=r299]:checked ~pre label[for=r299],
input[id=r300]:checked ~pre label[for=r300],
input[id=r301]:checked ~pre label[for=r301],
input[id=r302]:checked ~pre label[for=r302],
input[id=r303]:checked ~pre label[for=r303],
input[id=r304]:checked ~pre label[for=r304],
input[id=r305]:checked ~pre label[for=r305],
input[id=r306]:checked ~pre label[for=r306],
input[id=r307]:checked ~pre label[for=r307],
input[id=r308]:checked ~pre label[for=r308],
input[id=r309]:checked ~pre label[for=r309],
input[id=r310]:checked ~pre label[for=r310],
input[id=r311]:checked ~pre label[for=r311],
input[id=r312]:checked ~pre label[for=r312],
input[id=r313]:checked ~pre label[for=r313],
input[id=r314]:checked ~pre label[for=r314],
input[id=r315]:checked ~pre label[for=r315],
input[id=r316]:checked ~pre label[for=r316],
input[id=r317]:checked ~pre label[for=r317],
input[id=r318]:checked ~pre label[for=r318],
input[id=r319]:checked ~pre label[for=r319],
input[id=r320]:checked ~pre label[for=r320],
input[id=r321]:checked ~pre label[for=r321],
input[id=r322]:checked ~pre label[for=r322],
input[id=r323]:checked ~pre label[for=r323],
input[id=r324]:checked ~pre label[for=r324],
input[id=r325]:checked ~pre label[for=r325],
input[id=r326]:checked ~pre label[for=r326],
input[id=r327]:checked ~pre label[for=r327],
input[id=r328]:checked ~pre label[for=r328],
input[id=r329]:checked ~pre label[for=r329],
input[id=r330]:checked ~pre label[for=r330],
input[id=r331]:checked ~pre label[for=r331],
input[id=r332]:checked ~pre label[for=r332],
input[id=r333]:checked ~pre label[for=r333],
input[id=r334]:checked ~pre label[for=r334]
{background: #226; color: #ff8;}
input[id=i0]:checked ~pre .i0,
input[id=i1]:checked ~pre .i1,
input[id=i2]:checked ~pre .i2
{background: brown; color: #eed;}
</style><input id="r0" type="radio" name="g"/>
<input id="r1" type="radio" name="g"/>
<input id="r2" type="radio" name="g"/>
<input id="r3" type="radio" name="g"/>
<input id="r4" type="radio" name="g"/>
<input id="r5" type="radio" name="g"/>
<input id="r6" type="radio" name="g"/>
<input id="r7" type="radio" name="g"/>
<input id="r8" type="radio" name="g"/>
<input id="r9" type="radio" name="g"/>
<input id="r10" type="radio" name="g"/>
<input id="r11" type="radio" name="g"/>
<input id="r12" type="radio" name="g"/>
<input id="r13" type="radio" name="g"/>
<input id="r14" type="radio" name="g"/>
<input id="r15" type="radio" name="g"/>
<input id="r16" type="radio" name="g"/>
<input id="r17" type="radio" name="g"/>
<input id="r18" type="radio" name="g"/>
<input id="r19" type="radio" name="g"/>
<input id="r20" type="radio" name="g"/>
<input id="r21" type="radio" name="g"/>
<input id="r22" type="radio" name="g"/>
<input id="r23" type="radio" name="g"/>
<input id="r24" type="radio" name="g"/>
<input id="r25" type="radio" name="g"/>
<input id="r26" type="radio" name="g"/>
<input id="r27" type="radio" name="g"/>
<input id="r28" type="radio" name="g"/>
<input id="r29" type="radio" name="g"/>
<input id="r30" type="radio" name="g"/>
<input id="r31" type="radio" name="g"/>
<input id="r32" type="radio" name="g"/>
<input id="r33" type="radio" name="g"/>
<input id="r34" type="radio" name="g"/>
<input id="r35" type="radio" name="g"/>
<input id="r36" type="radio" name="g"/>
<input id="r37" type="radio" name="g"/>
<input id="r38" type="radio" name="g"/>
<input id="r39" type="radio" name="g"/>
<input id="r40" type="radio" name="g"/>
<input id="r41" type="radio" name="g"/>
<input id="r42" type="radio" name="g"/>
<input id="r43" type="radio" name="g"/>
<input id="r44" type="radio" name="g"/>
<input id="r45" type="radio" name="g"/>
<input id="r46" type="radio" name="g"/>
<input id="r47" type="radio" name="g"/>
<input id="r48" type="radio" name="g"/>
<input id="r49" type="radio" name="g"/>
<input id="r50" type="radio" name="g"/>
<input id="r51" type="radio" name="g"/>
<input id="r52" type="radio" name="g"/>
<input id="r53" type="radio" name="g"/>
<input id="r54" type="radio" name="g"/>
<input id="r55" type="radio" name="g"/>
<input id="r56" type="radio" name="g"/>
<input id="r57" type="radio" name="g"/>
<input id="r58" type="radio" name="g"/>
<input id="r59" type="radio" name="g"/>
<input id="r60" type="radio" name="g"/>
<input id="r61" type="radio" name="g"/>
<input id="r62" type="radio" name="g"/>
<input id="r63" type="radio" name="g"/>
<input id="r64" type="radio" name="g"/>
<input id="r65" type="radio" name="g"/>
<input id="r66" type="radio" name="g"/>
<input id="r67" type="radio" name="g"/>
<input id="r68" type="radio" name="g"/>
<input id="r69" type="radio" name="g"/>
<input id="r70" type="radio" name="g"/>
<input id="r71" type="radio" name="g"/>
<input id="r72" type="radio" name="g"/>
<input id="r73" type="radio" name="g"/>
<input id="r74" type="radio" name="g"/>
<input id="r75" type="radio" name="g"/>
<input id="r76" type="radio" name="g"/>
<input id="r77" type="radio" name="g"/>
<input id="r78" type="radio" name="g"/>
<input id="r79" type="radio" name="g"/>
<input id="r80" type="radio" name="g"/>
<input id="r81" type="radio" name="g"/>
<input id="r82" type="radio" name="g"/>
<input id="r83" type="radio" name="g"/>
<input id="r84" type="radio" name="g"/>
<input id="r85" type="radio" name="g"/>
<input id="r86" type="radio" name="g"/>
<input id="r87" type="radio" name="g"/>
<input id="r88" type="radio" name="g"/>
<input id="r89" type="radio" name="g"/>
<input id="r90" type="radio" name="g"/>
<input id="r91" type="radio" name="g"/>
<input id="r92" type="radio" name="g"/>
<input id="r93" type="radio" name="g"/>
<input id="r94" type="radio" name="g"/>
<input id="r95" type="radio" name="g"/>
<input id="r96" type="radio" name="g"/>
<input id="r97" type="radio" name="g"/>
<input id="r98" type="radio" name="g"/>
<input id="r99" type="radio" name="g"/>
<input id="r100" type="radio" name="g"/>
<input id="r101" type="radio" name="g"/>
<input id="r102" type="radio" name="g"/>
<input id="r103" type="radio" name="g"/>
<input id="r104" type="radio" name="g"/>
<input id="r105" type="radio" name="g"/>
<input id="r106" type="radio" name="g"/>
<input id="r107" type="radio" name="g"/>
<input id="r108" type="radio" name="g"/>
<input id="r109" type="radio" name="g"/>
<input id="r110" type="radio" name="g"/>
<input id="r111" type="radio" name="g"/>
<input id="r112" type="radio" name="g"/>
<input id="r113" type="radio" name="g"/>
<input id="r114" type="radio" name="g"/>
<input id="r115" type="radio" name="g"/>
<input id="r116" type="radio" name="g"/>
<input id="r117" type="radio" name="g"/>
<input id="r118" type="radio" name="g"/>
<input id="r119" type="radio" name="g"/>
<input id="r120" type="radio" name="g"/>
<input id="r121" type="radio" name="g"/>
<input id="r122" type="radio" name="g"/>
<input id="r123" type="radio" name="g"/>
<input id="r124" type="radio" name="g"/>
<input id="r125" type="radio" name="g"/>
<input id="r126" type="radio" name="g"/>
<input id="r127" type="radio" name="g"/>
<input id="r128" type="radio" name="g"/>
<input id="r129" type="radio" name="g"/>
<input id="r130" type="radio" name="g"/>
<input id="r131" type="radio" name="g"/>
<input id="r132" type="radio" name="g"/>
<input id="r133" type="radio" name="g"/>
<input id="r134" type="radio" name="g"/>
<input id="r135" type="radio" name="g"/>
<input id="r136" type="radio" name="g"/>
<input id="r137" type="radio" name="g"/>
<input id="r138" type="radio" name="g"/>
<input id="r139" type="radio" name="g"/>
<input id="r140" type="radio" name="g"/>
<input id="r141" type="radio" name="g"/>
<input id="r142" type="radio" name="g"/>
<input id="r143" type="radio" name="g"/>
<input id="r144" type="radio" name="g"/>
<input id="r145" type="radio" name="g"/>
<input id="r146" type="radio" name="g"/>
<input id="r147" type="radio" name="g"/>
<input id="r148" type="radio" name="g"/>
<input id="r149" type="radio" name="g"/>
<input id="r150" type="radio" name="g"/>
<input id="r151" type="radio" name="g"/>
<input id="r152" type="radio" name="g"/>
<input id="r153" type="radio" name="g"/>
<input id="r154" type="radio" name="g"/>
<input id="r155" type="radio" name="g"/>
<input id="r156" type="radio" name="g"/>
<input id="r157" type="radio" name="g"/>
<input id="r158" type="radio" name="g"/>
<input id="r159" type="radio" name="g"/>
<input id="r160" type="radio" name="g"/>
<input id="r161" type="radio" name="g"/>
<input id="r162" type="radio" name="g"/>
<input id="r163" type="radio" name="g"/>
<input id="r164" type="radio" name="g"/>
<input id="r165" type="radio" name="g"/>
<input id="r166" type="radio" name="g"/>
<input id="r167" type="radio" name="g"/>
<input id="r168" type="radio" name="g"/>
<input id="r169" type="radio" name="g"/>
<input id="r170" type="radio" name="g"/>
<input id="r171" type="radio" name="g"/>
<input id="r172" type="radio" name="g"/>
<input id="r173" type="radio" name="g"/>
<input id="r174" type="radio" name="g"/>
<input id="r175" type="radio" name="g"/>
<input id="r176" type="radio" name="g"/>
<input id="r177" type="radio" name="g"/>
<input id="r178" type="radio" name="g"/>
<input id="r179" type="radio" name="g"/>
<input id="r180" type="radio" name="g"/>
<input id="r181" type="radio" name="g"/>
<input id="r182" type="radio" name="g"/>
<input id="r183" type="radio" name="g"/>
<input id="r184" type="radio" name="g"/>
<input id="r185" type="radio" name="g"/>
<input id="r186" type="radio" name="g"/>
<input id="r187" type="radio" name="g"/>
<input id="r188" type="radio" name="g"/>
<input id="r189" type="radio" name="g"/>
<input id="r190" type="radio" name="g"/>
<input id="r191" type="radio" name="g"/>
<input id="r192" type="radio" name="g"/>
<input id="r193" type="radio" name="g"/>
<input id="r194" type="radio" name="g"/>
<input id="r195" type="radio" name="g"/>
<input id="r196" type="radio" name="g"/>
<input id="r197" type="radio" name="g"/>
<input id="r198" type="radio" name="g"/>
<input id="r199" type="radio" name="g"/>
<input id="r200" type="radio" name="g"/>
<input id="r201" type="radio" name="g"/>
<input id="r202" type="radio" name="g"/>
<input id="r203" type="radio" name="g"/>
<input id="r204" type="radio" name="g"/>
<input id="r205" type="radio" name="g"/>
<input id="r206" type="radio" name="g"/>
<input id="r207" type="radio" name="g"/>
<input id="r208" type="radio" name="g"/>
<input id="r209" type="radio" name="g"/>
<input id="r210" type="radio" name="g"/>
<input id="r211" type="radio" name="g"/>
<input id="r212" type="radio" name="g"/>
<input id="r213" type="radio" name="g"/>
<input id="r214" type="radio" name="g"/>
<input id="r215" type="radio" name="g"/>
<input id="r216" type="radio" name="g"/>
<input id="r217" type="radio" name="g"/>
<input id="r218" type="radio" name="g"/>
<input id="r219" type="radio" name="g"/>
<input id="r220" type="radio" name="g"/>
<input id="r221" type="radio" name="g"/>
<input id="r222" type="radio" name="g"/>
<input id="r223" type="radio" name="g"/>
<input id="r224" type="radio" name="g"/>
<input id="r225" type="radio" name="g"/>
<input id="r226" type="radio" name="g"/>
<input id="r227" type="radio" name="g"/>
<input id="r228" type="radio" name="g"/>
<input id="r229" type="radio" name="g"/>
<input id="r230" type="radio" name="g"/>
<input id="r231" type="radio" name="g"/>
<input id="r232" type="radio" name="g"/>
<input id="r233" type="radio" name="g"/>
<input id="r234" type="radio" name="g"/>
<input id="r235" type="radio" name="g"/>
<input id="r236" type="radio" name="g"/>
<input id="r237" type="radio" name="g"/>
<input id="r238" type="radio" name="g"/>
<input id="r239" type="radio" name="g"/>
<input id="r240" type="radio" name="g"/>
<input id="r241" type="radio" name="g"/>
<input id="r242" type="radio" name="g"/>
<input id="r243" type="radio" name="g"/>
<input id="r244" type="radio" name="g"/>
<input id="r245" type="radio" name="g"/>
<input id="r246" type="radio" name="g"/>
<input id="r247" type="radio" name="g"/>
<input id="r248" type="radio" name="g"/>
<input id="r249" type="radio" name="g"/>
<input id="r250" type="radio" name="g"/>
<input id="r251" type="radio" name="g"/>
<input id="r252" type="radio" name="g"/>
<input id="r253" type="radio" name="g"/>
<input id="r254" type="radio" name="g"/>
<input id="r255" type="radio" name="g"/>
<input id="r256" type="radio" name="g"/>
<input id="r257" type="radio" name="g"/>
<input id="r258" type="radio" name="g"/>
<input id="r259" type="radio" name="g"/>
<input id="r260" type="radio" name="g"/>
<input id="r261" type="radio" name="g"/>
<input id="r262" type="radio" name="g"/>
<input id="r263" type="radio" name="g"/>
<input id="r264" type="radio" name="g"/>
<input id="r265" type="radio" name="g"/>
<input id="r266" type="radio" name="g"/>
<input id="r267" type="radio" name="g"/>
<input id="r268" type="radio" name="g"/>
<input id="r269" type="radio" name="g"/>
<input id="r270" type="radio" name="g"/>
<input id="r271" type="radio" name="g"/>
<input id="r272" type="radio" name="g"/>
<input id="r273" type="radio" name="g"/>
<input id="r274" type="radio" name="g"/>
<input id="r275" type="radio" name="g"/>
<input id="r276" type="radio" name="g"/>
<input id="r277" type="radio" name="g"/>
<input id="r278" type="radio" name="g"/>
<input id="r279" type="radio" name="g"/>
<input id="r280" type="radio" name="g"/>
<input id="r281" type="radio" name="g"/>
<input id="r282" type="radio" name="g"/>
<input id="r283" type="radio" name="g"/>
<input id="r284" type="radio" name="g"/>
<input id="r285" type="radio" name="g"/>
<input id="r286" type="radio" name="g"/>
<input id="r287" type="radio" name="g"/>
<input id="r288" type="radio" name="g"/>
<input id="r289" type="radio" name="g"/>
<input id="r290" type="radio" name="g"/>
<input id="r291" type="radio" name="g"/>
<input id="r292" type="radio" name="g"/>
<input id="r293" type="radio" name="g"/>
<input id="r294" type="radio" name="g"/>
<input id="r295" type="radio" name="g"/>
<input id="r296" type="radio" name="g"/>
<input id="r297" type="radio" name="g"/>
<input id="r298" type="radio" name="g"/>
<input id="r299" type="radio" name="g"/>
<input id="r300" type="radio" name="g"/>
<input id="r301" type="radio" name="g"/>
<input id="r302" type="radio" name="g"/>
<input id="r303" type="radio" name="g"/>
<input id="r304" type="radio" name="g"/>
<input id="r305" type="radio" name="g"/>
<input id="r306" type="radio" name="g"/>
<input id="r307" type="radio" name="g"/>
<input id="r308" type="radio" name="g"/>
<input id="r309" type="radio" name="g"/>
<input id="r310" type="radio" name="g"/>
<input id="r311" type="radio" name="g"/>
<input id="r312" type="radio" name="g"/>
<input id="r313" type="radio" name="g"/>
<input id="r314" type="radio" name="g"/>
<input id="r315" type="radio" name="g"/>
<input id="r316" type="radio" name="g"/>
<input id="r317" type="radio" name="g"/>
<input id="r318" type="radio" name="g"/>
<input id="r319" type="radio" name="g"/>
<input id="r320" type="radio" name="g"/>
<input id="r321" type="radio" name="g"/>
<input id="r322" type="radio" name="g"/>
<input id="r323" type="radio" name="g"/>
<input id="r324" type="radio" name="g"/>
<input id="r325" type="radio" name="g"/>
<input id="r326" type="radio" name="g"/>
<input id="r327" type="radio" name="g"/>
<input id="r328" type="radio" name="g"/>
<input id="r329" type="radio" name="g"/>
<input id="r330" type="radio" name="g"/>
<input id="r331" type="radio" name="g"/>
<input id="r332" type="radio" name="g"/>
<input id="r333" type="radio" name="g"/>
<input id="r334" type="radio" name="g"/>
<input id="i0" type="radio" name="i"/>
<input id="i1" type="radio" name="i"/>
<input id="i2" type="radio" name="i"/>
<div id="container"><div class="section">
<div class="doc">
<span class="comment"> Copyright 2009 The Go Authors. All rights reserved.</span><span class="comment"> Use of this source code is governed by a BSD-style</span><span class="comment"> license that can be found in the LICENSE file.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Garbage collector: type and heap bitmaps.</span><span class="comment"></span><span class="comment"> Stack, data, and bss bitmaps</span><span class="comment"></span><span class="comment"> Stack frames and global variables in the data and bss sections are</span><span class="comment"> described by bitmaps with 1 bit per pointer-sized word. A "1" bit</span><span class="comment"> means the word is a live pointer to be visited by the GC (referred to</span><span class="comment"> as "pointer"). A "0" bit means the word should be ignored by GC</span><span class="comment"> (referred to as "scalar", though it could be a dead pointer value).</span><span class="comment"></span><span class="comment"> Heap bitmap</span><span class="comment"></span><span class="comment"> The heap bitmap comprises 2 bits for each pointer-sized word in the heap,</span><span class="comment"> stored in the heapArena metadata backing each heap arena.</span><span class="comment"> That is, if ha is the heapArena for the arena starting a start,</span><span class="comment"> then ha.bitmap[0] holds the 2-bit entries for the four words start</span><span class="comment"> through start+3*ptrSize, ha.bitmap[1] holds the entries for</span><span class="comment"> start+4*ptrSize through start+7*ptrSize, and so on.</span><span class="comment"></span><span class="comment"> In each 2-bit entry, the lower bit is a pointer/scalar bit, just</span><span class="comment"> like in the stack/data bitmaps described above. The upper bit</span><span class="comment"> indicates scan/dead: a "1" value ("scan") indicates that there may</span><span class="comment"> be pointers in later words of the allocation, and a "0" value</span><span class="comment"> ("dead") indicates there are no more pointers in the allocation. If</span><span class="comment"> the upper bit is 0, the lower bit must also be 0, and this</span><span class="comment"> indicates scanning can ignore the rest of the allocation.</span><span class="comment"></span><span class="comment"> The 2-bit entries are split when written into the byte, so that the top half</span><span class="comment"> of the byte contains 4 high (scan) bits and the bottom half contains 4 low</span><span class="comment"> (pointer) bits. This form allows a copy from the 1-bit to the 4-bit form to</span><span class="comment"> keep the pointer bits contiguous, instead of having to space them out.</span><span class="comment"></span><span class="comment"> The code makes use of the fact that the zero value for a heap</span><span class="comment"> bitmap means scalar/dead. This property must be preserved when</span><span class="comment"> modifying the encoding.</span><span class="comment"></span><span class="comment"> The bitmap for noscan spans is not maintained. Code must ensure</span><span class="comment"> that an object is scannable before consulting its bitmap by</span><span class="comment"> checking either the noscan bit in the span or by consulting its</span><span class="comment"> type's information.</span></div>
<div class="code"><pre><code>
<span class="keyword">package</span> runtime

<span class="keyword">import</span> (
	<label for="i0"><span class="lit-string i0">"runtime/internal/atomic"</span></label>
	<label for="i1"><span class="lit-string i1">"runtime/internal/sys"</span></label>
	<label for="i2"><span class="lit-string i2">"unsafe"</span></label>
)

<span class="keyword">const</span> (
	<a href="../../pkg/runtime.html#name-bitPointer" class="ident">bitPointer</a> = <span class="lit-number">1</span> &lt;&lt; <span class="lit-number">0</span>
	<a href="../../pkg/runtime.html#name-bitScan" class="ident">bitScan</a>    = <span class="lit-number">1</span> &lt;&lt; <span class="lit-number">4</span>

	<a href="../../pkg/runtime.html#name-heapBitsShift" class="ident">heapBitsShift</a>      = <span class="lit-number">1</span>     <span class="comment">// shift offset between successive bitPointer or bitScan entries</span>
	<a href="../../pkg/runtime.html#name-wordsPerBitmapByte" class="ident">wordsPerBitmapByte</a> = <span class="lit-number">8</span> / <span class="lit-number">2</span> <span class="comment">// heap words described by one bitmap byte</span>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> all scan/pointer bits in a byte</span></div>
<div class="code"><pre><code>	<a href="../../pkg/runtime.html#name-bitScanAll" class="ident">bitScanAll</a>    = <a href="#line-56" class="ident">bitScan</a> | <a href="#line-56" class="ident">bitScan</a>&lt;&lt;<a href="#line-58" class="ident">heapBitsShift</a> | <a href="#line-56" class="ident">bitScan</a>&lt;&lt;(<span class="lit-number">2</span>*<a href="#line-58" class="ident">heapBitsShift</a>) | <a href="#line-56" class="ident">bitScan</a>&lt;&lt;(<span class="lit-number">3</span>*<a href="#line-58" class="ident">heapBitsShift</a>)
	<a href="../../pkg/runtime.html#name-bitPointerAll" class="ident">bitPointerAll</a> = <a href="#line-55" class="ident">bitPointer</a> | <a href="#line-55" class="ident">bitPointer</a>&lt;&lt;<a href="#line-58" class="ident">heapBitsShift</a> | <a href="#line-55" class="ident">bitPointer</a>&lt;&lt;(<span class="lit-number">2</span>*<a href="#line-58" class="ident">heapBitsShift</a>) | <a href="#line-55" class="ident">bitPointer</a>&lt;&lt;(<span class="lit-number">3</span>*<a href="#line-58" class="ident">heapBitsShift</a>)
)
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> addb returns the byte pointer p+n.</span><span class="comment">go:nowritebarrier</span><span class="comment">go:nosplit</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Note: wrote out full expression instead of calling add(p, n)</span><span class="comment">	 to reduce the number of temporaries generated by the</span><span class="comment">	 compiler for this trivial expression during inlining.</span></div>
<div class="code"><pre><code>	<span class="keyword">return</span> (*<a href="../../pkg/builtin.html#name-byte" class="ident">byte</a>)(<a href="../../pkg/unsafe.html" class="ident i2">unsafe</a>.<a href="../../pkg/unsafe.html#name-Pointer" class="ident">Pointer</a>(<a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<a href="../../pkg/unsafe.html" class="ident i2">unsafe</a>.<a href="../../pkg/unsafe.html#name-Pointer" class="ident">Pointer</a>(<label for="r1" class="ident">p</label>)) + <label for="r2" class="ident">n</label>))
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> subtractb returns the byte pointer p-n.</span><span class="comment">go:nowritebarrier</span><span class="comment">go:nosplit</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Note: wrote out full expression instead of calling add(p, -n)</span><span class="comment">	 to reduce the number of temporaries generated by the</span><span class="comment">	 compiler for this trivial expression during inlining.</span></div>
<div class="code"><pre><code>	<span class="keyword">return</span> (*<a href="../../pkg/builtin.html#name-byte" class="ident">byte</a>)(<a href="../../pkg/unsafe.html" class="ident i2">unsafe</a>.<a href="../../pkg/unsafe.html#name-Pointer" class="ident">Pointer</a>(<a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<a href="../../pkg/unsafe.html" class="ident i2">unsafe</a>.<a href="../../pkg/unsafe.html#name-Pointer" class="ident">Pointer</a>(<label for="r4" class="ident">p</label>)) - <label for="r5" class="ident">n</label>))
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> add1 returns the byte pointer p+1.</span><span class="comment">go:nowritebarrier</span><span class="comment">go:nosplit</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Note: wrote out full expression instead of calling addb(p, 1)</span><span class="comment">	 to reduce the number of temporaries generated by the</span><span class="comment">	 compiler for this trivial expression during inlining.</span></div>
<div class="code"><pre><code>	<span class="keyword">return</span> (*<a href="../../pkg/builtin.html#name-byte" class="ident">byte</a>)(<a href="../../pkg/unsafe.html" class="ident i2">unsafe</a>.<a href="../../pkg/unsafe.html#name-Pointer" class="ident">Pointer</a>(<a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<a href="../../pkg/unsafe.html" class="ident i2">unsafe</a>.<a href="../../pkg/unsafe.html#name-Pointer" class="ident">Pointer</a>(<label for="r7" class="ident">p</label>)) + <span class="lit-number">1</span>))
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> subtract1 returns the byte pointer p-1.</span><span class="comment">go:nowritebarrier</span><span class="comment"></span><span class="comment"> nosplit because it is used during write barriers and must not be preempted.</span><span class="comment">go:nosplit</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Note: wrote out full expression instead of calling subtractb(p, 1)</span><span class="comment">	 to reduce the number of temporaries generated by the</span><span class="comment">	 compiler for this trivial expression during inlining.</span></div>
<div class="code"><pre><code>	<span class="keyword">return</span> (*<a href="../../pkg/builtin.html#name-byte" class="ident">byte</a>)(<a href="../../pkg/unsafe.html" class="ident i2">unsafe</a>.<a href="../../pkg/unsafe.html#name-Pointer" class="ident">Pointer</a>(<a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<a href="../../pkg/unsafe.html" class="ident i2">unsafe</a>.<a href="../../pkg/unsafe.html#name-Pointer" class="ident">Pointer</a>(<label for="r9" class="ident">p</label>)) - <span class="lit-number">1</span>))
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> heapBits provides access to the bitmap bits for a single heap word.</span><span class="comment"> The methods on heapBits take value receivers so that the compiler</span><span class="comment"> can more easily inline calls to those methods and registerize the</span><span class="comment"> struct fields independently.</span></div>
<div class="code"><pre><code><span class="keyword">type</span> <a href="../../pkg/runtime.html#name-heapBits" class="ident">heapBits</a> <span class="keyword">struct</span> {
	<a href="../../use/runtime..heapBits*29394.bitp*b78c1.html" class="ident">bitp</a>  *<a href="../../pkg/builtin.html#name-uint8" class="ident">uint8</a>
	<a href="../../use/runtime..heapBits*29394.shift*ecd3f.html" class="ident">shift</a> <a href="../../pkg/builtin.html#name-uint32" class="ident">uint32</a>
	<a href="../../use/runtime..heapBits*29394.arena*572e3.html" class="ident">arena</a> <a href="../../pkg/builtin.html#name-uint32" class="ident">uint32</a> <span class="comment">// Index of heap arena containing bitp</span>
	<a href="../../use/runtime..heapBits*29394.last*3547c.html" class="ident">last</a>  *<a href="../../pkg/builtin.html#name-uint8" class="ident">uint8</a> <span class="comment">// Last byte arena's bitmap</span>
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Make the compiler check that heapBits.arena is large enough to hold</span><span class="comment"> the maximum arena frame number.</span></div>
<div class="code"><pre><code><span class="keyword">var</span> _ = <a href="#line-112" class="ident">heapBits</a>{<a href="#line-115" class="ident">arena</a>: (<span class="lit-number">1</span>&lt;&lt;<a href="malloc.go.html#line-210" class="ident">heapAddrBits</a>)/<a href="malloc.go.html#line-245" class="ident">heapArenaBytes</a> - <span class="lit-number">1</span>}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> markBits provides access to the mark bit for an object in the heap.</span><span class="comment"> bytep points to the byte holding the mark bit.</span><span class="comment"> mask is a byte with a single bit set that can be &amp;ed with *bytep</span><span class="comment"> to see if the bit has been set.</span><span class="comment"> *m.byte&amp;m.mask != 0 indicates the mark bit is set.</span><span class="comment"> index can be used along with span information to generate</span><span class="comment"> the address of the object in the heap.</span><span class="comment"> We maintain one set of mark bits for allocation and one for</span><span class="comment"> marking purposes.</span></div>
<div class="code"><pre><code><span class="keyword">type</span> <a href="../../pkg/runtime.html#name-markBits" class="ident">markBits</a> <span class="keyword">struct</span> {
	<a href="../../use/runtime..markBits*ac11f.bytep*528af.html" class="ident">bytep</a> *<a href="../../pkg/builtin.html#name-uint8" class="ident">uint8</a>
	<a href="../../use/runtime..markBits*ac11f.mask*48bf9.html" class="ident">mask</a>  <a href="../../pkg/builtin.html#name-uint8" class="ident">uint8</a>
	<a href="../../use/runtime..markBits*ac11f.index*1bc04.html" class="ident">index</a> <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment">go:nosplit</span></div>
<div class="code"><pre><code><span class="keyword">func</span> (<label for="r10" class="ident">s</label> *<a href="mheap.go.html#line-382" class="ident">mspan</a>) <label for="r11" class="ident"><a href="../../use/runtime..mspan*6f34b.allocBitsForIndex*d1dc2.html" class="ident">allocBitsForIndex</a></label>(<label for="r12" class="ident">allocBitIndex</label> <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>) <a href="#line-132" class="ident">markBits</a> {
	<label for="r13" class="ident">bytep</label>, <label for="r14" class="ident">mask</label> := <label for="r10" class="ident">s</label>.<a href="mheap.go.html#line-442" class="ident">allocBits</a>.<a href="mheap.go.html#line-1882" class="ident">bitp</a>(<label for="r12" class="ident">allocBitIndex</label>)
	<span class="keyword">return</span> <a href="#line-132" class="ident">markBits</a>{<label for="r13" class="ident">bytep</label>, <label for="r14" class="ident">mask</label>, <label for="r12" class="ident">allocBitIndex</label>}
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> refillAllocCache takes 8 bytes s.allocBits starting at whichByte</span><span class="comment"> and negates them so that ctz (count trailing zeros) instructions</span><span class="comment"> can be used. It then places these 8 bytes into the cached 64 bit</span><span class="comment"> s.allocCache.</span></div>
<div class="code"><pre><code><span class="keyword">func</span> (<label for="r15" class="ident">s</label> *<a href="mheap.go.html#line-382" class="ident">mspan</a>) <label for="r16" class="ident"><a href="../../use/runtime..mspan*6f34b.refillAllocCache*2d2a7.html" class="ident">refillAllocCache</a></label>(<label for="r17" class="ident">whichByte</label> <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>) {
	<label for="r18" class="ident">bytes</label> := (*[<span class="lit-number">8</span>]<a href="../../pkg/builtin.html#name-uint8" class="ident">uint8</a>)(<a href="../../pkg/unsafe.html" class="ident i2">unsafe</a>.<a href="../../pkg/unsafe.html#name-Pointer" class="ident">Pointer</a>(<label for="r15" class="ident">s</label>.<a href="mheap.go.html#line-442" class="ident">allocBits</a>.<a href="mheap.go.html#line-1876" class="ident">bytep</a>(<label for="r17" class="ident">whichByte</label>)))
	<label for="r19" class="ident">aCache</label> := <a href="../../pkg/builtin.html#name-uint64" class="ident">uint64</a>(<span class="lit-number">0</span>)
	<label for="r19" class="ident">aCache</label> |= <a href="../../pkg/builtin.html#name-uint64" class="ident">uint64</a>(<label for="r18" class="ident">bytes</label>[<span class="lit-number">0</span>])
	<label for="r19" class="ident">aCache</label> |= <a href="../../pkg/builtin.html#name-uint64" class="ident">uint64</a>(<label for="r18" class="ident">bytes</label>[<span class="lit-number">1</span>]) &lt;&lt; (<span class="lit-number">1</span> * <span class="lit-number">8</span>)
	<label for="r19" class="ident">aCache</label> |= <a href="../../pkg/builtin.html#name-uint64" class="ident">uint64</a>(<label for="r18" class="ident">bytes</label>[<span class="lit-number">2</span>]) &lt;&lt; (<span class="lit-number">2</span> * <span class="lit-number">8</span>)
	<label for="r19" class="ident">aCache</label> |= <a href="../../pkg/builtin.html#name-uint64" class="ident">uint64</a>(<label for="r18" class="ident">bytes</label>[<span class="lit-number">3</span>]) &lt;&lt; (<span class="lit-number">3</span> * <span class="lit-number">8</span>)
	<label for="r19" class="ident">aCache</label> |= <a href="../../pkg/builtin.html#name-uint64" class="ident">uint64</a>(<label for="r18" class="ident">bytes</label>[<span class="lit-number">4</span>]) &lt;&lt; (<span class="lit-number">4</span> * <span class="lit-number">8</span>)
	<label for="r19" class="ident">aCache</label> |= <a href="../../pkg/builtin.html#name-uint64" class="ident">uint64</a>(<label for="r18" class="ident">bytes</label>[<span class="lit-number">5</span>]) &lt;&lt; (<span class="lit-number">5</span> * <span class="lit-number">8</span>)
	<label for="r19" class="ident">aCache</label> |= <a href="../../pkg/builtin.html#name-uint64" class="ident">uint64</a>(<label for="r18" class="ident">bytes</label>[<span class="lit-number">6</span>]) &lt;&lt; (<span class="lit-number">6</span> * <span class="lit-number">8</span>)
	<label for="r19" class="ident">aCache</label> |= <a href="../../pkg/builtin.html#name-uint64" class="ident">uint64</a>(<label for="r18" class="ident">bytes</label>[<span class="lit-number">7</span>]) &lt;&lt; (<span class="lit-number">7</span> * <span class="lit-number">8</span>)
	<label for="r15" class="ident">s</label>.<a href="mheap.go.html#line-418" class="ident">allocCache</a> = ^<label for="r19" class="ident">aCache</label>
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> nextFreeIndex returns the index of the next free object in s at</span><span class="comment"> or after s.freeindex.</span><span class="comment"> There are hardware instructions that can be used to make this</span><span class="comment"> faster if profiling warrants it.</span></div>
<div class="code"><pre><code><span class="keyword">func</span> (<label for="r20" class="ident">s</label> *<a href="mheap.go.html#line-382" class="ident">mspan</a>) <label for="r21" class="ident"><a href="../../use/runtime..mspan*6f34b.nextFreeIndex*45b75.html" class="ident">nextFreeIndex</a></label>() <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a> {
	<label for="r22" class="ident">sfreeindex</label> := <label for="r20" class="ident">s</label>.<a href="mheap.go.html#line-407" class="ident">freeindex</a>
	<label for="r23" class="ident">snelems</label> := <label for="r20" class="ident">s</label>.<a href="mheap.go.html#line-410" class="ident">nelems</a>
	<span class="keyword">if</span> <label for="r22" class="ident">sfreeindex</label> == <label for="r23" class="ident">snelems</label> {
		<span class="keyword">return</span> <label for="r22" class="ident">sfreeindex</label>
	}
	<span class="keyword">if</span> <label for="r22" class="ident">sfreeindex</label> &gt; <label for="r23" class="ident">snelems</label> {
		<a href="panic.go.html#line-1107" class="ident">throw</a>(<span class="lit-string">"s.freeindex &gt; s.nelems"</span>)
	}

	<label for="r24" class="ident">aCache</label> := <label for="r20" class="ident">s</label>.<a href="mheap.go.html#line-418" class="ident">allocCache</a>

	<label for="r25" class="ident">bitIndex</label> := <a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/intrinsics.go.html#line-38" class="ident">Ctz64</a>(<label for="r24" class="ident">aCache</label>)
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Move index to start of next cached bits.</span></div>
<div class="code"><pre><code>		<label for="r22" class="ident">sfreeindex</label> = (<label for="r22" class="ident">sfreeindex</label> + <span class="lit-number">64</span>) &amp;^ (<span class="lit-number">64</span> - <span class="lit-number">1</span>)
		<span class="keyword">if</span> <label for="r22" class="ident">sfreeindex</label> &gt;= <label for="r23" class="ident">snelems</label> {
			<label for="r20" class="ident">s</label>.<a href="mheap.go.html#line-407" class="ident">freeindex</a> = <label for="r23" class="ident">snelems</label>
			<span class="keyword">return</span> <label for="r23" class="ident">snelems</label>
		}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Refill s.allocCache with the next 64 alloc bits.</span></div>
<div class="code"><pre><code>		<label for="r20" class="ident">s</label>.<a href="#line-148" class="ident">refillAllocCache</a>(<label for="r26" class="ident">whichByte</label>)
		<label for="r24" class="ident">aCache</label> = <label for="r20" class="ident">s</label>.<a href="mheap.go.html#line-418" class="ident">allocCache</a>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> nothing available in cached bits</span><span class="comment">		 grab the next 8 bytes and try again.</span></div>
<div class="code"><pre><code>	}
	<label for="r27" class="ident">result</label> := <label for="r22" class="ident">sfreeindex</label> + <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<label for="r25" class="ident">bitIndex</label>)
	<span class="keyword">if</span> <label for="r27" class="ident">result</label> &gt;= <label for="r23" class="ident">snelems</label> {
		<label for="r20" class="ident">s</label>.<a href="mheap.go.html#line-407" class="ident">freeindex</a> = <label for="r23" class="ident">snelems</label>
		<span class="keyword">return</span> <label for="r23" class="ident">snelems</label>
	}

	<label for="r20" class="ident">s</label>.<a href="mheap.go.html#line-418" class="ident">allocCache</a> &gt;&gt;= <a href="../../pkg/builtin.html#name-uint" class="ident">uint</a>(<label for="r25" class="ident">bitIndex</label> + <span class="lit-number">1</span>)
	<label for="r22" class="ident">sfreeindex</label> = <label for="r27" class="ident">result</label> + <span class="lit-number">1</span>

</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> We just incremented s.freeindex so it isn't 0.</span><span class="comment">		 As each 1 in s.allocCache was encountered and used for allocation</span><span class="comment">		 it was shifted away. At this point s.allocCache contains all 0s.</span><span class="comment">		 Refill s.allocCache so that it corresponds</span><span class="comment">		 to the bits at s.allocBits starting at s.freeindex.</span></div>
<div class="code"><pre><code>		<label for="r28" class="ident">whichByte</label> := <label for="r22" class="ident">sfreeindex</label> / <span class="lit-number">8</span>
		<label for="r20" class="ident">s</label>.<a href="#line-148" class="ident">refillAllocCache</a>(<label for="r28" class="ident">whichByte</label>)
	}
	<label for="r20" class="ident">s</label>.<a href="mheap.go.html#line-407" class="ident">freeindex</a> = <label for="r22" class="ident">sfreeindex</label>
	<span class="keyword">return</span> <label for="r27" class="ident">result</label>
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> isFree reports whether the index'th object in s is unallocated.</span><span class="comment"></span><span class="comment"> The caller must ensure s.state is mSpanInUse, and there must have</span><span class="comment"> been no preemption points since ensuring this (which could allow a</span><span class="comment"> GC transition, which would allow the state to change).</span></div>
<div class="code"><pre><code><span class="keyword">func</span> (<label for="r29" class="ident">s</label> *<a href="mheap.go.html#line-382" class="ident">mspan</a>) <label for="r30" class="ident"><a href="../../use/runtime..mspan*6f34b.isFree*11a7a.html" class="ident">isFree</a></label>(<label for="r31" class="ident">index</label> <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>) <a href="../../pkg/builtin.html#name-bool" class="ident">bool</a> {
	<span class="keyword">if</span> <label for="r31" class="ident">index</label> &lt; <label for="r29" class="ident">s</label>.<a href="mheap.go.html#line-407" class="ident">freeindex</a> {
		<span class="keyword">return</span> <a href="../../pkg/builtin.html#name-false" class="ident">false</a>
	}
	<label for="r32" class="ident">bytep</label>, <label for="r33" class="ident">mask</label> := <label for="r29" class="ident">s</label>.<a href="mheap.go.html#line-442" class="ident">allocBits</a>.<a href="mheap.go.html#line-1882" class="ident">bitp</a>(<label for="r31" class="ident">index</label>)
	<span class="keyword">return</span> *<label for="r32" class="ident">bytep</label>&amp;<label for="r33" class="ident">mask</label> == <span class="lit-number">0</span>
}

<span class="keyword">func</span> (<label for="r34" class="ident">s</label> *<a href="mheap.go.html#line-382" class="ident">mspan</a>) <label for="r35" class="ident"><a href="../../use/runtime..mspan*6f34b.objIndex*dfb6f.html" class="ident">objIndex</a></label>(<label for="r36" class="ident">p</label> <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>) <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a> {
	<label for="r37" class="ident">byteOffset</label> := <label for="r36" class="ident">p</label> - <label for="r34" class="ident">s</label>.<a href="mheap.go.html#line-468" class="ident">base</a>()
	<span class="keyword">if</span> <label for="r37" class="ident">byteOffset</label> == <span class="lit-number">0</span> {
		<span class="keyword">return</span> <span class="lit-number">0</span>
	}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> s.baseMask is non-0, elemsize is a power of two, so shift by s.divShift</span></div>
<div class="code"><pre><code>		<span class="keyword">return</span> <label for="r37" class="ident">byteOffset</label> &gt;&gt; <label for="r34" class="ident">s</label>.<a href="mheap.go.html#line-460" class="ident">divShift</a>
	}
	<span class="keyword">return</span> <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(((<a href="../../pkg/builtin.html#name-uint64" class="ident">uint64</a>(<label for="r37" class="ident">byteOffset</label>) &gt;&gt; <label for="r34" class="ident">s</label>.<a href="mheap.go.html#line-460" class="ident">divShift</a>) * <a href="../../pkg/builtin.html#name-uint64" class="ident">uint64</a>(<label for="r34" class="ident">s</label>.<a href="mheap.go.html#line-454" class="ident">divMul</a>)) &gt;&gt; <label for="r34" class="ident">s</label>.<a href="mheap.go.html#line-461" class="ident">divShift2</a>)
}

<span class="keyword">func</span> <label for="r38" class="ident"><a href="../../pkg/runtime.html#name-markBitsForAddr" class="ident">markBitsForAddr</a></label>(<label for="r39" class="ident">p</label> <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>) <a href="#line-132" class="ident">markBits</a> {
	<label for="r40" class="ident">s</label> := <a href="mheap.go.html#line-631" class="ident">spanOf</a>(<label for="r39" class="ident">p</label>)
	<label for="r41" class="ident">objIndex</label> := <label for="r40" class="ident">s</label>.<a href="#line-229" class="ident">objIndex</a>(<label for="r39" class="ident">p</label>)
	<span class="keyword">return</span> <label for="r40" class="ident">s</label>.<a href="#line-247" class="ident">markBitsForIndex</a>(<label for="r41" class="ident">objIndex</label>)
}

<span class="keyword">func</span> (<label for="r42" class="ident">s</label> *<a href="mheap.go.html#line-382" class="ident">mspan</a>) <label for="r43" class="ident"><a href="../../use/runtime..mspan*6f34b.markBitsForIndex*c5f05.html" class="ident">markBitsForIndex</a></label>(<label for="r44" class="ident">objIndex</label> <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>) <a href="#line-132" class="ident">markBits</a> {
	<label for="r45" class="ident">bytep</label>, <label for="r46" class="ident">mask</label> := <label for="r42" class="ident">s</label>.<a href="mheap.go.html#line-443" class="ident">gcmarkBits</a>.<a href="mheap.go.html#line-1882" class="ident">bitp</a>(<label for="r44" class="ident">objIndex</label>)
	<span class="keyword">return</span> <a href="#line-132" class="ident">markBits</a>{<label for="r45" class="ident">bytep</label>, <label for="r46" class="ident">mask</label>, <label for="r44" class="ident">objIndex</label>}
}

<span class="keyword">func</span> (<label for="r47" class="ident">s</label> *<a href="mheap.go.html#line-382" class="ident">mspan</a>) <label for="r48" class="ident"><a href="../../use/runtime..mspan*6f34b.markBitsForBase*a070e.html" class="ident">markBitsForBase</a></label>() <a href="#line-132" class="ident">markBits</a> {
	<span class="keyword">return</span> <a href="#line-132" class="ident">markBits</a>{(*<a href="../../pkg/builtin.html#name-uint8" class="ident">uint8</a>)(<label for="r47" class="ident">s</label>.<a href="mheap.go.html#line-443" class="ident">gcmarkBits</a>), <a href="../../pkg/builtin.html#name-uint8" class="ident">uint8</a>(<span class="lit-number">1</span>), <span class="lit-number">0</span>}
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> isMarked reports whether mark bit m is set.</span></div>
<div class="code"><pre><code><span class="keyword">func</span> (<label for="r49" class="ident">m</label> <a href="#line-132" class="ident">markBits</a>) <label for="r50" class="ident"><a href="../../use/runtime..markBits*ac11f.isMarked*787b8.html" class="ident">isMarked</a></label>() <a href="../../pkg/builtin.html#name-bool" class="ident">bool</a> {
	<span class="keyword">return</span> *<label for="r49" class="ident">m</label>.<a href="#line-133" class="ident">bytep</a>&amp;<label for="r49" class="ident">m</label>.<a href="#line-134" class="ident">mask</a> != <span class="lit-number">0</span>
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> setMarked sets the marked bit in the markbits, atomically.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Might be racing with other updates, so use atomic update always.</span><span class="comment">	 We used to be clever here and use a non-atomic update in certain</span><span class="comment">	 cases, but it's not worth the risk.</span></div>
<div class="code"><pre><code>	<a href="../../pkg/runtime/internal/atomic.html" class="ident i0">atomic</a>.<a href="internal/atomic/atomic_amd64.go.html#line-78" class="ident">Or8</a>(<label for="r51" class="ident">m</label>.<a href="#line-133" class="ident">bytep</a>, <label for="r51" class="ident">m</label>.<a href="#line-134" class="ident">mask</a>)
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> setMarkedNonAtomic sets the marked bit in the markbits, non-atomically.</span></div>
<div class="code"><pre><code><span class="keyword">func</span> (<label for="r53" class="ident">m</label> <a href="#line-132" class="ident">markBits</a>) <label for="r54" class="ident"><a href="../../use/runtime..markBits*ac11f.setMarkedNonAtomic*583c3.html" class="ident">setMarkedNonAtomic</a></label>() {
	*<label for="r53" class="ident">m</label>.<a href="#line-133" class="ident">bytep</a> |= <label for="r53" class="ident">m</label>.<a href="#line-134" class="ident">mask</a>
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> clearMarked clears the marked bit in the markbits, atomically.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Might be racing with other updates, so use atomic update always.</span><span class="comment">	 We used to be clever here and use a non-atomic update in certain</span><span class="comment">	 cases, but it's not worth the risk.</span></div>
<div class="code"><pre><code>	<a href="../../pkg/runtime/internal/atomic.html" class="ident i0">atomic</a>.<a href="internal/atomic/atomic_amd64.go.html#line-75" class="ident">And8</a>(<label for="r55" class="ident">m</label>.<a href="#line-133" class="ident">bytep</a>, ^<label for="r55" class="ident">m</label>.<a href="#line-134" class="ident">mask</a>)
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> markBitsForSpan returns the markBits for the span base address base.</span></div>
<div class="code"><pre><code><span class="keyword">func</span> <label for="r57" class="ident"><a href="../../pkg/runtime.html#name-markBitsForSpan" class="ident">markBitsForSpan</a></label>(<label for="r58" class="ident">base</label> <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>) (<label for="r59" class="ident">mbits</label> <a href="#line-132" class="ident">markBits</a>) {
	<label for="r59" class="ident">mbits</label> = <a href="#line-241" class="ident">markBitsForAddr</a>(<label for="r58" class="ident">base</label>)
	<span class="keyword">if</span> <label for="r59" class="ident">mbits</label>.<a href="#line-134" class="ident">mask</a> != <span class="lit-number">1</span> {
		<a href="panic.go.html#line-1107" class="ident">throw</a>(<span class="lit-string">"markBitsForSpan: unaligned start"</span>)
	}
	<span class="keyword">return</span> <label for="r59" class="ident">mbits</label>
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> advance advances the markBits to the next object in the span.</span></div>
<div class="code"><pre><code><span class="keyword">func</span> (<label for="r60" class="ident">m</label> *<a href="#line-132" class="ident">markBits</a>) <label for="r61" class="ident"><a href="../../use/runtime..markBits*ac11f.advance*e40df.html" class="ident">advance</a></label>() {
	<span class="keyword">if</span> <label for="r60" class="ident">m</label>.<a href="#line-134" class="ident">mask</a> == <span class="lit-number">1</span>&lt;&lt;<span class="lit-number">7</span> {
		<label for="r60" class="ident">m</label>.<a href="#line-133" class="ident">bytep</a> = (*<a href="../../pkg/builtin.html#name-uint8" class="ident">uint8</a>)(<a href="../../pkg/unsafe.html" class="ident i2">unsafe</a>.<a href="../../pkg/unsafe.html#name-Pointer" class="ident">Pointer</a>(<a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<a href="../../pkg/unsafe.html" class="ident i2">unsafe</a>.<a href="../../pkg/unsafe.html#name-Pointer" class="ident">Pointer</a>(<label for="r60" class="ident">m</label>.<a href="#line-133" class="ident">bytep</a>)) + <span class="lit-number">1</span>))
		<label for="r60" class="ident">m</label>.<a href="#line-134" class="ident">mask</a> = <span class="lit-number">1</span>
	} <span class="keyword">else</span> {
		<label for="r60" class="ident">m</label>.<a href="#line-134" class="ident">mask</a> = <label for="r60" class="ident">m</label>.<a href="#line-134" class="ident">mask</a> &lt;&lt; <span class="lit-number">1</span>
	}
	<label for="r60" class="ident">m</label>.<a href="#line-135" class="ident">index</a>++
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> heapBitsForAddr returns the heapBits for the address addr.</span><span class="comment"> The caller must ensure addr is in an allocated span.</span><span class="comment"> In particular, be careful not to point past the end of an object.</span><span class="comment"></span><span class="comment"> nosplit because it is used during write barriers and must not be preempted.</span><span class="comment">go:nosplit</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> 2 bits per word, 4 pairs per byte, and a mask is hard coded.</span></div>
<div class="code"><pre><code>	<label for="r65" class="ident">arena</label> := <a href="mheap.go.html#line-563" class="ident">arenaIndex</a>(<label for="r63" class="ident">addr</label>)
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> The compiler uses a load for nil checking ha, but in this</span><span class="comment">	 case we'll almost never hit that cache line again, so it</span><span class="comment">	 makes more sense to do a value check.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> addr is not in the heap. Return nil heapBits, which</span><span class="comment">		 we expect to crash in the caller.</span></div>
<div class="code"><pre><code>		<span class="keyword">return</span>
	}
	<label for="r64" class="ident">h</label>.<a href="#line-113" class="ident">bitp</a> = &amp;<label for="r66" class="ident">ha</label>.<a href="mheap.go.html#line-231" class="ident">bitmap</a>[(<label for="r63" class="ident">addr</label>/(<a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a>*<span class="lit-number">4</span>))%<a href="malloc.go.html#line-253" class="ident">heapArenaBitmapBytes</a>]
	<label for="r64" class="ident">h</label>.<a href="#line-114" class="ident">shift</a> = <a href="../../pkg/builtin.html#name-uint32" class="ident">uint32</a>((<label for="r63" class="ident">addr</label> / <a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a>) &amp; <span class="lit-number">3</span>)
	<label for="r64" class="ident">h</label>.<a href="#line-115" class="ident">arena</a> = <a href="../../pkg/builtin.html#name-uint32" class="ident">uint32</a>(<label for="r65" class="ident">arena</label>)
	<label for="r64" class="ident">h</label>.<a href="#line-116" class="ident">last</a> = &amp;<label for="r66" class="ident">ha</label>.<a href="mheap.go.html#line-231" class="ident">bitmap</a>[<a href="../../pkg/builtin.html#name-len" class="ident">len</a>(<label for="r66" class="ident">ha</label>.<a href="mheap.go.html#line-231" class="ident">bitmap</a>)-<span class="lit-number">1</span>]
	<span class="keyword">return</span>
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> badPointer throws bad pointer in heap panic.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Typically this indicates an incorrect use</span><span class="comment">	 of unsafe or cgo to store a bad pointer in</span><span class="comment">	 the Go heap. It may also indicate a runtime</span><span class="comment">	 bug.</span><span class="comment">	</span><span class="comment">	 TODO(austin): We could be more aggressive</span><span class="comment">	 and detect pointers to unallocated objects</span><span class="comment">	 in allocated spans.</span></div>
<div class="code"><pre><code>	<a href="print.go.html#line-66" class="ident">printlock</a>()
	<a href="../../pkg/builtin.html#name-print" class="ident">print</a>(<span class="lit-string">"runtime: pointer "</span>, <a href="print.go.html#line-15" class="ident">hex</a>(<label for="r69" class="ident">p</label>))
	<label for="r72" class="ident">state</label> := <label for="r68" class="ident">s</label>.<a href="mheap.go.html#line-458" class="ident">state</a>.<a href="mheap.go.html#line-369" class="ident">get</a>()
	<span class="keyword">if</span> <label for="r72" class="ident">state</label> != <a href="mheap.go.html#line-345" class="ident">mSpanInUse</a> {
		<a href="../../pkg/builtin.html#name-print" class="ident">print</a>(<span class="lit-string">" to unallocated span"</span>)
	} <span class="keyword">else</span> {
		<a href="../../pkg/builtin.html#name-print" class="ident">print</a>(<span class="lit-string">" to unused region of span"</span>)
	}
	<a href="../../pkg/builtin.html#name-print" class="ident">print</a>(<span class="lit-string">" span.base()="</span>, <a href="print.go.html#line-15" class="ident">hex</a>(<label for="r68" class="ident">s</label>.<a href="mheap.go.html#line-468" class="ident">base</a>()), <span class="lit-string">" span.limit="</span>, <a href="print.go.html#line-15" class="ident">hex</a>(<label for="r68" class="ident">s</label>.<a href="mheap.go.html#line-463" class="ident">limit</a>), <span class="lit-string">" span.state="</span>, <label for="r72" class="ident">state</label>, <span class="lit-string">"\n"</span>)
	<span class="keyword">if</span> <label for="r70" class="ident">refBase</label> != <span class="lit-number">0</span> {
		<a href="../../pkg/builtin.html#name-print" class="ident">print</a>(<span class="lit-string">"runtime: found in object at *("</span>, <a href="print.go.html#line-15" class="ident">hex</a>(<label for="r70" class="ident">refBase</label>), <span class="lit-string">"+"</span>, <a href="print.go.html#line-15" class="ident">hex</a>(<label for="r71" class="ident">refOff</label>), <span class="lit-string">")\n"</span>)
		<a href="mgcmark.go.html#line-1462" class="ident">gcDumpObject</a>(<span class="lit-string">"object"</span>, <label for="r70" class="ident">refBase</label>, <label for="r71" class="ident">refOff</label>)
	}
	<a href="stubs.go.html#line-18" class="ident">getg</a>().<a href="runtime2.go.html#line-418" class="ident">m</a>.<a href="runtime2.go.html#line-518" class="ident">traceback</a> = <span class="lit-number">2</span>
	<a href="panic.go.html#line-1107" class="ident">throw</a>(<span class="lit-string">"found bad pointer in Go heap (incorrect use of unsafe or cgo?)"</span>)
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> findObject returns the base address for the heap object containing</span><span class="comment"> the address p, the object's span, and the index of the object in s.</span><span class="comment"> If p does not point into a heap object, it returns base == 0.</span><span class="comment"></span><span class="comment"> If p points is an invalid heap pointer and debug.invalidptr != 0,</span><span class="comment"> findObject panics.</span><span class="comment"></span><span class="comment"> refBase and refOff optionally give the base address of the object</span><span class="comment"> in which the pointer p was found and the byte offset at which it</span><span class="comment"> was found. These are used for error reporting.</span><span class="comment"></span><span class="comment"> It is nosplit so it is safe for p to be a pointer to the current goroutine's stack.</span><span class="comment"> Since p is a uintptr, it would not be adjusted if the stack were to move.</span><span class="comment">go:nosplit</span></div>
<div class="code"><pre><code><span class="keyword">func</span> <label for="r73" class="ident"><a href="../../pkg/runtime.html#name-findObject" class="ident">findObject</a></label>(<label for="r74" class="ident">p</label>, <label for="r75" class="ident">refBase</label>, <label for="r76" class="ident">refOff</label> <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>) (<label for="r77" class="ident">base</label> <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>, <label for="r78" class="ident">s</label> *<a href="mheap.go.html#line-382" class="ident">mspan</a>, <label for="r79" class="ident">objIndex</label> <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>) {
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> If s is nil, the virtual address has never been part of the heap.</span><span class="comment">	 This pointer may be to some mmap'd region, so we allow it.</span></div>
<div class="code"><pre><code>	<span class="keyword">if</span> <label for="r78" class="ident">s</label> == <a href="../../pkg/builtin.html#name-nil" class="ident">nil</a> {
		<span class="keyword">return</span>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> If p is a bad pointer, it may not be in s's bounds.</span><span class="comment">	</span><span class="comment">	 Check s.state to synchronize with span initialization</span><span class="comment">	 before checking other fields. See also spanOfHeap.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Pointers into stacks are also ok, the runtime manages these explicitly.</span></div>
<div class="code"><pre><code>		<span class="keyword">if</span> <label for="r80" class="ident">state</label> == <a href="mheap.go.html#line-346" class="ident">mSpanManual</a> {
			<span class="keyword">return</span>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> The following ensures that we are rigorous about what data</span><span class="comment">		 structures hold valid pointers.</span></div>
<div class="code"><pre><code>		<span class="keyword">if</span> <a href="runtime1.go.html#line-302" class="ident">debug</a>.<a href="runtime1.go.html#line-311" class="ident">invalidptr</a> != <span class="lit-number">0</span> {
			<a href="#line-328" class="ident">badPointer</a>(<label for="r78" class="ident">s</label>, <label for="r74" class="ident">p</label>, <label for="r75" class="ident">refBase</label>, <label for="r76" class="ident">refOff</label>)
		}
		<span class="keyword">return</span>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> If this span holds object of a power of 2 size, just mask off the bits to</span><span class="comment">	 the interior of the object. Otherwise use the size to get the base.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> optimize for power of 2 sized objects.</span></div>
<div class="code"><pre><code>		<label for="r77" class="ident">base</label> = <label for="r78" class="ident">s</label>.<a href="mheap.go.html#line-468" class="ident">base</a>()
		<label for="r77" class="ident">base</label> = <label for="r77" class="ident">base</label> + (<label for="r74" class="ident">p</label>-<label for="r77" class="ident">base</label>)&amp;<a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<label for="r78" class="ident">s</label>.<a href="mheap.go.html#line-455" class="ident">baseMask</a>)
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> base = p &amp; s.baseMask is faster for small spans,</span><span class="comment">		 but doesn't work for large spans.</span><span class="comment">		 Overall, it's faster to use the more general computation above.</span></div>
<div class="code"><pre><code>	} <span class="keyword">else</span> {
		<label for="r77" class="ident">base</label> = <label for="r78" class="ident">s</label>.<a href="mheap.go.html#line-468" class="ident">base</a>()
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> n := (p - base) / s.elemsize, using division by multiplication</span></div>
<div class="code"><pre><code>			<label for="r79" class="ident">objIndex</label> = <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<label for="r74" class="ident">p</label>-<label for="r77" class="ident">base</label>) &gt;&gt; <label for="r78" class="ident">s</label>.<a href="mheap.go.html#line-460" class="ident">divShift</a> * <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<label for="r78" class="ident">s</label>.<a href="mheap.go.html#line-454" class="ident">divMul</a>) &gt;&gt; <label for="r78" class="ident">s</label>.<a href="mheap.go.html#line-461" class="ident">divShift2</a>
			<label for="r77" class="ident">base</label> += <label for="r79" class="ident">objIndex</label> * <label for="r78" class="ident">s</label>.<a href="mheap.go.html#line-462" class="ident">elemsize</a>
		}
	}
	<span class="keyword">return</span>
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> next returns the heapBits describing the next pointer-sized word in memory.</span><span class="comment"> That is, if h describes address p, h.next() describes p+ptrSize.</span><span class="comment"> Note that next does not modify h. The caller must record the result.</span><span class="comment"></span><span class="comment"> nosplit because it is used during write barriers and must not be preempted.</span><span class="comment">go:nosplit</span></div>
<div class="code"><pre><code><span class="keyword">func</span> (<label for="r81" class="ident">h</label> <a href="#line-112" class="ident">heapBits</a>) <label for="r82" class="ident"><a href="../../use/runtime..heapBits*29394.next*c6c1c.html" class="ident">next</a></label>() <a href="#line-112" class="ident">heapBits</a> {
	<span class="keyword">if</span> <label for="r81" class="ident">h</label>.<a href="#line-114" class="ident">shift</a> &lt; <span class="lit-number">3</span>*<a href="#line-58" class="ident">heapBitsShift</a> {
		<label for="r81" class="ident">h</label>.<a href="#line-114" class="ident">shift</a> += <a href="#line-58" class="ident">heapBitsShift</a>
	} <span class="keyword">else</span> <span class="keyword">if</span> <label for="r81" class="ident">h</label>.<a href="#line-113" class="ident">bitp</a> != <label for="r81" class="ident">h</label>.<a href="#line-116" class="ident">last</a> {
		<label for="r81" class="ident">h</label>.<a href="#line-113" class="ident">bitp</a>, <label for="r81" class="ident">h</label>.<a href="#line-114" class="ident">shift</a> = <a href="#line-89" class="ident">add1</a>(<label for="r81" class="ident">h</label>.<a href="#line-113" class="ident">bitp</a>), <span class="lit-number">0</span>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Move to the next arena.</span></div>
<div class="code"><pre><code>		<span class="keyword">return</span> <label for="r81" class="ident">h</label>.<a href="#line-439" class="ident">nextArena</a>()
	}
	<span class="keyword">return</span> <label for="r81" class="ident">h</label>
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> nextArena advances h to the beginning of the next heap arena.</span><span class="comment"></span><span class="comment"> This is a slow-path helper to next. gc's inliner knows that</span><span class="comment"> heapBits.next can be inlined even though it calls this. This is</span><span class="comment"> marked noinline so it doesn't get inlined into next and cause next</span><span class="comment"> to be too big to inline.</span><span class="comment"></span><span class="comment">go:nosplit</span><span class="comment">go:noinline</span></div>
<div class="code"><pre><code><span class="keyword">func</span> (<label for="r83" class="ident">h</label> <a href="#line-112" class="ident">heapBits</a>) <label for="r84" class="ident"><a href="../../use/runtime..heapBits*29394.nextArena*9b0ad.html" class="ident">nextArena</a></label>() <a href="#line-112" class="ident">heapBits</a> {
	<label for="r83" class="ident">h</label>.<a href="#line-115" class="ident">arena</a>++
	<label for="r85" class="ident">ai</label> := <a href="mheap.go.html#line-573" class="ident">arenaIdx</a>(<label for="r83" class="ident">h</label>.<a href="#line-115" class="ident">arena</a>)
	<label for="r86" class="ident">l2</label> := <a href="mheap.go.html#line-221" class="ident">mheap_</a>.<a href="mheap.go.html#line-156" class="ident">arenas</a>[<label for="r85" class="ident">ai</label>.<a href="mheap.go.html#line-575" class="ident">l1</a>()]
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> We just passed the end of the object, which</span><span class="comment">		 was also the end of the heap. Poison h. It</span><span class="comment">		 should never be dereferenced at this point.</span></div>
<div class="code"><pre><code>		<span class="keyword">return</span> <a href="#line-112" class="ident">heapBits</a>{}
	}
	<label for="r87" class="ident">ha</label> := <label for="r86" class="ident">l2</label>[<label for="r85" class="ident">ai</label>.<a href="mheap.go.html#line-585" class="ident">l2</a>()]
	<span class="keyword">if</span> <label for="r87" class="ident">ha</label> == <a href="../../pkg/builtin.html#name-nil" class="ident">nil</a> {
		<span class="keyword">return</span> <a href="#line-112" class="ident">heapBits</a>{}
	}
	<label for="r83" class="ident">h</label>.<a href="#line-113" class="ident">bitp</a>, <label for="r83" class="ident">h</label>.<a href="#line-114" class="ident">shift</a> = &amp;<label for="r87" class="ident">ha</label>.<a href="mheap.go.html#line-231" class="ident">bitmap</a>[<span class="lit-number">0</span>], <span class="lit-number">0</span>
	<label for="r83" class="ident">h</label>.<a href="#line-116" class="ident">last</a> = &amp;<label for="r87" class="ident">ha</label>.<a href="mheap.go.html#line-231" class="ident">bitmap</a>[<a href="../../pkg/builtin.html#name-len" class="ident">len</a>(<label for="r87" class="ident">ha</label>.<a href="mheap.go.html#line-231" class="ident">bitmap</a>)-<span class="lit-number">1</span>]
	<span class="keyword">return</span> <label for="r83" class="ident">h</label>
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> forward returns the heapBits describing n pointer-sized words ahead of h in memory.</span><span class="comment"> That is, if h describes address p, h.forward(n) describes p+n*ptrSize.</span><span class="comment"> h.forward(1) is equivalent to h.next(), just slower.</span><span class="comment"> Note that forward does not modify h. The caller must record the result.</span><span class="comment"> bits returns the heap bits for the current word.</span><span class="comment">go:nosplit</span></div>
<div class="code"><pre><code><span class="keyword">func</span> (<label for="r88" class="ident">h</label> <a href="#line-112" class="ident">heapBits</a>) <label for="r89" class="ident"><a href="../../use/runtime..heapBits*29394.forward*9dc08.html" class="ident">forward</a></label>(<label for="r90" class="ident">n</label> <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>) <a href="#line-112" class="ident">heapBits</a> {
	<label for="r90" class="ident">n</label> += <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<label for="r88" class="ident">h</label>.<a href="#line-114" class="ident">shift</a>) / <a href="#line-58" class="ident">heapBitsShift</a>
	<label for="r91" class="ident">nbitp</label> := <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<a href="../../pkg/unsafe.html" class="ident i2">unsafe</a>.<a href="../../pkg/unsafe.html#name-Pointer" class="ident">Pointer</a>(<label for="r88" class="ident">h</label>.<a href="#line-113" class="ident">bitp</a>)) + <label for="r90" class="ident">n</label>/<span class="lit-number">4</span>
	<label for="r88" class="ident">h</label>.<a href="#line-114" class="ident">shift</a> = <a href="../../pkg/builtin.html#name-uint32" class="ident">uint32</a>(<label for="r90" class="ident">n</label>%<span class="lit-number">4</span>) * <a href="#line-58" class="ident">heapBitsShift</a>
	<span class="keyword">if</span> <label for="r91" class="ident">nbitp</label> &lt;= <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<a href="../../pkg/unsafe.html" class="ident i2">unsafe</a>.<a href="../../pkg/unsafe.html#name-Pointer" class="ident">Pointer</a>(<label for="r88" class="ident">h</label>.<a href="#line-116" class="ident">last</a>)) {
		<label for="r88" class="ident">h</label>.<a href="#line-113" class="ident">bitp</a> = (*<a href="../../pkg/builtin.html#name-uint8" class="ident">uint8</a>)(<a href="../../pkg/unsafe.html" class="ident i2">unsafe</a>.<a href="../../pkg/unsafe.html#name-Pointer" class="ident">Pointer</a>(<label for="r91" class="ident">nbitp</label>))
		<span class="keyword">return</span> <label for="r88" class="ident">h</label>
	}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> We're in a new heap arena.</span></div>
<div class="code"><pre><code>	<label for="r92" class="ident">past</label> := <label for="r91" class="ident">nbitp</label> - (<a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<a href="../../pkg/unsafe.html" class="ident i2">unsafe</a>.<a href="../../pkg/unsafe.html#name-Pointer" class="ident">Pointer</a>(<label for="r88" class="ident">h</label>.<a href="#line-116" class="ident">last</a>)) + <span class="lit-number">1</span>)
	<label for="r88" class="ident">h</label>.<a href="#line-115" class="ident">arena</a> += <span class="lit-number">1</span> + <a href="../../pkg/builtin.html#name-uint32" class="ident">uint32</a>(<label for="r92" class="ident">past</label>/<a href="malloc.go.html#line-253" class="ident">heapArenaBitmapBytes</a>)
	<label for="r93" class="ident">ai</label> := <a href="mheap.go.html#line-573" class="ident">arenaIdx</a>(<label for="r88" class="ident">h</label>.<a href="#line-115" class="ident">arena</a>)
	<span class="keyword">if</span> <label for="r94" class="ident">l2</label> := <a href="mheap.go.html#line-221" class="ident">mheap_</a>.<a href="mheap.go.html#line-156" class="ident">arenas</a>[<label for="r93" class="ident">ai</label>.<a href="mheap.go.html#line-575" class="ident">l1</a>()]; <label for="r94" class="ident">l2</label> != <a href="../../pkg/builtin.html#name-nil" class="ident">nil</a> &amp;&amp; <label for="r94" class="ident">l2</label>[<label for="r93" class="ident">ai</label>.<a href="mheap.go.html#line-585" class="ident">l2</a>()] != <a href="../../pkg/builtin.html#name-nil" class="ident">nil</a> {
		<label for="r95" class="ident">a</label> := <label for="r94" class="ident">l2</label>[<label for="r93" class="ident">ai</label>.<a href="mheap.go.html#line-585" class="ident">l2</a>()]
		<label for="r88" class="ident">h</label>.<a href="#line-113" class="ident">bitp</a> = &amp;<label for="r95" class="ident">a</label>.<a href="mheap.go.html#line-231" class="ident">bitmap</a>[<label for="r92" class="ident">past</label>%<a href="malloc.go.html#line-253" class="ident">heapArenaBitmapBytes</a>]
		<label for="r88" class="ident">h</label>.<a href="#line-116" class="ident">last</a> = &amp;<label for="r95" class="ident">a</label>.<a href="mheap.go.html#line-231" class="ident">bitmap</a>[<a href="../../pkg/builtin.html#name-len" class="ident">len</a>(<label for="r95" class="ident">a</label>.<a href="mheap.go.html#line-231" class="ident">bitmap</a>)-<span class="lit-number">1</span>]
	} <span class="keyword">else</span> {
		<label for="r88" class="ident">h</label>.<a href="#line-113" class="ident">bitp</a>, <label for="r88" class="ident">h</label>.<a href="#line-116" class="ident">last</a> = <a href="../../pkg/builtin.html#name-nil" class="ident">nil</a>, <a href="../../pkg/builtin.html#name-nil" class="ident">nil</a>
	}
	<span class="keyword">return</span> <label for="r88" class="ident">h</label>
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> forwardOrBoundary is like forward, but stops at boundaries between</span><span class="comment"> contiguous sections of the bitmap. It returns the number of words</span><span class="comment"> advanced over, which will be &lt;= n.</span></div>
<div class="code"><pre><code><span class="keyword">func</span> (<label for="r96" class="ident">h</label> <a href="#line-112" class="ident">heapBits</a>) <label for="r97" class="ident"><a href="../../use/runtime..heapBits*29394.forwardOrBoundary*4a826.html" class="ident">forwardOrBoundary</a></label>(<label for="r98" class="ident">n</label> <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>) (<a href="#line-112" class="ident">heapBits</a>, <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>) {
	<label for="r99" class="ident">maxn</label> := <span class="lit-number">4</span> * ((<a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<a href="../../pkg/unsafe.html" class="ident i2">unsafe</a>.<a href="../../pkg/unsafe.html#name-Pointer" class="ident">Pointer</a>(<label for="r96" class="ident">h</label>.<a href="#line-116" class="ident">last</a>)) + <span class="lit-number">1</span>) - <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<a href="../../pkg/unsafe.html" class="ident i2">unsafe</a>.<a href="../../pkg/unsafe.html#name-Pointer" class="ident">Pointer</a>(<label for="r96" class="ident">h</label>.<a href="#line-113" class="ident">bitp</a>)))
	<span class="keyword">if</span> <label for="r98" class="ident">n</label> &gt; <label for="r99" class="ident">maxn</label> {
		<label for="r98" class="ident">n</label> = <label for="r99" class="ident">maxn</label>
	}
	<span class="keyword">return</span> <label for="r96" class="ident">h</label>.<a href="#line-464" class="ident">forward</a>(<label for="r98" class="ident">n</label>), <label for="r98" class="ident">n</label>
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> The caller can test morePointers and isPointer by &amp;-ing with bitScan and bitPointer.</span><span class="comment"> The result includes in its higher bits the bits for subsequent words</span><span class="comment"> described by the same bitmap byte.</span><span class="comment"></span><span class="comment"> nosplit because it is used during write barriers and must not be preempted.</span><span class="comment">go:nosplit</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> The (shift &amp; 31) eliminates a test and conditional branch</span><span class="comment">	 from the generated code.</span></div>
<div class="code"><pre><code>	<span class="keyword">return</span> <a href="../../pkg/builtin.html#name-uint32" class="ident">uint32</a>(*<label for="r100" class="ident">h</label>.<a href="#line-113" class="ident">bitp</a>) &gt;&gt; (<label for="r100" class="ident">h</label>.<a href="#line-114" class="ident">shift</a> &amp; <span class="lit-number">31</span>)
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> morePointers reports whether this word and all remaining words in this object</span><span class="comment"> are scalars.</span><span class="comment"> h must not describe the second word of the object.</span></div>
<div class="code"><pre><code><span class="keyword">func</span> (<label for="r102" class="ident">h</label> <a href="#line-112" class="ident">heapBits</a>) <label for="r103" class="ident"><a href="../../use/runtime..heapBits*29394.morePointers*bdf60.html" class="ident">morePointers</a></label>() <a href="../../pkg/builtin.html#name-bool" class="ident">bool</a> {
	<span class="keyword">return</span> <label for="r102" class="ident">h</label>.<a href="#line-504" class="ident">bits</a>()&amp;<a href="#line-56" class="ident">bitScan</a> != <span class="lit-number">0</span>
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> isPointer reports whether the heap bits describe a pointer word.</span><span class="comment"></span><span class="comment"> nosplit because it is used during write barriers and must not be preempted.</span><span class="comment">go:nosplit</span></div>
<div class="code"><pre><code><span class="keyword">func</span> (<label for="r104" class="ident">h</label> <a href="#line-112" class="ident">heapBits</a>) <label for="r105" class="ident"><a href="../../use/runtime..heapBits*29394.isPointer*40c9c.html" class="ident">isPointer</a></label>() <a href="../../pkg/builtin.html#name-bool" class="ident">bool</a> {
	<span class="keyword">return</span> <label for="r104" class="ident">h</label>.<a href="#line-504" class="ident">bits</a>()&amp;<a href="#line-55" class="ident">bitPointer</a> != <span class="lit-number">0</span>
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> bulkBarrierPreWrite executes a write barrier</span><span class="comment"> for every pointer slot in the memory range [src, src+size),</span><span class="comment"> using pointer/scalar information from [dst, dst+size).</span><span class="comment"> This executes the write barriers necessary before a memmove.</span><span class="comment"> src, dst, and size must be pointer-aligned.</span><span class="comment"> The range [dst, dst+size) must lie within a single object.</span><span class="comment"> It does not perform the actual writes.</span><span class="comment"></span><span class="comment"> As a special case, src == 0 indicates that this is being used for a</span><span class="comment"> memclr. bulkBarrierPreWrite will pass 0 for the src of each write</span><span class="comment"> barrier.</span><span class="comment"></span><span class="comment"> Callers should call bulkBarrierPreWrite immediately before</span><span class="comment"> calling memmove(dst, src, size). This function is marked nosplit</span><span class="comment"> to avoid being preempted; the GC must not stop the goroutine</span><span class="comment"> between the memmove and the execution of the barriers.</span><span class="comment"> The caller is also responsible for cgo pointer checks if this</span><span class="comment"> may be writing Go pointers into non-Go memory.</span><span class="comment"></span><span class="comment"> The pointer bitmap is not maintained for allocations containing</span><span class="comment"> no pointers at all; any caller of bulkBarrierPreWrite must first</span><span class="comment"> make sure the underlying allocation contains pointers, usually</span><span class="comment"> by checking typ.ptrdata.</span><span class="comment"></span><span class="comment"> Callers must perform cgo checks if writeBarrier.cgo.</span><span class="comment"></span><span class="comment">go:nosplit</span></div>
<div class="code"><pre><code><span class="keyword">func</span> <label for="r106" class="ident"><a href="../../pkg/runtime.html#name-bulkBarrierPreWrite" class="ident">bulkBarrierPreWrite</a></label>(<label for="r107" class="ident">dst</label>, <label for="r108" class="ident">src</label>, <label for="r109" class="ident">size</label> <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>) {
	<span class="keyword">if</span> (<label for="r107" class="ident">dst</label>|<label for="r108" class="ident">src</label>|<label for="r109" class="ident">size</label>)&amp;(<a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a>-<span class="lit-number">1</span>) != <span class="lit-number">0</span> {
		<a href="panic.go.html#line-1107" class="ident">throw</a>(<span class="lit-string">"bulkBarrierPreWrite: unaligned arguments"</span>)
	}
	<span class="keyword">if</span> !<a href="mgc.go.html#line-257" class="ident">writeBarrier</a>.<a href="mgc.go.html#line-260" class="ident">needed</a> {
		<span class="keyword">return</span>
	}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> If dst is a global, use the data or BSS bitmaps to</span><span class="comment">		 execute write barriers.</span></div>
<div class="code"><pre><code>		<span class="keyword">for</span> <label for="r111" class="ident">_</label>, <label for="r112" class="ident">datap</label> := <span class="keyword">range</span> <a href="symtab.go.html#line-439" class="ident">activeModules</a>() {
			<span class="keyword">if</span> <label for="r112" class="ident">datap</label>.<a href="symtab.go.html#line-370" class="ident">data</a> &lt;= <label for="r107" class="ident">dst</label> &amp;&amp; <label for="r107" class="ident">dst</label> &lt; <label for="r112" class="ident">datap</label>.<a href="symtab.go.html#line-370" class="ident">edata</a> {
				<a href="#line-648" class="ident">bulkBarrierBitmap</a>(<label for="r107" class="ident">dst</label>, <label for="r108" class="ident">src</label>, <label for="r109" class="ident">size</label>, <label for="r107" class="ident">dst</label>-<label for="r112" class="ident">datap</label>.<a href="symtab.go.html#line-370" class="ident">data</a>, <label for="r112" class="ident">datap</label>.<a href="symtab.go.html#line-390" class="ident">gcdatamask</a>.<a href="stack.go.html#line-564" class="ident">bytedata</a>)
				<span class="keyword">return</span>
			}
		}
		<span class="keyword">for</span> <label for="r113" class="ident">_</label>, <label for="r114" class="ident">datap</label> := <span class="keyword">range</span> <a href="symtab.go.html#line-439" class="ident">activeModules</a>() {
			<span class="keyword">if</span> <label for="r114" class="ident">datap</label>.<a href="symtab.go.html#line-371" class="ident">bss</a> &lt;= <label for="r107" class="ident">dst</label> &amp;&amp; <label for="r107" class="ident">dst</label> &lt; <label for="r114" class="ident">datap</label>.<a href="symtab.go.html#line-371" class="ident">ebss</a> {
				<a href="#line-648" class="ident">bulkBarrierBitmap</a>(<label for="r107" class="ident">dst</label>, <label for="r108" class="ident">src</label>, <label for="r109" class="ident">size</label>, <label for="r107" class="ident">dst</label>-<label for="r114" class="ident">datap</label>.<a href="symtab.go.html#line-371" class="ident">bss</a>, <label for="r114" class="ident">datap</label>.<a href="symtab.go.html#line-390" class="ident">gcbssmask</a>.<a href="stack.go.html#line-564" class="ident">bytedata</a>)
				<span class="keyword">return</span>
			}
		}
		<span class="keyword">return</span>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> dst was heap memory at some point, but isn't now.</span><span class="comment">		 It can't be a global. It must be either our stack,</span><span class="comment">		 or in the case of direct channel sends, it could be</span><span class="comment">		 another stack. Either way, no need for barriers.</span><span class="comment">		 This will also catch if dst is in a freed span,</span><span class="comment">		 though that should never have.</span></div>
<div class="code"><pre><code>		<span class="keyword">return</span>
	}

	<label for="r115" class="ident">buf</label> := &amp;<a href="stubs.go.html#line-18" class="ident">getg</a>().<a href="runtime2.go.html#line-418" class="ident">m</a>.<a href="runtime2.go.html#line-500" class="ident">p</a>.<a href="runtime2.go.html#line-283" class="ident">ptr</a>().<a href="runtime2.go.html#line-678" class="ident">wbBuf</a>
	<label for="r116" class="ident">h</label> := <a href="#line-308" class="ident">heapBitsForAddr</a>(<label for="r107" class="ident">dst</label>)
	<span class="keyword">if</span> <label for="r108" class="ident">src</label> == <span class="lit-number">0</span> {
		<span class="keyword">for</span> <label for="r117" class="ident">i</label> := <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<span class="lit-number">0</span>); <label for="r117" class="ident">i</label> &lt; <label for="r109" class="ident">size</label>; <label for="r117" class="ident">i</label> += <a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a> {
			<span class="keyword">if</span> <label for="r116" class="ident">h</label>.<a href="#line-521" class="ident">isPointer</a>() {
				<label for="r118" class="ident">dstx</label> := (*<a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>)(<a href="../../pkg/unsafe.html" class="ident i2">unsafe</a>.<a href="../../pkg/unsafe.html#name-Pointer" class="ident">Pointer</a>(<label for="r107" class="ident">dst</label> + <label for="r117" class="ident">i</label>))
				<span class="keyword">if</span> !<label for="r115" class="ident">buf</label>.<a href="mwbbuf.go.html#line-144" class="ident">putFast</a>(*<label for="r118" class="ident">dstx</label>, <span class="lit-number">0</span>) {
					<a href="mwbbuf.go.html#line-168" class="ident">wbBufFlush</a>(<a href="../../pkg/builtin.html#name-nil" class="ident">nil</a>, <span class="lit-number">0</span>)
				}
			}
			<label for="r116" class="ident">h</label> = <label for="r116" class="ident">h</label>.<a href="#line-418" class="ident">next</a>()
		}
	} <span class="keyword">else</span> {
		<span class="keyword">for</span> <label for="r119" class="ident">i</label> := <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<span class="lit-number">0</span>); <label for="r119" class="ident">i</label> &lt; <label for="r109" class="ident">size</label>; <label for="r119" class="ident">i</label> += <a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a> {
			<span class="keyword">if</span> <label for="r116" class="ident">h</label>.<a href="#line-521" class="ident">isPointer</a>() {
				<label for="r120" class="ident">dstx</label> := (*<a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>)(<a href="../../pkg/unsafe.html" class="ident i2">unsafe</a>.<a href="../../pkg/unsafe.html#name-Pointer" class="ident">Pointer</a>(<label for="r107" class="ident">dst</label> + <label for="r119" class="ident">i</label>))
				<label for="r121" class="ident">srcx</label> := (*<a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>)(<a href="../../pkg/unsafe.html" class="ident i2">unsafe</a>.<a href="../../pkg/unsafe.html#name-Pointer" class="ident">Pointer</a>(<label for="r108" class="ident">src</label> + <label for="r119" class="ident">i</label>))
				<span class="keyword">if</span> !<label for="r115" class="ident">buf</label>.<a href="mwbbuf.go.html#line-144" class="ident">putFast</a>(*<label for="r120" class="ident">dstx</label>, *<label for="r121" class="ident">srcx</label>) {
					<a href="mwbbuf.go.html#line-168" class="ident">wbBufFlush</a>(<a href="../../pkg/builtin.html#name-nil" class="ident">nil</a>, <span class="lit-number">0</span>)
				}
			}
			<label for="r116" class="ident">h</label> = <label for="r116" class="ident">h</label>.<a href="#line-418" class="ident">next</a>()
		}
	}
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> bulkBarrierPreWriteSrcOnly is like bulkBarrierPreWrite but</span><span class="comment"> does not execute write barriers for [dst, dst+size).</span><span class="comment"></span><span class="comment"> In addition to the requirements of bulkBarrierPreWrite</span><span class="comment"> callers need to ensure [dst, dst+size) is zeroed.</span><span class="comment"></span><span class="comment"> This is used for special cases where e.g. dst was just</span><span class="comment"> created and zeroed with malloc.</span><span class="comment">go:nosplit</span></div>
<div class="code"><pre><code><span class="keyword">func</span> <label for="r122" class="ident"><a href="../../pkg/runtime.html#name-bulkBarrierPreWriteSrcOnly" class="ident">bulkBarrierPreWriteSrcOnly</a></label>(<label for="r123" class="ident">dst</label>, <label for="r124" class="ident">src</label>, <label for="r125" class="ident">size</label> <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>) {
	<span class="keyword">if</span> (<label for="r123" class="ident">dst</label>|<label for="r124" class="ident">src</label>|<label for="r125" class="ident">size</label>)&amp;(<a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a>-<span class="lit-number">1</span>) != <span class="lit-number">0</span> {
		<a href="panic.go.html#line-1107" class="ident">throw</a>(<span class="lit-string">"bulkBarrierPreWrite: unaligned arguments"</span>)
	}
	<span class="keyword">if</span> !<a href="mgc.go.html#line-257" class="ident">writeBarrier</a>.<a href="mgc.go.html#line-260" class="ident">needed</a> {
		<span class="keyword">return</span>
	}
	<label for="r126" class="ident">buf</label> := &amp;<a href="stubs.go.html#line-18" class="ident">getg</a>().<a href="runtime2.go.html#line-418" class="ident">m</a>.<a href="runtime2.go.html#line-500" class="ident">p</a>.<a href="runtime2.go.html#line-283" class="ident">ptr</a>().<a href="runtime2.go.html#line-678" class="ident">wbBuf</a>
	<label for="r127" class="ident">h</label> := <a href="#line-308" class="ident">heapBitsForAddr</a>(<label for="r123" class="ident">dst</label>)
	<span class="keyword">for</span> <label for="r128" class="ident">i</label> := <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<span class="lit-number">0</span>); <label for="r128" class="ident">i</label> &lt; <label for="r125" class="ident">size</label>; <label for="r128" class="ident">i</label> += <a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a> {
		<span class="keyword">if</span> <label for="r127" class="ident">h</label>.<a href="#line-521" class="ident">isPointer</a>() {
			<label for="r129" class="ident">srcx</label> := (*<a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>)(<a href="../../pkg/unsafe.html" class="ident i2">unsafe</a>.<a href="../../pkg/unsafe.html#name-Pointer" class="ident">Pointer</a>(<label for="r124" class="ident">src</label> + <label for="r128" class="ident">i</label>))
			<span class="keyword">if</span> !<label for="r126" class="ident">buf</label>.<a href="mwbbuf.go.html#line-144" class="ident">putFast</a>(<span class="lit-number">0</span>, *<label for="r129" class="ident">srcx</label>) {
				<a href="mwbbuf.go.html#line-168" class="ident">wbBufFlush</a>(<a href="../../pkg/builtin.html#name-nil" class="ident">nil</a>, <span class="lit-number">0</span>)
			}
		}
		<label for="r127" class="ident">h</label> = <label for="r127" class="ident">h</label>.<a href="#line-418" class="ident">next</a>()
	}
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> bulkBarrierBitmap executes write barriers for copying from [src,</span><span class="comment"> src+size) to [dst, dst+size) using a 1-bit pointer bitmap. src is</span><span class="comment"> assumed to start maskOffset bytes into the data covered by the</span><span class="comment"> bitmap in bits (which may not be a multiple of 8).</span><span class="comment"></span><span class="comment"> This is used by bulkBarrierPreWrite for writes to data and BSS.</span><span class="comment"></span><span class="comment">go:nosplit</span></div>
<div class="code"><pre><code><span class="keyword">func</span> <label for="r130" class="ident"><a href="../../pkg/runtime.html#name-bulkBarrierBitmap" class="ident">bulkBarrierBitmap</a></label>(<label for="r131" class="ident">dst</label>, <label for="r132" class="ident">src</label>, <label for="r133" class="ident">size</label>, <label for="r134" class="ident">maskOffset</label> <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>, <label for="r135" class="ident">bits</label> *<a href="../../pkg/builtin.html#name-uint8" class="ident">uint8</a>) {
	<label for="r136" class="ident">word</label> := <label for="r134" class="ident">maskOffset</label> / <a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a>
	<label for="r135" class="ident">bits</label> = <a href="#line-69" class="ident">addb</a>(<label for="r135" class="ident">bits</label>, <label for="r136" class="ident">word</label>/<span class="lit-number">8</span>)
	<label for="r137" class="ident">mask</label> := <a href="../../pkg/builtin.html#name-uint8" class="ident">uint8</a>(<span class="lit-number">1</span>) &lt;&lt; (<label for="r136" class="ident">word</label> % <span class="lit-number">8</span>)

	<label for="r138" class="ident">buf</label> := &amp;<a href="stubs.go.html#line-18" class="ident">getg</a>().<a href="runtime2.go.html#line-418" class="ident">m</a>.<a href="runtime2.go.html#line-500" class="ident">p</a>.<a href="runtime2.go.html#line-283" class="ident">ptr</a>().<a href="runtime2.go.html#line-678" class="ident">wbBuf</a>
	<span class="keyword">for</span> <label for="r139" class="ident">i</label> := <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<span class="lit-number">0</span>); <label for="r139" class="ident">i</label> &lt; <label for="r133" class="ident">size</label>; <label for="r139" class="ident">i</label> += <a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a> {
		<span class="keyword">if</span> <label for="r137" class="ident">mask</label> == <span class="lit-number">0</span> {
			<label for="r135" class="ident">bits</label> = <a href="#line-69" class="ident">addb</a>(<label for="r135" class="ident">bits</label>, <span class="lit-number">1</span>)
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Skip 8 words.</span></div>
<div class="code"><pre><code>				<label for="r139" class="ident">i</label> += <span class="lit-number">7</span> * <a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a>
				<span class="keyword">continue</span>
			}
			<label for="r137" class="ident">mask</label> = <span class="lit-number">1</span>
		}
		<span class="keyword">if</span> *<label for="r135" class="ident">bits</label>&amp;<label for="r137" class="ident">mask</label> != <span class="lit-number">0</span> {
			<label for="r140" class="ident">dstx</label> := (*<a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>)(<a href="../../pkg/unsafe.html" class="ident i2">unsafe</a>.<a href="../../pkg/unsafe.html#name-Pointer" class="ident">Pointer</a>(<label for="r131" class="ident">dst</label> + <label for="r139" class="ident">i</label>))
			<span class="keyword">if</span> <label for="r132" class="ident">src</label> == <span class="lit-number">0</span> {
				<span class="keyword">if</span> !<label for="r138" class="ident">buf</label>.<a href="mwbbuf.go.html#line-144" class="ident">putFast</a>(*<label for="r140" class="ident">dstx</label>, <span class="lit-number">0</span>) {
					<a href="mwbbuf.go.html#line-168" class="ident">wbBufFlush</a>(<a href="../../pkg/builtin.html#name-nil" class="ident">nil</a>, <span class="lit-number">0</span>)
				}
			} <span class="keyword">else</span> {
				<label for="r141" class="ident">srcx</label> := (*<a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>)(<a href="../../pkg/unsafe.html" class="ident i2">unsafe</a>.<a href="../../pkg/unsafe.html#name-Pointer" class="ident">Pointer</a>(<label for="r132" class="ident">src</label> + <label for="r139" class="ident">i</label>))
				<span class="keyword">if</span> !<label for="r138" class="ident">buf</label>.<a href="mwbbuf.go.html#line-144" class="ident">putFast</a>(*<label for="r140" class="ident">dstx</label>, *<label for="r141" class="ident">srcx</label>) {
					<a href="mwbbuf.go.html#line-168" class="ident">wbBufFlush</a>(<a href="../../pkg/builtin.html#name-nil" class="ident">nil</a>, <span class="lit-number">0</span>)
				}
			}
		}
		<label for="r137" class="ident">mask</label> &lt;&lt;= <span class="lit-number">1</span>
	}
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> typeBitsBulkBarrier executes a write barrier for every</span><span class="comment"> pointer that would be copied from [src, src+size) to [dst,</span><span class="comment"> dst+size) by a memmove using the type bitmap to locate those</span><span class="comment"> pointer slots.</span><span class="comment"></span><span class="comment"> The type typ must correspond exactly to [src, src+size) and [dst, dst+size).</span><span class="comment"> dst, src, and size must be pointer-aligned.</span><span class="comment"> The type typ must have a plain bitmap, not a GC program.</span><span class="comment"> The only use of this function is in channel sends, and the</span><span class="comment"> 64 kB channel element limit takes care of this for us.</span><span class="comment"></span><span class="comment"> Must not be preempted because it typically runs right before memmove,</span><span class="comment"> and the GC must observe them as an atomic action.</span><span class="comment"></span><span class="comment"> Callers must perform cgo checks if writeBarrier.cgo.</span><span class="comment"></span><span class="comment">go:nosplit</span></div>
<div class="code"><pre><code><span class="keyword">func</span> <label for="r142" class="ident"><a href="../../pkg/runtime.html#name-typeBitsBulkBarrier" class="ident">typeBitsBulkBarrier</a></label>(<label for="r143" class="ident">typ</label> *<a href="type.go.html#line-31" class="ident">_type</a>, <label for="r144" class="ident">dst</label>, <label for="r145" class="ident">src</label>, <label for="r146" class="ident">size</label> <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>) {
	<span class="keyword">if</span> <label for="r143" class="ident">typ</label> == <a href="../../pkg/builtin.html#name-nil" class="ident">nil</a> {
		<a href="panic.go.html#line-1107" class="ident">throw</a>(<span class="lit-string">"runtime: typeBitsBulkBarrier without type"</span>)
	}
	<span class="keyword">if</span> <label for="r143" class="ident">typ</label>.<a href="type.go.html#line-32" class="ident">size</a> != <label for="r146" class="ident">size</label> {
		<a href="../../pkg/builtin.html#name-println" class="ident">println</a>(<span class="lit-string">"runtime: typeBitsBulkBarrier with type "</span>, <label for="r143" class="ident">typ</label>.<a href="type.go.html#line-50" class="ident">string</a>(), <span class="lit-string">" of size "</span>, <label for="r143" class="ident">typ</label>.<a href="type.go.html#line-32" class="ident">size</a>, <span class="lit-string">" but memory size"</span>, <label for="r146" class="ident">size</label>)
		<a href="panic.go.html#line-1107" class="ident">throw</a>(<span class="lit-string">"runtime: invalid typeBitsBulkBarrier"</span>)
	}
	<span class="keyword">if</span> <label for="r143" class="ident">typ</label>.<a href="type.go.html#line-38" class="ident">kind</a>&amp;<a href="typekind.go.html#line-36" class="ident">kindGCProg</a> != <span class="lit-number">0</span> {
		<a href="../../pkg/builtin.html#name-println" class="ident">println</a>(<span class="lit-string">"runtime: typeBitsBulkBarrier with type "</span>, <label for="r143" class="ident">typ</label>.<a href="type.go.html#line-50" class="ident">string</a>(), <span class="lit-string">" with GC prog"</span>)
		<a href="panic.go.html#line-1107" class="ident">throw</a>(<span class="lit-string">"runtime: invalid typeBitsBulkBarrier"</span>)
	}
	<span class="keyword">if</span> !<a href="mgc.go.html#line-257" class="ident">writeBarrier</a>.<a href="mgc.go.html#line-260" class="ident">needed</a> {
		<span class="keyword">return</span>
	}
	<label for="r147" class="ident">ptrmask</label> := <label for="r143" class="ident">typ</label>.<a href="type.go.html#line-45" class="ident">gcdata</a>
	<label for="r148" class="ident">buf</label> := &amp;<a href="stubs.go.html#line-18" class="ident">getg</a>().<a href="runtime2.go.html#line-418" class="ident">m</a>.<a href="runtime2.go.html#line-500" class="ident">p</a>.<a href="runtime2.go.html#line-283" class="ident">ptr</a>().<a href="runtime2.go.html#line-678" class="ident">wbBuf</a>
	<span class="keyword">var</span> <label for="r149" class="ident">bits</label> <a href="../../pkg/builtin.html#name-uint32" class="ident">uint32</a>
	<span class="keyword">for</span> <label for="r150" class="ident">i</label> := <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<span class="lit-number">0</span>); <label for="r150" class="ident">i</label> &lt; <label for="r143" class="ident">typ</label>.<a href="type.go.html#line-33" class="ident">ptrdata</a>; <label for="r150" class="ident">i</label> += <a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a> {
		<span class="keyword">if</span> <label for="r150" class="ident">i</label>&amp;(<a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a>*<span class="lit-number">8</span>-<span class="lit-number">1</span>) == <span class="lit-number">0</span> {
			<label for="r149" class="ident">bits</label> = <a href="../../pkg/builtin.html#name-uint32" class="ident">uint32</a>(*<label for="r147" class="ident">ptrmask</label>)
			<label for="r147" class="ident">ptrmask</label> = <a href="#line-69" class="ident">addb</a>(<label for="r147" class="ident">ptrmask</label>, <span class="lit-number">1</span>)
		} <span class="keyword">else</span> {
			<label for="r149" class="ident">bits</label> = <label for="r149" class="ident">bits</label> &gt;&gt; <span class="lit-number">1</span>
		}
		<span class="keyword">if</span> <label for="r149" class="ident">bits</label>&amp;<span class="lit-number">1</span> != <span class="lit-number">0</span> {
			<label for="r151" class="ident">dstx</label> := (*<a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>)(<a href="../../pkg/unsafe.html" class="ident i2">unsafe</a>.<a href="../../pkg/unsafe.html#name-Pointer" class="ident">Pointer</a>(<label for="r144" class="ident">dst</label> + <label for="r150" class="ident">i</label>))
			<label for="r152" class="ident">srcx</label> := (*<a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>)(<a href="../../pkg/unsafe.html" class="ident i2">unsafe</a>.<a href="../../pkg/unsafe.html#name-Pointer" class="ident">Pointer</a>(<label for="r145" class="ident">src</label> + <label for="r150" class="ident">i</label>))
			<span class="keyword">if</span> !<label for="r148" class="ident">buf</label>.<a href="mwbbuf.go.html#line-144" class="ident">putFast</a>(*<label for="r151" class="ident">dstx</label>, *<label for="r152" class="ident">srcx</label>) {
				<a href="mwbbuf.go.html#line-168" class="ident">wbBufFlush</a>(<a href="../../pkg/builtin.html#name-nil" class="ident">nil</a>, <span class="lit-number">0</span>)
			}
		}
	}
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> The methods operating on spans all require that h has been returned</span><span class="comment"> by heapBitsForSpan and that size, n, total are the span layout description</span><span class="comment"> returned by the mspan's layout method.</span><span class="comment"> If total &gt; size*n, it means that there is extra leftover memory in the span,</span><span class="comment"> usually due to rounding.</span><span class="comment"></span><span class="comment"> TODO(rsc): Perhaps introduce a different heapBitsSpan type.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> initSpan initializes the heap bitmap for a span.</span><span class="comment"> If this is a span of pointer-sized objects, it initializes all</span><span class="comment"> words to pointer/scan.</span><span class="comment"> Otherwise, it initializes all words to scalar/dead.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Clear bits corresponding to objects.</span></div>
<div class="code"><pre><code>	<label for="r156" class="ident">nw</label> := (<label for="r155" class="ident">s</label>.<a href="mheap.go.html#line-388" class="ident">npages</a> &lt;&lt; <a href="sizeclasses.go.html#line-81" class="ident">_PageShift</a>) / <a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a>
	<span class="keyword">if</span> <label for="r156" class="ident">nw</label>%<a href="#line-59" class="ident">wordsPerBitmapByte</a> != <span class="lit-number">0</span> {
		<a href="panic.go.html#line-1107" class="ident">throw</a>(<span class="lit-string">"initSpan: unaligned length"</span>)
	}
	<span class="keyword">if</span> <label for="r153" class="ident">h</label>.<a href="#line-114" class="ident">shift</a> != <span class="lit-number">0</span> {
		<a href="panic.go.html#line-1107" class="ident">throw</a>(<span class="lit-string">"initSpan: unaligned base"</span>)
	}
	<label for="r157" class="ident">isPtrs</label> := <a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a> == <span class="lit-number">8</span> &amp;&amp; <label for="r155" class="ident">s</label>.<a href="mheap.go.html#line-462" class="ident">elemsize</a> == <a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a>
	<span class="keyword">for</span> <label for="r156" class="ident">nw</label> &gt; <span class="lit-number">0</span> {
		<label for="r158" class="ident">hNext</label>, <label for="r159" class="ident">anw</label> := <label for="r153" class="ident">h</label>.<a href="#line-490" class="ident">forwardOrBoundary</a>(<label for="r156" class="ident">nw</label>)
		<label for="r160" class="ident">nbyte</label> := <label for="r159" class="ident">anw</label> / <a href="#line-59" class="ident">wordsPerBitmapByte</a>
		<span class="keyword">if</span> <label for="r157" class="ident">isPtrs</label> {
			<label for="r161" class="ident">bitp</label> := <label for="r153" class="ident">h</label>.<a href="#line-113" class="ident">bitp</a>
			<span class="keyword">for</span> <label for="r162" class="ident">i</label> := <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<span class="lit-number">0</span>); <label for="r162" class="ident">i</label> &lt; <label for="r160" class="ident">nbyte</label>; <label for="r162" class="ident">i</label>++ {
				*<label for="r161" class="ident">bitp</label> = <a href="#line-63" class="ident">bitPointerAll</a> | <a href="#line-62" class="ident">bitScanAll</a>
				<label for="r161" class="ident">bitp</label> = <a href="#line-89" class="ident">add1</a>(<label for="r161" class="ident">bitp</label>)
			}
		} <span class="keyword">else</span> {
			<a href="stubs.go.html#line-86" class="ident">memclrNoHeapPointers</a>(<a href="../../pkg/unsafe.html" class="ident i2">unsafe</a>.<a href="../../pkg/unsafe.html#name-Pointer" class="ident">Pointer</a>(<label for="r153" class="ident">h</label>.<a href="#line-113" class="ident">bitp</a>), <label for="r160" class="ident">nbyte</label>)
		}
		<label for="r153" class="ident">h</label> = <label for="r158" class="ident">hNext</label>
		<label for="r156" class="ident">nw</label> -= <label for="r159" class="ident">anw</label>
	}
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> countAlloc returns the number of objects allocated in span s by</span><span class="comment"> scanning the allocation bitmap.</span></div>
<div class="code"><pre><code><span class="keyword">func</span> (<label for="r163" class="ident">s</label> *<a href="mheap.go.html#line-382" class="ident">mspan</a>) <label for="r164" class="ident"><a href="../../use/runtime..mspan*6f34b.countAlloc*bcfb5.html" class="ident">countAlloc</a></label>() <a href="../../pkg/builtin.html#name-int" class="ident">int</a> {
	<label for="r165" class="ident">count</label> := <span class="lit-number">0</span>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Iterate over each 8-byte chunk and count allocations</span><span class="comment">	 with an intrinsic. Note that newMarkBits guarantees that</span><span class="comment">	 gcmarkBits will be 8-byte aligned, so we don't have to</span><span class="comment">	 worry about edge cases, irrelevant bits will simply be zero.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Extract 64 bits from the byte pointer and get a OnesCount.</span><span class="comment">		 Note that the unsafe cast here doesn't preserve endianness,</span><span class="comment">		 but that's OK. We only care about how many bits are 1, not</span><span class="comment">		 about the order we discover them in.</span></div>
<div class="code"><pre><code>		<label for="r168" class="ident">mrkBits</label> := *(*<a href="../../pkg/builtin.html#name-uint64" class="ident">uint64</a>)(<a href="../../pkg/unsafe.html" class="ident i2">unsafe</a>.<a href="../../pkg/unsafe.html#name-Pointer" class="ident">Pointer</a>(<label for="r163" class="ident">s</label>.<a href="mheap.go.html#line-443" class="ident">gcmarkBits</a>.<a href="mheap.go.html#line-1876" class="ident">bytep</a>(<label for="r167" class="ident">i</label>)))
		<label for="r165" class="ident">count</label> += <a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/intrinsics_common.go.html#line-71" class="ident">OnesCount64</a>(<label for="r168" class="ident">mrkBits</label>)
	}
	<span class="keyword">return</span> <label for="r165" class="ident">count</label>
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> heapBitsSetType records that the new allocation [x, x+size)</span><span class="comment"> holds in [x, x+dataSize) one or more values of type typ.</span><span class="comment"> (The number of values is given by dataSize / typ.size.)</span><span class="comment"> If dataSize &lt; size, the fragment [x+dataSize, x+size) is</span><span class="comment"> recorded as non-pointer data.</span><span class="comment"> It is known that the type has pointers somewhere;</span><span class="comment"> malloc does not call heapBitsSetType when there are no pointers,</span><span class="comment"> because all free objects are marked as noscan during</span><span class="comment"> heapBitsSweepSpan.</span><span class="comment"></span><span class="comment"> There can only be one allocation from a given span active at a time,</span><span class="comment"> and the bitmap for a span always falls on byte boundaries,</span><span class="comment"> so there are no write-write races for access to the heap bitmap.</span><span class="comment"> Hence, heapBitsSetType can access the bitmap without atomics.</span><span class="comment"></span><span class="comment"> There can be read-write races between heapBitsSetType and things</span><span class="comment"> that read the heap bitmap like scanobject. However, since</span><span class="comment"> heapBitsSetType is only used for objects that have not yet been</span><span class="comment"> made reachable, readers will ignore bits being modified by this</span><span class="comment"> function. This does mean this function cannot transiently modify</span><span class="comment"> bits that belong to neighboring objects. Also, on weakly-ordered</span><span class="comment"> machines, callers must execute a store/store (publication) barrier</span><span class="comment"> between calling this function and making the object reachable.</span></div>
<div class="code"><pre><code><span class="keyword">func</span> <label for="r169" class="ident"><a href="../../pkg/runtime.html#name-heapBitsSetType" class="ident">heapBitsSetType</a></label>(<label for="r170" class="ident">x</label>, <label for="r171" class="ident">size</label>, <label for="r172" class="ident">dataSize</label> <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>, <label for="r173" class="ident">typ</label> *<a href="type.go.html#line-31" class="ident">_type</a>) {
	<span class="keyword">const</span> <label for="r174" class="ident">doubleCheck</label> = <a href="../../pkg/builtin.html#name-false" class="ident">false</a> <span class="comment">// slow but helpful; enable to test modifications to this code</span>

	<span class="keyword">const</span> (
		<label for="r175" class="ident">mask1</label> = <a href="#line-55" class="ident">bitPointer</a> | <a href="#line-56" class="ident">bitScan</a>                        <span class="comment">// 00010001</span>
		<label for="r176" class="ident">mask2</label> = <a href="#line-55" class="ident">bitPointer</a> | <a href="#line-56" class="ident">bitScan</a> | <label for="r175" class="ident">mask1</label>&lt;&lt;<a href="#line-58" class="ident">heapBitsShift</a> <span class="comment">// 00110011</span>
		<label for="r177" class="ident">mask3</label> = <a href="#line-55" class="ident">bitPointer</a> | <a href="#line-56" class="ident">bitScan</a> | <label for="r176" class="ident">mask2</label>&lt;&lt;<a href="#line-58" class="ident">heapBitsShift</a> <span class="comment">// 01110111</span>
	)
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> dataSize is always size rounded up to the next malloc size class,</span><span class="comment">	 except in the case of allocating a defer block, in which case</span><span class="comment">	 size is sizeof(_defer{}) (at least 6 words) and dataSize may be</span><span class="comment">	 arbitrarily larger.</span><span class="comment">	</span><span class="comment">	 The checks for size == sys.PtrSize and size == 2*sys.PtrSize can therefore</span><span class="comment">	 assume that dataSize == size without checking it explicitly.</span></div>
<div class="code"><pre><code>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> It's one word and it has pointers, it must be a pointer.</span><span class="comment">		 Since all allocated one-word objects are pointers</span><span class="comment">		 (non-pointers are aggregated into tinySize allocations),</span><span class="comment">		 initSpan sets the pointer bits for us. Nothing to do here.</span></div>
<div class="code"><pre><code>		<span class="keyword">if</span> <label for="r174" class="ident">doubleCheck</label> {
			<label for="r178" class="ident">h</label> := <a href="#line-308" class="ident">heapBitsForAddr</a>(<label for="r170" class="ident">x</label>)
			<span class="keyword">if</span> !<label for="r178" class="ident">h</label>.<a href="#line-521" class="ident">isPointer</a>() {
				<a href="panic.go.html#line-1107" class="ident">throw</a>(<span class="lit-string">"heapBitsSetType: pointer bit missing"</span>)
			}
			<span class="keyword">if</span> !<label for="r178" class="ident">h</label>.<a href="#line-513" class="ident">morePointers</a>() {
				<a href="panic.go.html#line-1107" class="ident">throw</a>(<span class="lit-string">"heapBitsSetType: scan bit missing"</span>)
			}
		}
		<span class="keyword">return</span>
	}

	<label for="r179" class="ident">h</label> := <a href="#line-308" class="ident">heapBitsForAddr</a>(<label for="r170" class="ident">x</label>)
	<label for="r180" class="ident">ptrmask</label> := <label for="r173" class="ident">typ</label>.<a href="type.go.html#line-45" class="ident">gcdata</a> <span class="comment">// start of 1-bit pointer mask (or GC program, handled below)</span>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> 2-word objects only have 4 bitmap bits and 3-word objects only have 6 bitmap bits.</span><span class="comment">	 Therefore, these objects share a heap bitmap byte with the objects next to them.</span><span class="comment">	 These are called out as a special case primarily so the code below can assume all</span><span class="comment">	 objects are at least 4 words long and that their bitmaps start either at the beginning</span><span class="comment">	 of a bitmap byte, or half-way in (h.shift of 0 and 2 respectively).</span></div>
<div class="code"><pre><code>
	<span class="keyword">if</span> <label for="r171" class="ident">size</label> == <span class="lit-number">2</span>*<a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a> {
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> We're allocating a block big enough to hold two pointers.</span><span class="comment">			 On 64-bit, that means the actual object must be two pointers,</span><span class="comment">			 or else we'd have used the one-pointer-sized block.</span><span class="comment">			 On 32-bit, however, this is the 8-byte block, the smallest one.</span><span class="comment">			 So it could be that we're allocating one pointer and this was</span><span class="comment">			 just the smallest block available. Distinguish by checking dataSize.</span><span class="comment">			 (In general the number of instances of typ being allocated is</span><span class="comment">			 dataSize/typ.size.)</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> 1 pointer object. On 32-bit machines clear the bit for the</span><span class="comment">				 unused second word.</span></div>
<div class="code"><pre><code>				*<label for="r179" class="ident">h</label>.<a href="#line-113" class="ident">bitp</a> &amp;^= (<a href="#line-55" class="ident">bitPointer</a> | <a href="#line-56" class="ident">bitScan</a> | (<a href="#line-55" class="ident">bitPointer</a>|<a href="#line-56" class="ident">bitScan</a>)&lt;&lt;<a href="#line-58" class="ident">heapBitsShift</a>) &lt;&lt; <label for="r179" class="ident">h</label>.<a href="#line-114" class="ident">shift</a>
				*<label for="r179" class="ident">h</label>.<a href="#line-113" class="ident">bitp</a> |= (<a href="#line-55" class="ident">bitPointer</a> | <a href="#line-56" class="ident">bitScan</a>) &lt;&lt; <label for="r179" class="ident">h</label>.<a href="#line-114" class="ident">shift</a>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> 2-element array of pointer.</span></div>
<div class="code"><pre><code>				*<label for="r179" class="ident">h</label>.<a href="#line-113" class="ident">bitp</a> |= (<a href="#line-55" class="ident">bitPointer</a> | <a href="#line-56" class="ident">bitScan</a> | (<a href="#line-55" class="ident">bitPointer</a>|<a href="#line-56" class="ident">bitScan</a>)&lt;&lt;<a href="#line-58" class="ident">heapBitsShift</a>) &lt;&lt; <label for="r179" class="ident">h</label>.<a href="#line-114" class="ident">shift</a>
			}
			<span class="keyword">return</span>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Otherwise typ.size must be 2*sys.PtrSize,</span><span class="comment">		 and typ.kind&amp;kindGCProg == 0.</span></div>
<div class="code"><pre><code>		<span class="keyword">if</span> <label for="r174" class="ident">doubleCheck</label> {
			<span class="keyword">if</span> <label for="r173" class="ident">typ</label>.<a href="type.go.html#line-32" class="ident">size</a> != <span class="lit-number">2</span>*<a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a> || <label for="r173" class="ident">typ</label>.<a href="type.go.html#line-38" class="ident">kind</a>&amp;<a href="typekind.go.html#line-36" class="ident">kindGCProg</a> != <span class="lit-number">0</span> {
				<a href="../../pkg/builtin.html#name-print" class="ident">print</a>(<span class="lit-string">"runtime: heapBitsSetType size="</span>, <label for="r171" class="ident">size</label>, <span class="lit-string">" but typ.size="</span>, <label for="r173" class="ident">typ</label>.<a href="type.go.html#line-32" class="ident">size</a>, <span class="lit-string">" gcprog="</span>, <label for="r173" class="ident">typ</label>.<a href="type.go.html#line-38" class="ident">kind</a>&amp;<a href="typekind.go.html#line-36" class="ident">kindGCProg</a> != <span class="lit-number">0</span>, <span class="lit-string">"\n"</span>)
				<a href="panic.go.html#line-1107" class="ident">throw</a>(<span class="lit-string">"heapBitsSetType"</span>)
			}
		}
		<label for="r181" class="ident">b</label> := <a href="../../pkg/builtin.html#name-uint32" class="ident">uint32</a>(*<label for="r180" class="ident">ptrmask</label>)
		<label for="r182" class="ident">hb</label> := <label for="r181" class="ident">b</label> &amp; <span class="lit-number">3</span>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Clear the bits for this object so we can set the</span><span class="comment">		 appropriate ones.</span></div>
<div class="code"><pre><code>		*<label for="r179" class="ident">h</label>.<a href="#line-113" class="ident">bitp</a> &amp;^= (<a href="#line-55" class="ident">bitPointer</a> | <a href="#line-56" class="ident">bitScan</a> | ((<a href="#line-55" class="ident">bitPointer</a> | <a href="#line-56" class="ident">bitScan</a>) &lt;&lt; <a href="#line-58" class="ident">heapBitsShift</a>)) &lt;&lt; <label for="r179" class="ident">h</label>.<a href="#line-114" class="ident">shift</a>
		*<label for="r179" class="ident">h</label>.<a href="#line-113" class="ident">bitp</a> |= <a href="../../pkg/builtin.html#name-uint8" class="ident">uint8</a>(<label for="r182" class="ident">hb</label> &lt;&lt; <label for="r179" class="ident">h</label>.<a href="#line-114" class="ident">shift</a>)
		<span class="keyword">return</span>
	} <span class="keyword">else</span> <span class="keyword">if</span> <label for="r171" class="ident">size</label> == <span class="lit-number">3</span>*<a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a> {
		<label for="r183" class="ident">b</label> := <a href="../../pkg/builtin.html#name-uint8" class="ident">uint8</a>(*<label for="r180" class="ident">ptrmask</label>)
		<span class="keyword">if</span> <label for="r174" class="ident">doubleCheck</label> {
			<span class="keyword">if</span> <label for="r183" class="ident">b</label> == <span class="lit-number">0</span> {
				<a href="../../pkg/builtin.html#name-println" class="ident">println</a>(<span class="lit-string">"runtime: invalid type "</span>, <label for="r173" class="ident">typ</label>.<a href="type.go.html#line-50" class="ident">string</a>())
				<a href="panic.go.html#line-1107" class="ident">throw</a>(<span class="lit-string">"heapBitsSetType: called with non-pointer type"</span>)
			}
			<span class="keyword">if</span> <a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a> != <span class="lit-number">8</span> {
				<a href="panic.go.html#line-1107" class="ident">throw</a>(<span class="lit-string">"heapBitsSetType: unexpected 3 pointer wide size class on 32 bit"</span>)
			}
			<span class="keyword">if</span> <label for="r173" class="ident">typ</label>.<a href="type.go.html#line-38" class="ident">kind</a>&amp;<a href="typekind.go.html#line-36" class="ident">kindGCProg</a> != <span class="lit-number">0</span> {
				<a href="panic.go.html#line-1107" class="ident">throw</a>(<span class="lit-string">"heapBitsSetType: unexpected GC prog for 3 pointer wide size class"</span>)
			}
			<span class="keyword">if</span> <label for="r173" class="ident">typ</label>.<a href="type.go.html#line-32" class="ident">size</a> == <span class="lit-number">2</span>*<a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a> {
				<a href="../../pkg/builtin.html#name-print" class="ident">print</a>(<span class="lit-string">"runtime: heapBitsSetType size="</span>, <label for="r171" class="ident">size</label>, <span class="lit-string">" but typ.size="</span>, <label for="r173" class="ident">typ</label>.<a href="type.go.html#line-32" class="ident">size</a>, <span class="lit-string">"\n"</span>)
				<a href="panic.go.html#line-1107" class="ident">throw</a>(<span class="lit-string">"heapBitsSetType: inconsistent object sizes"</span>)
			}
		}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> The type contains a pointer otherwise heapBitsSetType wouldn't have been called.</span><span class="comment">			 Since the type is only 1 pointer wide and contains a pointer, its gcdata must be exactly 1.</span></div>
<div class="code"><pre><code>			<span class="keyword">if</span> <label for="r174" class="ident">doubleCheck</label> &amp;&amp; *<label for="r173" class="ident">typ</label>.<a href="type.go.html#line-45" class="ident">gcdata</a> != <span class="lit-number">1</span> {
				<a href="../../pkg/builtin.html#name-print" class="ident">print</a>(<span class="lit-string">"runtime: heapBitsSetType size="</span>, <label for="r171" class="ident">size</label>, <span class="lit-string">" typ.size="</span>, <label for="r173" class="ident">typ</label>.<a href="type.go.html#line-32" class="ident">size</a>, <span class="lit-string">"but *typ.gcdata"</span>, *<label for="r173" class="ident">typ</label>.<a href="type.go.html#line-45" class="ident">gcdata</a>, <span class="lit-string">"\n"</span>)
				<a href="panic.go.html#line-1107" class="ident">throw</a>(<span class="lit-string">"heapBitsSetType: unexpected gcdata for 1 pointer wide type size in 3 pointer wide size class"</span>)
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> 3 element array of pointers. Unrolling ptrmask 3 times into p yields 00000111.</span></div>
<div class="code"><pre><code>			<label for="r183" class="ident">b</label> = <span class="lit-number">7</span>
		}

</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Set bitScan bits for all pointers.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> First bitScan bit is always set since the type contains pointers.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Second bitScan bit needs to also be set if the third bitScan bit is set.</span></div>
<div class="code"><pre><code>		<label for="r184" class="ident">hb</label> |= <label for="r184" class="ident">hb</label> &amp; (<a href="#line-56" class="ident">bitScan</a> &lt;&lt; (<span class="lit-number">2</span> * <a href="#line-58" class="ident">heapBitsShift</a>)) &gt;&gt; <span class="lit-number">1</span>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> For h.shift &gt; 1 heap bits cross a byte boundary and need to be written part</span><span class="comment">		 to h.bitp and part to the next h.bitp.</span></div>
<div class="code"><pre><code>		<span class="keyword">switch</span> <label for="r179" class="ident">h</label>.<a href="#line-114" class="ident">shift</a> {
		<span class="keyword">case</span> <span class="lit-number">0</span>:
			*<label for="r179" class="ident">h</label>.<a href="#line-113" class="ident">bitp</a> &amp;^= <label for="r177" class="ident">mask3</label> &lt;&lt; <span class="lit-number">0</span>
			*<label for="r179" class="ident">h</label>.<a href="#line-113" class="ident">bitp</a> |= <label for="r184" class="ident">hb</label> &lt;&lt; <span class="lit-number">0</span>
		<span class="keyword">case</span> <span class="lit-number">1</span>:
			*<label for="r179" class="ident">h</label>.<a href="#line-113" class="ident">bitp</a> &amp;^= <label for="r177" class="ident">mask3</label> &lt;&lt; <span class="lit-number">1</span>
			*<label for="r179" class="ident">h</label>.<a href="#line-113" class="ident">bitp</a> |= <label for="r184" class="ident">hb</label> &lt;&lt; <span class="lit-number">1</span>
		<span class="keyword">case</span> <span class="lit-number">2</span>:
			*<label for="r179" class="ident">h</label>.<a href="#line-113" class="ident">bitp</a> &amp;^= <label for="r176" class="ident">mask2</label> &lt;&lt; <span class="lit-number">2</span>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Two words written to the first byte.</span><span class="comment">			 Advance two words to get to the next byte.</span></div>
<div class="code"><pre><code>			<label for="r179" class="ident">h</label> = <label for="r179" class="ident">h</label>.<a href="#line-418" class="ident">next</a>().<a href="#line-418" class="ident">next</a>()
			*<label for="r179" class="ident">h</label>.<a href="#line-113" class="ident">bitp</a> &amp;^= <label for="r175" class="ident">mask1</label>
			*<label for="r179" class="ident">h</label>.<a href="#line-113" class="ident">bitp</a> |= (<label for="r184" class="ident">hb</label> &gt;&gt; <span class="lit-number">2</span>) &amp; <label for="r175" class="ident">mask1</label>
		<span class="keyword">case</span> <span class="lit-number">3</span>:
			*<label for="r179" class="ident">h</label>.<a href="#line-113" class="ident">bitp</a> &amp;^= <label for="r175" class="ident">mask1</label> &lt;&lt; <span class="lit-number">3</span>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> One word written to the first byte.</span><span class="comment">			 Advance one word to get to the next byte.</span></div>
<div class="code"><pre><code>			<label for="r179" class="ident">h</label> = <label for="r179" class="ident">h</label>.<a href="#line-418" class="ident">next</a>()
			*<label for="r179" class="ident">h</label>.<a href="#line-113" class="ident">bitp</a> &amp;^= <label for="r176" class="ident">mask2</label>
			*<label for="r179" class="ident">h</label>.<a href="#line-113" class="ident">bitp</a> |= (<label for="r184" class="ident">hb</label> &gt;&gt; <span class="lit-number">1</span>) &amp; <label for="r176" class="ident">mask2</label>
		}
		<span class="keyword">return</span>
	}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Copy from 1-bit ptrmask into 2-bit bitmap.</span><span class="comment">	 The basic approach is to use a single uintptr as a bit buffer,</span><span class="comment">	 alternating between reloading the buffer and writing bitmap bytes.</span><span class="comment">	 In general, one load can supply two bitmap byte writes.</span><span class="comment">	 This is a lot of lines of code, but it compiles into relatively few</span><span class="comment">	 machine instructions.</span></div>
<div class="code"><pre><code>
	<label for="r185" class="ident">outOfPlace</label> := <a href="../../pkg/builtin.html#name-false" class="ident">false</a>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> This object spans heap arenas, so the bitmap may be</span><span class="comment">		 discontiguous. Unroll it into the object instead</span><span class="comment">		 and then copy it out.</span><span class="comment">		</span><span class="comment">		 In doubleCheck mode, we randomly do this anyway to</span><span class="comment">		 stress test the bitmap copying path.</span></div>
<div class="code"><pre><code>		<label for="r185" class="ident">outOfPlace</label> = <a href="../../pkg/builtin.html#name-true" class="ident">true</a>
		<label for="r179" class="ident">h</label>.<a href="#line-113" class="ident">bitp</a> = (*<a href="../../pkg/builtin.html#name-uint8" class="ident">uint8</a>)(<a href="../../pkg/unsafe.html" class="ident i2">unsafe</a>.<a href="../../pkg/unsafe.html#name-Pointer" class="ident">Pointer</a>(<label for="r170" class="ident">x</label>))
		<label for="r179" class="ident">h</label>.<a href="#line-116" class="ident">last</a> = <a href="../../pkg/builtin.html#name-nil" class="ident">nil</a>
	}

</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Ptrmask input.</span></div>
<div class="code"><pre><code>		<label for="r186" class="ident">p</label>     *<a href="../../pkg/builtin.html#name-byte" class="ident">byte</a>   <span class="comment">// last ptrmask byte read</span>
		<label for="r187" class="ident">b</label>     <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a> <span class="comment">// ptrmask bits already loaded</span>
		<label for="r188" class="ident">nb</label>    <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a> <span class="comment">// number of bits in b at next read</span>
		<label for="r189" class="ident">endp</label>  *<a href="../../pkg/builtin.html#name-byte" class="ident">byte</a>   <span class="comment">// final ptrmask byte to read (then repeat)</span>
		<label for="r190" class="ident">endnb</label> <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a> <span class="comment">// number of valid bits in *endp</span>
		<label for="r191" class="ident">pbits</label> <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a> <span class="comment">// alternate source of bits</span>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Heap bitmap output.</span></div>
<div class="code"><pre><code>		<label for="r192" class="ident">w</label>     <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a> <span class="comment">// words processed</span>
		<label for="r193" class="ident">nw</label>    <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a> <span class="comment">// number of words to process</span>
		<label for="r194" class="ident">hbitp</label> *<a href="../../pkg/builtin.html#name-byte" class="ident">byte</a>   <span class="comment">// next heap bitmap byte to write</span>
		<label for="r195" class="ident">hb</label>    <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a> <span class="comment">// bits being prepared for *hbitp</span>
	)

	<label for="r194" class="ident">hbitp</label> = <label for="r179" class="ident">h</label>.<a href="#line-113" class="ident">bitp</a>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Handle GC program. Delayed until this part of the code</span><span class="comment">	 so that we can use the same double-checking mechanism</span><span class="comment">	 as the 1-bit case. Nothing above could have encountered</span><span class="comment">	 GC programs: the cases were all too small.</span></div>
<div class="code"><pre><code>	<span class="keyword">if</span> <label for="r173" class="ident">typ</label>.<a href="type.go.html#line-38" class="ident">kind</a>&amp;<a href="typekind.go.html#line-36" class="ident">kindGCProg</a> != <span class="lit-number">0</span> {
		<a href="#line-1472" class="ident">heapBitsSetTypeGCProg</a>(<label for="r179" class="ident">h</label>, <label for="r173" class="ident">typ</label>.<a href="type.go.html#line-33" class="ident">ptrdata</a>, <label for="r173" class="ident">typ</label>.<a href="type.go.html#line-32" class="ident">size</a>, <label for="r172" class="ident">dataSize</label>, <label for="r171" class="ident">size</label>, <a href="#line-69" class="ident">addb</a>(<label for="r173" class="ident">typ</label>.<a href="type.go.html#line-45" class="ident">gcdata</a>, <span class="lit-number">4</span>))
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Double-check the heap bits written by GC program</span><span class="comment">			 by running the GC program to create a 1-bit pointer mask</span><span class="comment">			 and then jumping to the double-check code below.</span><span class="comment">			 This doesn't catch bugs shared between the 1-bit and 4-bit</span><span class="comment">			 GC program execution, but it does catch mistakes specific</span><span class="comment">			 to just one of those and bugs in heapBitsSetTypeGCProg's</span><span class="comment">			 implementation of arrays.</span></div>
<div class="code"><pre><code>			<a href="lock_sema.go.html#line-35" class="ident">lock</a>(&amp;<a href="#line-1457" class="ident">debugPtrmask</a>.<a href="#line-1458" class="ident">lock</a>)
			<span class="keyword">if</span> <a href="#line-1457" class="ident">debugPtrmask</a>.<a href="#line-1459" class="ident">data</a> == <a href="../../pkg/builtin.html#name-nil" class="ident">nil</a> {
				<a href="#line-1457" class="ident">debugPtrmask</a>.<a href="#line-1459" class="ident">data</a> = (*<a href="../../pkg/builtin.html#name-byte" class="ident">byte</a>)(<a href="malloc.go.html#line-1311" class="ident">persistentalloc</a>(<span class="lit-number">1</span>&lt;&lt;<span class="lit-number">20</span>, <span class="lit-number">1</span>, &amp;<a href="mstats.go.html#line-170" class="ident">memstats</a>.<a href="mstats.go.html#line-61" class="ident">other_sys</a>))
			}
			<label for="r180" class="ident">ptrmask</label> = <a href="#line-1457" class="ident">debugPtrmask</a>.<a href="#line-1459" class="ident">data</a>
			<a href="#line-1584" class="ident">runGCProg</a>(<a href="#line-69" class="ident">addb</a>(<label for="r173" class="ident">typ</label>.<a href="type.go.html#line-45" class="ident">gcdata</a>, <span class="lit-number">4</span>), <a href="../../pkg/builtin.html#name-nil" class="ident">nil</a>, <label for="r180" class="ident">ptrmask</label>, <span class="lit-number">1</span>)
		}
		<span class="keyword">goto</span> <label for="r196" class="ident">Phase4</label>
	}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Note about sizes:</span><span class="comment">	</span><span class="comment">	 typ.size is the number of words in the object,</span><span class="comment">	 and typ.ptrdata is the number of words in the prefix</span><span class="comment">	 of the object that contains pointers. That is, the final</span><span class="comment">	 typ.size - typ.ptrdata words contain no pointers.</span><span class="comment">	 This allows optimization of a common pattern where</span><span class="comment">	 an object has a small header followed by a large scalar</span><span class="comment">	 buffer. If we know the pointers are over, we don't have</span><span class="comment">	 to scan the buffer's heap bitmap at all.</span><span class="comment">	 The 1-bit ptrmasks are sized to contain only bits for</span><span class="comment">	 the typ.ptrdata prefix, zero padded out to a full byte</span><span class="comment">	 of bitmap. This code sets nw (below) so that heap bitmap</span><span class="comment">	 bits are only written for the typ.ptrdata prefix; if there is</span><span class="comment">	 more room in the allocated object, the next heap bitmap</span><span class="comment">	 entry is a 00, indicating that there are no more pointers</span><span class="comment">	 to scan. So only the ptrmask for the ptrdata bytes is needed.</span><span class="comment">	</span><span class="comment">	 Replicated copies are not as nice: if there is an array of</span><span class="comment">	 objects with scalar tails, all but the last tail does have to</span><span class="comment">	 be initialized, because there is no way to say "skip forward".</span><span class="comment">	 However, because of the possibility of a repeated type with</span><span class="comment">	 size not a multiple of 4 pointers (one heap bitmap byte),</span><span class="comment">	 the code already must handle the last ptrmask byte specially</span><span class="comment">	 by treating it as containing only the bits for endnb pointers,</span><span class="comment">	 where endnb &lt;= 4. We represent large scalar tails that must</span><span class="comment">	 be expanded in the replication by setting endnb larger than 4.</span><span class="comment">	 This will have the effect of reading many bits out of b,</span><span class="comment">	 but once the real bits are shifted out, b will supply as many</span><span class="comment">	 zero bits as we try to read, which is exactly what we need.</span></div>
<div class="code"><pre><code>
	<label for="r186" class="ident">p</label> = <label for="r180" class="ident">ptrmask</label>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Filling in bits for an array of typ.</span><span class="comment">		 Set up for repetition of ptrmask during main loop.</span><span class="comment">		 Note that ptrmask describes only a prefix of</span></div>
<div class="code"><pre><code>		<span class="keyword">const</span> <label for="r197" class="ident">maxBits</label> = <a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a>*<span class="lit-number">8</span> - <span class="lit-number">7</span>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Entire ptrmask fits in uintptr with room for a byte fragment.</span><span class="comment">			 Load into pbits and never read from ptrmask again.</span><span class="comment">			 This is especially important when the ptrmask has</span><span class="comment">			 fewer than 8 bits in it; otherwise the reload in the middle</span><span class="comment">			 of the Phase 2 loop would itself need to loop to gather</span><span class="comment">			 at least 8 bits.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Accumulate ptrmask into b.</span><span class="comment">			 ptrmask is sized to describe only typ.ptrdata, but we record</span><span class="comment">			 it as describing typ.size bytes, since all the high bits are zero.</span></div>
<div class="code"><pre><code>			<label for="r188" class="ident">nb</label> = <label for="r173" class="ident">typ</label>.<a href="type.go.html#line-33" class="ident">ptrdata</a> / <a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a>
			<span class="keyword">for</span> <label for="r198" class="ident">i</label> := <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<span class="lit-number">0</span>); <label for="r198" class="ident">i</label> &lt; <label for="r188" class="ident">nb</label>; <label for="r198" class="ident">i</label> += <span class="lit-number">8</span> {
				<label for="r187" class="ident">b</label> |= <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(*<label for="r186" class="ident">p</label>) &lt;&lt; <label for="r198" class="ident">i</label>
				<label for="r186" class="ident">p</label> = <a href="#line-89" class="ident">add1</a>(<label for="r186" class="ident">p</label>)
			}
			<label for="r188" class="ident">nb</label> = <label for="r173" class="ident">typ</label>.<a href="type.go.html#line-32" class="ident">size</a> / <a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Replicate ptrmask to fill entire pbits uintptr.</span><span class="comment">			 Doubling and truncating is fewer steps than</span><span class="comment">			 iterating by nb each time. (nb could be 1.)</span><span class="comment">			 Since we loaded typ.ptrdata/sys.PtrSize bits</span><span class="comment">			 but are pretending to have typ.size/sys.PtrSize,</span><span class="comment">			 there might be no replication necessary/possible.</span></div>
<div class="code"><pre><code>			<label for="r191" class="ident">pbits</label> = <label for="r187" class="ident">b</label>
			<label for="r190" class="ident">endnb</label> = <label for="r188" class="ident">nb</label>
			<span class="keyword">if</span> <label for="r188" class="ident">nb</label>+<label for="r188" class="ident">nb</label> &lt;= <label for="r197" class="ident">maxBits</label> {
				<span class="keyword">for</span> <label for="r190" class="ident">endnb</label> &lt;= <a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a>*<span class="lit-number">8</span> {
					<label for="r191" class="ident">pbits</label> |= <label for="r191" class="ident">pbits</label> &lt;&lt; <label for="r190" class="ident">endnb</label>
					<label for="r190" class="ident">endnb</label> += <label for="r190" class="ident">endnb</label>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Truncate to a multiple of original ptrmask.</span><span class="comment">				 Because nb+nb &lt;= maxBits, nb fits in a byte.</span><span class="comment">				 Byte division is cheaper than uintptr division.</span></div>
<div class="code"><pre><code>				<label for="r190" class="ident">endnb</label> = <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<label for="r197" class="ident">maxBits</label>/<a href="../../pkg/builtin.html#name-byte" class="ident">byte</a>(<label for="r188" class="ident">nb</label>)) * <label for="r188" class="ident">nb</label>
				<label for="r191" class="ident">pbits</label> &amp;= <span class="lit-number">1</span>&lt;&lt;<label for="r190" class="ident">endnb</label> - <span class="lit-number">1</span>
				<label for="r187" class="ident">b</label> = <label for="r191" class="ident">pbits</label>
				<label for="r188" class="ident">nb</label> = <label for="r190" class="ident">endnb</label>
			}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Clear p and endp as sentinel for using pbits.</span><span class="comment">			 Checked during Phase 2 loop.</span></div>
<div class="code"><pre><code>			<label for="r186" class="ident">p</label> = <a href="../../pkg/builtin.html#name-nil" class="ident">nil</a>
			<label for="r189" class="ident">endp</label> = <a href="../../pkg/builtin.html#name-nil" class="ident">nil</a>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Ptrmask is larger. Read it multiple times.</span></div>
<div class="code"><pre><code>			<label for="r199" class="ident">n</label> := (<label for="r173" class="ident">typ</label>.<a href="type.go.html#line-33" class="ident">ptrdata</a>/<a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a>+<span class="lit-number">7</span>)/<span class="lit-number">8</span> - <span class="lit-number">1</span>
			<label for="r189" class="ident">endp</label> = <a href="#line-69" class="ident">addb</a>(<label for="r180" class="ident">ptrmask</label>, <label for="r199" class="ident">n</label>)
			<label for="r190" class="ident">endnb</label> = <label for="r173" class="ident">typ</label>.<a href="type.go.html#line-32" class="ident">size</a>/<a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a> - <label for="r199" class="ident">n</label>*<span class="lit-number">8</span>
		}
	}
	<span class="keyword">if</span> <label for="r186" class="ident">p</label> != <a href="../../pkg/builtin.html#name-nil" class="ident">nil</a> {
		<label for="r187" class="ident">b</label> = <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(*<label for="r186" class="ident">p</label>)
		<label for="r186" class="ident">p</label> = <a href="#line-89" class="ident">add1</a>(<label for="r186" class="ident">p</label>)
		<label for="r188" class="ident">nb</label> = <span class="lit-number">8</span>
	}

</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Single entry: can stop once we reach the non-pointer data.</span></div>
<div class="code"><pre><code>		<label for="r193" class="ident">nw</label> = <label for="r173" class="ident">typ</label>.<a href="type.go.html#line-33" class="ident">ptrdata</a> / <a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Repeated instances of typ in an array.</span><span class="comment">		 Have to process first N-1 entries in full, but can stop</span><span class="comment">		 once we reach the non-pointer data in the final entry.</span></div>
<div class="code"><pre><code>		<label for="r193" class="ident">nw</label> = ((<label for="r172" class="ident">dataSize</label>/<label for="r173" class="ident">typ</label>.<a href="type.go.html#line-32" class="ident">size</a>-<span class="lit-number">1</span>)*<label for="r173" class="ident">typ</label>.<a href="type.go.html#line-32" class="ident">size</a> + <label for="r173" class="ident">typ</label>.<a href="type.go.html#line-33" class="ident">ptrdata</a>) / <a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a>
	}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> No pointers! Caller was supposed to check.</span></div>
<div class="code"><pre><code>		<a href="../../pkg/builtin.html#name-println" class="ident">println</a>(<span class="lit-string">"runtime: invalid type "</span>, <label for="r173" class="ident">typ</label>.<a href="type.go.html#line-50" class="ident">string</a>())
		<a href="panic.go.html#line-1107" class="ident">throw</a>(<span class="lit-string">"heapBitsSetType: called with non-pointer type"</span>)
		<span class="keyword">return</span>
	}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Phase 1: Special case for leading byte (shift==0) or half-byte (shift==2).</span><span class="comment">	 The leading byte is special because it contains the bits for word 1,</span><span class="comment">	 which does not have the scan bit set.</span><span class="comment">	 The leading half-byte is special because it's a half a byte,</span><span class="comment">	 so we have to be careful with the bits already there.</span></div>
<div class="code"><pre><code>	<span class="keyword">switch</span> {
	<span class="keyword">default</span>:
		<a href="panic.go.html#line-1107" class="ident">throw</a>(<span class="lit-string">"heapBitsSetType: unexpected shift"</span>)

</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Ptrmask and heap bitmap are aligned.</span><span class="comment">		</span><span class="comment">		 This is a fast path for small objects.</span><span class="comment">		</span><span class="comment">		 The first byte we write out covers the first four</span><span class="comment">		 words of the object. The scan/dead bit on the first</span><span class="comment">		 word must be set to scan since there are pointers</span><span class="comment">		 somewhere in the object.</span><span class="comment">		 In all following words, we set the scan/dead</span><span class="comment">		 appropriately to indicate that the object continues</span><span class="comment">		 to the next 2-bit entry in the bitmap.</span><span class="comment">		</span><span class="comment">		 We set four bits at a time here, but if the object</span><span class="comment">		 is fewer than four words, phase 3 will clear</span><span class="comment">		 unnecessary bits.</span></div>
<div class="code"><pre><code>		<label for="r195" class="ident">hb</label> = <label for="r187" class="ident">b</label> &amp; <a href="#line-63" class="ident">bitPointerAll</a>
		<label for="r195" class="ident">hb</label> |= <a href="#line-62" class="ident">bitScanAll</a>
		<span class="keyword">if</span> <label for="r192" class="ident">w</label> += <span class="lit-number">4</span>; <label for="r192" class="ident">w</label> &gt;= <label for="r193" class="ident">nw</label> {
			<span class="keyword">goto</span> <label for="r200" class="ident">Phase3</label>
		}
		*<label for="r194" class="ident">hbitp</label> = <a href="../../pkg/builtin.html#name-uint8" class="ident">uint8</a>(<label for="r195" class="ident">hb</label>)
		<label for="r194" class="ident">hbitp</label> = <a href="#line-89" class="ident">add1</a>(<label for="r194" class="ident">hbitp</label>)
		<label for="r187" class="ident">b</label> &gt;&gt;= <span class="lit-number">4</span>
		<label for="r188" class="ident">nb</label> -= <span class="lit-number">4</span>

</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Ptrmask and heap bitmap are misaligned.</span><span class="comment">		</span><span class="comment">		 On 32 bit architectures only the 6-word object that corresponds</span><span class="comment">		 to a 24 bytes size class can start with h.shift of 2 here since</span><span class="comment">		 all other non 16 byte aligned size classes have been handled by</span><span class="comment">		 special code paths at the beginning of heapBitsSetType on 32 bit.</span><span class="comment">		</span><span class="comment">		 Many size classes are only 16 byte aligned. On 64 bit architectures</span><span class="comment">		 this results in a heap bitmap position starting with a h.shift of 2.</span><span class="comment">		</span><span class="comment">		 The bits for the first two words are in a byte shared</span><span class="comment">		 with another object, so we must be careful with the bits</span><span class="comment">		 already there.</span><span class="comment">		</span><span class="comment">		 We took care of 1-word, 2-word, and 3-word objects above,</span><span class="comment">		 so this is at least a 6-word object.</span></div>
<div class="code"><pre><code>		<label for="r195" class="ident">hb</label> = (<label for="r187" class="ident">b</label> &amp; (<a href="#line-55" class="ident">bitPointer</a> | <a href="#line-55" class="ident">bitPointer</a>&lt;&lt;<a href="#line-58" class="ident">heapBitsShift</a>)) &lt;&lt; (<span class="lit-number">2</span> * <a href="#line-58" class="ident">heapBitsShift</a>)
		<label for="r195" class="ident">hb</label> |= <a href="#line-56" class="ident">bitScan</a> &lt;&lt; (<span class="lit-number">2</span> * <a href="#line-58" class="ident">heapBitsShift</a>)
		<span class="keyword">if</span> <label for="r193" class="ident">nw</label> &gt; <span class="lit-number">1</span> {
			<label for="r195" class="ident">hb</label> |= <a href="#line-56" class="ident">bitScan</a> &lt;&lt; (<span class="lit-number">3</span> * <a href="#line-58" class="ident">heapBitsShift</a>)
		}
		<label for="r187" class="ident">b</label> &gt;&gt;= <span class="lit-number">2</span>
		<label for="r188" class="ident">nb</label> -= <span class="lit-number">2</span>
		*<label for="r194" class="ident">hbitp</label> &amp;^= <a href="../../pkg/builtin.html#name-uint8" class="ident">uint8</a>((<a href="#line-55" class="ident">bitPointer</a> | <a href="#line-56" class="ident">bitScan</a> | ((<a href="#line-55" class="ident">bitPointer</a> | <a href="#line-56" class="ident">bitScan</a>) &lt;&lt; <a href="#line-58" class="ident">heapBitsShift</a>)) &lt;&lt; (<span class="lit-number">2</span> * <a href="#line-58" class="ident">heapBitsShift</a>))
		*<label for="r194" class="ident">hbitp</label> |= <a href="../../pkg/builtin.html#name-uint8" class="ident">uint8</a>(<label for="r195" class="ident">hb</label>)
		<label for="r194" class="ident">hbitp</label> = <a href="#line-89" class="ident">add1</a>(<label for="r194" class="ident">hbitp</label>)
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> We know that there is more data, because we handled 2-word and 3-word objects above.</span><span class="comment">			 This must be at least a 6-word object. If we're out of pointer words,</span><span class="comment">			 mark no scan in next bitmap byte and finish.</span></div>
<div class="code"><pre><code>			<label for="r195" class="ident">hb</label> = <span class="lit-number">0</span>
			<label for="r192" class="ident">w</label> += <span class="lit-number">4</span>
			<span class="keyword">goto</span> <label for="r200" class="ident">Phase3</label>
		}
	}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Phase 2: Full bytes in bitmap, up to but not including write to last byte (full or partial) in bitmap.</span><span class="comment">	 The loop computes the bits for that last write but does not execute the write;</span><span class="comment">	 it leaves the bits in hb for processing by phase 3.</span><span class="comment">	 To avoid repeated adjustment of nb, we subtract out the 4 bits we're going to</span><span class="comment">	 use in the first half of the loop right now, and then we only adjust nb explicitly</span><span class="comment">	 if the 8 bits used by each iteration isn't balanced by 8 bits loaded mid-loop.</span></div>
<div class="code"><pre><code>	<label for="r188" class="ident">nb</label> -= <span class="lit-number">4</span>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Emit bitmap byte.</span><span class="comment">		 b has at least nb+4 bits, with one exception:</span><span class="comment">		 if w+4 &gt;= nw, then b has only nw-w bits,</span><span class="comment">		 but we'll stop at the break and then truncate</span><span class="comment">		 appropriately in Phase 3.</span></div>
<div class="code"><pre><code>		<label for="r195" class="ident">hb</label> = <label for="r187" class="ident">b</label> &amp; <a href="#line-63" class="ident">bitPointerAll</a>
		<label for="r195" class="ident">hb</label> |= <a href="#line-62" class="ident">bitScanAll</a>
		<span class="keyword">if</span> <label for="r192" class="ident">w</label> += <span class="lit-number">4</span>; <label for="r192" class="ident">w</label> &gt;= <label for="r193" class="ident">nw</label> {
			<span class="keyword">break</span>
		}
		*<label for="r194" class="ident">hbitp</label> = <a href="../../pkg/builtin.html#name-uint8" class="ident">uint8</a>(<label for="r195" class="ident">hb</label>)
		<label for="r194" class="ident">hbitp</label> = <a href="#line-89" class="ident">add1</a>(<label for="r194" class="ident">hbitp</label>)
		<label for="r187" class="ident">b</label> &gt;&gt;= <span class="lit-number">4</span>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Load more bits. b has nb right now.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Fast path: keep reading from ptrmask.</span><span class="comment">			 nb unmodified: we just loaded 8 bits,</span><span class="comment">			 and the next iteration will consume 8 bits,</span><span class="comment">			 leaving us with the same nb the next time we're here.</span></div>
<div class="code"><pre><code>			<span class="keyword">if</span> <label for="r188" class="ident">nb</label> &lt; <span class="lit-number">8</span> {
				<label for="r187" class="ident">b</label> |= <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(*<label for="r186" class="ident">p</label>) &lt;&lt; <label for="r188" class="ident">nb</label>
				<label for="r186" class="ident">p</label> = <a href="#line-89" class="ident">add1</a>(<label for="r186" class="ident">p</label>)
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Reduce the number of bits in b.</span><span class="comment">				 This is important if we skipped</span><span class="comment">				 over a scalar tail, since nb could</span><span class="comment">				 be larger than the bit width of b.</span></div>
<div class="code"><pre><code>				<label for="r188" class="ident">nb</label> -= <span class="lit-number">8</span>
			}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Almost as fast path: track bit count and refill from pbits.</span><span class="comment">			 For short repetitions.</span></div>
<div class="code"><pre><code>			<span class="keyword">if</span> <label for="r188" class="ident">nb</label> &lt; <span class="lit-number">8</span> {
				<label for="r187" class="ident">b</label> |= <label for="r191" class="ident">pbits</label> &lt;&lt; <label for="r188" class="ident">nb</label>
				<label for="r188" class="ident">nb</label> += <label for="r190" class="ident">endnb</label>
			}
			<label for="r188" class="ident">nb</label> -= <span class="lit-number">8</span> <span class="comment">// for next iteration</span>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Slow path: reached end of ptrmask.</span><span class="comment">			 Process final partial byte and rewind to start.</span></div>
<div class="code"><pre><code>			<label for="r187" class="ident">b</label> |= <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(*<label for="r186" class="ident">p</label>) &lt;&lt; <label for="r188" class="ident">nb</label>
			<label for="r188" class="ident">nb</label> += <label for="r190" class="ident">endnb</label>
			<span class="keyword">if</span> <label for="r188" class="ident">nb</label> &lt; <span class="lit-number">8</span> {
				<label for="r187" class="ident">b</label> |= <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(*<label for="r180" class="ident">ptrmask</label>) &lt;&lt; <label for="r188" class="ident">nb</label>
				<label for="r186" class="ident">p</label> = <a href="#line-89" class="ident">add1</a>(<label for="r180" class="ident">ptrmask</label>)
			} <span class="keyword">else</span> {
				<label for="r188" class="ident">nb</label> -= <span class="lit-number">8</span>
				<label for="r186" class="ident">p</label> = <label for="r180" class="ident">ptrmask</label>
			}
		}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Emit bitmap byte.</span></div>
<div class="code"><pre><code>		<label for="r195" class="ident">hb</label> = <label for="r187" class="ident">b</label> &amp; <a href="#line-63" class="ident">bitPointerAll</a>
		<label for="r195" class="ident">hb</label> |= <a href="#line-62" class="ident">bitScanAll</a>
		<span class="keyword">if</span> <label for="r192" class="ident">w</label> += <span class="lit-number">4</span>; <label for="r192" class="ident">w</label> &gt;= <label for="r193" class="ident">nw</label> {
			<span class="keyword">break</span>
		}
		*<label for="r194" class="ident">hbitp</label> = <a href="../../pkg/builtin.html#name-uint8" class="ident">uint8</a>(<label for="r195" class="ident">hb</label>)
		<label for="r194" class="ident">hbitp</label> = <a href="#line-89" class="ident">add1</a>(<label for="r194" class="ident">hbitp</label>)
		<label for="r187" class="ident">b</label> &gt;&gt;= <span class="lit-number">4</span>
	}

</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Phase 3: Write last byte or partial byte and zero the rest of the bitmap entries.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Counting the 4 entries in hb not yet written to memory,</span><span class="comment">		 there are more entries than possible pointer slots.</span><span class="comment">		 Discard the excess entries (can't be more than 3).</span></div>
<div class="code"><pre><code>		<label for="r201" class="ident">mask</label> := <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<span class="lit-number">1</span>)&lt;&lt;(<span class="lit-number">4</span>-(<label for="r192" class="ident">w</label>-<label for="r193" class="ident">nw</label>)) - <span class="lit-number">1</span>
		<label for="r195" class="ident">hb</label> &amp;= <label for="r201" class="ident">mask</label> | <label for="r201" class="ident">mask</label>&lt;&lt;<span class="lit-number">4</span> <span class="comment">// apply mask to both pointer bits and scan bits</span>
	}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Change nw from counting possibly-pointer words to total words in allocation.</span></div>
<div class="code"><pre><code>	<label for="r193" class="ident">nw</label> = <label for="r171" class="ident">size</label> / <a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Write whole bitmap bytes.</span><span class="comment">	 The first is hb, the rest are zero.</span></div>
<div class="code"><pre><code>	<span class="keyword">if</span> <label for="r192" class="ident">w</label> &lt;= <label for="r193" class="ident">nw</label> {
		*<label for="r194" class="ident">hbitp</label> = <a href="../../pkg/builtin.html#name-uint8" class="ident">uint8</a>(<label for="r195" class="ident">hb</label>)
		<label for="r194" class="ident">hbitp</label> = <a href="#line-89" class="ident">add1</a>(<label for="r194" class="ident">hbitp</label>)
		<label for="r195" class="ident">hb</label> = <span class="lit-number">0</span> <span class="comment">// for possible final half-byte below</span>
		<span class="keyword">for</span> <label for="r192" class="ident">w</label> += <span class="lit-number">4</span>; <label for="r192" class="ident">w</label> &lt;= <label for="r193" class="ident">nw</label>; <label for="r192" class="ident">w</label> += <span class="lit-number">4</span> {
			*<label for="r194" class="ident">hbitp</label> = <span class="lit-number">0</span>
			<label for="r194" class="ident">hbitp</label> = <a href="#line-89" class="ident">add1</a>(<label for="r194" class="ident">hbitp</label>)
		}
	}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Write final partial bitmap byte if any.</span><span class="comment">	 We know w &gt; nw, or else we'd still be in the loop above.</span><span class="comment">	 It can be bigger only due to the 4 entries in hb that it counts.</span><span class="comment">	 If w == nw+4 then there's nothing left to do: we wrote all nw entries</span><span class="comment">	 and can discard the 4 sitting in hb.</span><span class="comment">	 But if w == nw+2, we need to write first two in hb.</span><span class="comment">	 The byte is shared with the next object, so be careful with</span><span class="comment">	 existing bits.</span></div>
<div class="code"><pre><code>	<span class="keyword">if</span> <label for="r192" class="ident">w</label> == <label for="r193" class="ident">nw</label>+<span class="lit-number">2</span> {
		*<label for="r194" class="ident">hbitp</label> = *<label for="r194" class="ident">hbitp</label>&amp;^(<a href="#line-55" class="ident">bitPointer</a>|<a href="#line-56" class="ident">bitScan</a>|(<a href="#line-55" class="ident">bitPointer</a>|<a href="#line-56" class="ident">bitScan</a>)&lt;&lt;<a href="#line-58" class="ident">heapBitsShift</a>) | <a href="../../pkg/builtin.html#name-uint8" class="ident">uint8</a>(<label for="r195" class="ident">hb</label>)
	}

</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Phase 4: Copy unrolled bitmap to per-arena bitmaps, if necessary.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> TODO: We could probably make this faster by</span><span class="comment">		 handling [x+dataSize, x+size) specially.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> cnw is the number of heap words, or bit pairs</span><span class="comment">		 remaining (like nw above).</span></div>
<div class="code"><pre><code>		<label for="r203" class="ident">cnw</label> := <label for="r171" class="ident">size</label> / <a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> We know the first and last byte of the bitmap are</span><span class="comment">		 not the same, but it's still possible for small</span><span class="comment">		 objects span arenas, so it may share bitmap bytes</span><span class="comment">		 with neighboring objects.</span><span class="comment">		</span><span class="comment">		 Handle the first byte specially if it's shared. See</span><span class="comment">		 Phase 1 for why this is the only special case we need.</span></div>
<div class="code"><pre><code>		<span class="keyword">if</span> <label for="r174" class="ident">doubleCheck</label> {
			<span class="keyword">if</span> !(<label for="r202" class="ident">h</label>.<a href="#line-114" class="ident">shift</a> == <span class="lit-number">0</span> || <label for="r202" class="ident">h</label>.<a href="#line-114" class="ident">shift</a> == <span class="lit-number">2</span>) {
				<a href="../../pkg/builtin.html#name-print" class="ident">print</a>(<span class="lit-string">"x="</span>, <label for="r170" class="ident">x</label>, <span class="lit-string">" size="</span>, <label for="r171" class="ident">size</label>, <span class="lit-string">" cnw="</span>, <label for="r202" class="ident">h</label>.<a href="#line-114" class="ident">shift</a>, <span class="lit-string">"\n"</span>)
				<a href="panic.go.html#line-1107" class="ident">throw</a>(<span class="lit-string">"bad start shift"</span>)
			}
		}
		<span class="keyword">if</span> <label for="r202" class="ident">h</label>.<a href="#line-114" class="ident">shift</a> == <span class="lit-number">2</span> {
			*<label for="r202" class="ident">h</label>.<a href="#line-113" class="ident">bitp</a> = *<label for="r202" class="ident">h</label>.<a href="#line-113" class="ident">bitp</a>&amp;^((<a href="#line-55" class="ident">bitPointer</a>|<a href="#line-56" class="ident">bitScan</a>|(<a href="#line-55" class="ident">bitPointer</a>|<a href="#line-56" class="ident">bitScan</a>)&lt;&lt;<a href="#line-58" class="ident">heapBitsShift</a>)&lt;&lt;(<span class="lit-number">2</span>*<a href="#line-58" class="ident">heapBitsShift</a>)) | *<label for="r204" class="ident">src</label>
			<label for="r202" class="ident">h</label> = <label for="r202" class="ident">h</label>.<a href="#line-418" class="ident">next</a>().<a href="#line-418" class="ident">next</a>()
			<label for="r203" class="ident">cnw</label> -= <span class="lit-number">2</span>
			<label for="r204" class="ident">src</label> = <a href="#line-69" class="ident">addb</a>(<label for="r204" class="ident">src</label>, <span class="lit-number">1</span>)
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> We're now byte aligned. Copy out to per-arena</span><span class="comment">		 bitmaps until the last byte (which may again be</span><span class="comment">		 partial).</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> This loop processes four words at a time,</span><span class="comment">			 so round cnw down accordingly.</span></div>
<div class="code"><pre><code>			<label for="r205" class="ident">hNext</label>, <label for="r206" class="ident">words</label> := <label for="r202" class="ident">h</label>.<a href="#line-490" class="ident">forwardOrBoundary</a>(<label for="r203" class="ident">cnw</label> / <span class="lit-number">4</span> * <span class="lit-number">4</span>)
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> n is the number of bitmap bytes to copy.</span></div>
<div class="code"><pre><code>			<label for="r207" class="ident">n</label> := <label for="r206" class="ident">words</label> / <span class="lit-number">4</span>
			<a href="stubs.go.html#line-106" class="ident">memmove</a>(<a href="../../pkg/unsafe.html" class="ident i2">unsafe</a>.<a href="../../pkg/unsafe.html#name-Pointer" class="ident">Pointer</a>(<label for="r202" class="ident">h</label>.<a href="#line-113" class="ident">bitp</a>), <a href="../../pkg/unsafe.html" class="ident i2">unsafe</a>.<a href="../../pkg/unsafe.html#name-Pointer" class="ident">Pointer</a>(<label for="r204" class="ident">src</label>), <label for="r207" class="ident">n</label>)
			<label for="r203" class="ident">cnw</label> -= <label for="r206" class="ident">words</label>
			<label for="r202" class="ident">h</label> = <label for="r205" class="ident">hNext</label>
			<label for="r204" class="ident">src</label> = <a href="#line-69" class="ident">addb</a>(<label for="r204" class="ident">src</label>, <label for="r207" class="ident">n</label>)
		}
		<span class="keyword">if</span> <label for="r174" class="ident">doubleCheck</label> &amp;&amp; <label for="r202" class="ident">h</label>.<a href="#line-114" class="ident">shift</a> != <span class="lit-number">0</span> {
			<a href="../../pkg/builtin.html#name-print" class="ident">print</a>(<span class="lit-string">"cnw="</span>, <label for="r203" class="ident">cnw</label>, <span class="lit-string">" h.shift="</span>, <label for="r202" class="ident">h</label>.<a href="#line-114" class="ident">shift</a>, <span class="lit-string">"\n"</span>)
			<a href="panic.go.html#line-1107" class="ident">throw</a>(<span class="lit-string">"bad shift after block copy"</span>)
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Handle the last byte if it's shared.</span></div>
<div class="code"><pre><code>		<span class="keyword">if</span> <label for="r203" class="ident">cnw</label> == <span class="lit-number">2</span> {
			*<label for="r202" class="ident">h</label>.<a href="#line-113" class="ident">bitp</a> = *<label for="r202" class="ident">h</label>.<a href="#line-113" class="ident">bitp</a>&amp;^(<a href="#line-55" class="ident">bitPointer</a>|<a href="#line-56" class="ident">bitScan</a>|(<a href="#line-55" class="ident">bitPointer</a>|<a href="#line-56" class="ident">bitScan</a>)&lt;&lt;<a href="#line-58" class="ident">heapBitsShift</a>) | *<label for="r204" class="ident">src</label>
			<label for="r204" class="ident">src</label> = <a href="#line-69" class="ident">addb</a>(<label for="r204" class="ident">src</label>, <span class="lit-number">1</span>)
			<label for="r202" class="ident">h</label> = <label for="r202" class="ident">h</label>.<a href="#line-418" class="ident">next</a>().<a href="#line-418" class="ident">next</a>()
		}
		<span class="keyword">if</span> <label for="r174" class="ident">doubleCheck</label> {
			<span class="keyword">if</span> <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<a href="../../pkg/unsafe.html" class="ident i2">unsafe</a>.<a href="../../pkg/unsafe.html#name-Pointer" class="ident">Pointer</a>(<label for="r204" class="ident">src</label>)) &gt; <label for="r170" class="ident">x</label>+<label for="r171" class="ident">size</label> {
				<a href="panic.go.html#line-1107" class="ident">throw</a>(<span class="lit-string">"copy exceeded object size"</span>)
			}
			<span class="keyword">if</span> !(<label for="r203" class="ident">cnw</label> == <span class="lit-number">0</span> || <label for="r203" class="ident">cnw</label> == <span class="lit-number">2</span>) {
				<a href="../../pkg/builtin.html#name-print" class="ident">print</a>(<span class="lit-string">"x="</span>, <label for="r170" class="ident">x</label>, <span class="lit-string">" size="</span>, <label for="r171" class="ident">size</label>, <span class="lit-string">" cnw="</span>, <label for="r203" class="ident">cnw</label>, <span class="lit-string">"\n"</span>)
				<a href="panic.go.html#line-1107" class="ident">throw</a>(<span class="lit-string">"bad number of remaining words"</span>)
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Set up hbitp so doubleCheck code below can check it.</span></div>
<div class="code"><pre><code>			<label for="r194" class="ident">hbitp</label> = <label for="r202" class="ident">h</label>.<a href="#line-113" class="ident">bitp</a>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Zero the object where we wrote the bitmap.</span></div>
<div class="code"><pre><code>		<a href="stubs.go.html#line-86" class="ident">memclrNoHeapPointers</a>(<a href="../../pkg/unsafe.html" class="ident i2">unsafe</a>.<a href="../../pkg/unsafe.html#name-Pointer" class="ident">Pointer</a>(<label for="r170" class="ident">x</label>), <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<a href="../../pkg/unsafe.html" class="ident i2">unsafe</a>.<a href="../../pkg/unsafe.html#name-Pointer" class="ident">Pointer</a>(<label for="r204" class="ident">src</label>))-<label for="r170" class="ident">x</label>)
	}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Double check the whole bitmap.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> x+size may not point to the heap, so back up one</span><span class="comment">		 word and then advance it the way we do above.</span></div>
<div class="code"><pre><code>		<label for="r208" class="ident">end</label> := <a href="#line-308" class="ident">heapBitsForAddr</a>(<label for="r170" class="ident">x</label> + <label for="r171" class="ident">size</label> - <a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a>)
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> In out-of-place copying, we just advance</span><span class="comment">			 using next.</span></div>
<div class="code"><pre><code>			<label for="r208" class="ident">end</label> = <label for="r208" class="ident">end</label>.<a href="#line-418" class="ident">next</a>()
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Don't use next because that may advance to</span><span class="comment">			 the next arena and the in-place logic</span><span class="comment">			 doesn't do that.</span></div>
<div class="code"><pre><code>			<label for="r208" class="ident">end</label>.<a href="#line-114" class="ident">shift</a> += <a href="#line-58" class="ident">heapBitsShift</a>
			<span class="keyword">if</span> <label for="r208" class="ident">end</label>.<a href="#line-114" class="ident">shift</a> == <span class="lit-number">4</span>*<a href="#line-58" class="ident">heapBitsShift</a> {
				<label for="r208" class="ident">end</label>.<a href="#line-113" class="ident">bitp</a>, <label for="r208" class="ident">end</label>.<a href="#line-114" class="ident">shift</a> = <a href="#line-89" class="ident">add1</a>(<label for="r208" class="ident">end</label>.<a href="#line-113" class="ident">bitp</a>), <span class="lit-number">0</span>
			}
		}
		<span class="keyword">if</span> <label for="r173" class="ident">typ</label>.<a href="type.go.html#line-38" class="ident">kind</a>&amp;<a href="typekind.go.html#line-36" class="ident">kindGCProg</a> == <span class="lit-number">0</span> &amp;&amp; (<label for="r194" class="ident">hbitp</label> != <label for="r208" class="ident">end</label>.<a href="#line-113" class="ident">bitp</a> || (<label for="r192" class="ident">w</label> == <label for="r193" class="ident">nw</label>+<span class="lit-number">2</span>) != (<label for="r208" class="ident">end</label>.<a href="#line-114" class="ident">shift</a> == <span class="lit-number">2</span>)) {
			<a href="../../pkg/builtin.html#name-println" class="ident">println</a>(<span class="lit-string">"ended at wrong bitmap byte for"</span>, <label for="r173" class="ident">typ</label>.<a href="type.go.html#line-50" class="ident">string</a>(), <span class="lit-string">"x"</span>, <label for="r172" class="ident">dataSize</label>/<label for="r173" class="ident">typ</label>.<a href="type.go.html#line-32" class="ident">size</a>)
			<a href="../../pkg/builtin.html#name-print" class="ident">print</a>(<span class="lit-string">"typ.size="</span>, <label for="r173" class="ident">typ</label>.<a href="type.go.html#line-32" class="ident">size</a>, <span class="lit-string">" typ.ptrdata="</span>, <label for="r173" class="ident">typ</label>.<a href="type.go.html#line-33" class="ident">ptrdata</a>, <span class="lit-string">" dataSize="</span>, <label for="r172" class="ident">dataSize</label>, <span class="lit-string">" size="</span>, <label for="r171" class="ident">size</label>, <span class="lit-string">"\n"</span>)
			<a href="../../pkg/builtin.html#name-print" class="ident">print</a>(<span class="lit-string">"w="</span>, <label for="r192" class="ident">w</label>, <span class="lit-string">" nw="</span>, <label for="r193" class="ident">nw</label>, <span class="lit-string">" b="</span>, <a href="print.go.html#line-15" class="ident">hex</a>(<label for="r187" class="ident">b</label>), <span class="lit-string">" nb="</span>, <label for="r188" class="ident">nb</label>, <span class="lit-string">" hb="</span>, <a href="print.go.html#line-15" class="ident">hex</a>(<label for="r195" class="ident">hb</label>), <span class="lit-string">"\n"</span>)
			<label for="r209" class="ident">h0</label> := <a href="#line-308" class="ident">heapBitsForAddr</a>(<label for="r170" class="ident">x</label>)
			<a href="../../pkg/builtin.html#name-print" class="ident">print</a>(<span class="lit-string">"initial bits h0.bitp="</span>, <label for="r209" class="ident">h0</label>.<a href="#line-113" class="ident">bitp</a>, <span class="lit-string">" h0.shift="</span>, <label for="r209" class="ident">h0</label>.<a href="#line-114" class="ident">shift</a>, <span class="lit-string">"\n"</span>)
			<a href="../../pkg/builtin.html#name-print" class="ident">print</a>(<span class="lit-string">"ended at hbitp="</span>, <label for="r194" class="ident">hbitp</label>, <span class="lit-string">" but next starts at bitp="</span>, <label for="r208" class="ident">end</label>.<a href="#line-113" class="ident">bitp</a>, <span class="lit-string">" shift="</span>, <label for="r208" class="ident">end</label>.<a href="#line-114" class="ident">shift</a>, <span class="lit-string">"\n"</span>)
			<a href="panic.go.html#line-1107" class="ident">throw</a>(<span class="lit-string">"bad heapBitsSetType"</span>)
		}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Double-check that bits to be written were written correctly.</span><span class="comment">		 Does not check that other bits were not written, unfortunately.</span></div>
<div class="code"><pre><code>		<label for="r210" class="ident">h</label> := <a href="#line-308" class="ident">heapBitsForAddr</a>(<label for="r170" class="ident">x</label>)
		<label for="r211" class="ident">nptr</label> := <label for="r173" class="ident">typ</label>.<a href="type.go.html#line-33" class="ident">ptrdata</a> / <a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a>
		<label for="r212" class="ident">ndata</label> := <label for="r173" class="ident">typ</label>.<a href="type.go.html#line-32" class="ident">size</a> / <a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a>
		<label for="r213" class="ident">count</label> := <label for="r172" class="ident">dataSize</label> / <label for="r173" class="ident">typ</label>.<a href="type.go.html#line-32" class="ident">size</a>
		<label for="r214" class="ident">totalptr</label> := ((<label for="r213" class="ident">count</label>-<span class="lit-number">1</span>)*<label for="r173" class="ident">typ</label>.<a href="type.go.html#line-32" class="ident">size</a> + <label for="r173" class="ident">typ</label>.<a href="type.go.html#line-33" class="ident">ptrdata</a>) / <a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a>
		<span class="keyword">for</span> <label for="r215" class="ident">i</label> := <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<span class="lit-number">0</span>); <label for="r215" class="ident">i</label> &lt; <label for="r171" class="ident">size</label>/<a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a>; <label for="r215" class="ident">i</label>++ {
			<label for="r216" class="ident">j</label> := <label for="r215" class="ident">i</label> % <label for="r212" class="ident">ndata</label>
			<span class="keyword">var</span> <label for="r217" class="ident">have</label>, <label for="r218" class="ident">want</label> <a href="../../pkg/builtin.html#name-uint8" class="ident">uint8</a>
			<label for="r217" class="ident">have</label> = (*<label for="r210" class="ident">h</label>.<a href="#line-113" class="ident">bitp</a> &gt;&gt; <label for="r210" class="ident">h</label>.<a href="#line-114" class="ident">shift</a>) &amp; (<a href="#line-55" class="ident">bitPointer</a> | <a href="#line-56" class="ident">bitScan</a>)
			<span class="keyword">if</span> <label for="r215" class="ident">i</label> &gt;= <label for="r214" class="ident">totalptr</label> {
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> heapBitsSetTypeGCProg always fills</span><span class="comment">					 in full nibbles of bitScan.</span></div>
<div class="code"><pre><code>					<label for="r218" class="ident">want</label> = <a href="#line-56" class="ident">bitScan</a>
				}
			} <span class="keyword">else</span> {
				<span class="keyword">if</span> <label for="r216" class="ident">j</label> &lt; <label for="r211" class="ident">nptr</label> &amp;&amp; (*<a href="#line-69" class="ident">addb</a>(<label for="r180" class="ident">ptrmask</label>, <label for="r216" class="ident">j</label>/<span class="lit-number">8</span>)&gt;&gt;(<label for="r216" class="ident">j</label>%<span class="lit-number">8</span>))&amp;<span class="lit-number">1</span> != <span class="lit-number">0</span> {
					<label for="r218" class="ident">want</label> |= <a href="#line-55" class="ident">bitPointer</a>
				}
				<label for="r218" class="ident">want</label> |= <a href="#line-56" class="ident">bitScan</a>
			}
			<span class="keyword">if</span> <label for="r217" class="ident">have</label> != <label for="r218" class="ident">want</label> {
				<a href="../../pkg/builtin.html#name-println" class="ident">println</a>(<span class="lit-string">"mismatch writing bits for"</span>, <label for="r173" class="ident">typ</label>.<a href="type.go.html#line-50" class="ident">string</a>(), <span class="lit-string">"x"</span>, <label for="r172" class="ident">dataSize</label>/<label for="r173" class="ident">typ</label>.<a href="type.go.html#line-32" class="ident">size</a>)
				<a href="../../pkg/builtin.html#name-print" class="ident">print</a>(<span class="lit-string">"typ.size="</span>, <label for="r173" class="ident">typ</label>.<a href="type.go.html#line-32" class="ident">size</a>, <span class="lit-string">" typ.ptrdata="</span>, <label for="r173" class="ident">typ</label>.<a href="type.go.html#line-33" class="ident">ptrdata</a>, <span class="lit-string">" dataSize="</span>, <label for="r172" class="ident">dataSize</label>, <span class="lit-string">" size="</span>, <label for="r171" class="ident">size</label>, <span class="lit-string">"\n"</span>)
				<a href="../../pkg/builtin.html#name-print" class="ident">print</a>(<span class="lit-string">"kindGCProg="</span>, <label for="r173" class="ident">typ</label>.<a href="type.go.html#line-38" class="ident">kind</a>&amp;<a href="typekind.go.html#line-36" class="ident">kindGCProg</a> != <span class="lit-number">0</span>, <span class="lit-string">" outOfPlace="</span>, <label for="r185" class="ident">outOfPlace</label>, <span class="lit-string">"\n"</span>)
				<a href="../../pkg/builtin.html#name-print" class="ident">print</a>(<span class="lit-string">"w="</span>, <label for="r192" class="ident">w</label>, <span class="lit-string">" nw="</span>, <label for="r193" class="ident">nw</label>, <span class="lit-string">" b="</span>, <a href="print.go.html#line-15" class="ident">hex</a>(<label for="r187" class="ident">b</label>), <span class="lit-string">" nb="</span>, <label for="r188" class="ident">nb</label>, <span class="lit-string">" hb="</span>, <a href="print.go.html#line-15" class="ident">hex</a>(<label for="r195" class="ident">hb</label>), <span class="lit-string">"\n"</span>)
				<label for="r219" class="ident">h0</label> := <a href="#line-308" class="ident">heapBitsForAddr</a>(<label for="r170" class="ident">x</label>)
				<a href="../../pkg/builtin.html#name-print" class="ident">print</a>(<span class="lit-string">"initial bits h0.bitp="</span>, <label for="r219" class="ident">h0</label>.<a href="#line-113" class="ident">bitp</a>, <span class="lit-string">" h0.shift="</span>, <label for="r219" class="ident">h0</label>.<a href="#line-114" class="ident">shift</a>, <span class="lit-string">"\n"</span>)
				<a href="../../pkg/builtin.html#name-print" class="ident">print</a>(<span class="lit-string">"current bits h.bitp="</span>, <label for="r210" class="ident">h</label>.<a href="#line-113" class="ident">bitp</a>, <span class="lit-string">" h.shift="</span>, <label for="r210" class="ident">h</label>.<a href="#line-114" class="ident">shift</a>, <span class="lit-string">" *h.bitp="</span>, <a href="print.go.html#line-15" class="ident">hex</a>(*<label for="r210" class="ident">h</label>.<a href="#line-113" class="ident">bitp</a>), <span class="lit-string">"\n"</span>)
				<a href="../../pkg/builtin.html#name-print" class="ident">print</a>(<span class="lit-string">"ptrmask="</span>, <label for="r180" class="ident">ptrmask</label>, <span class="lit-string">" p="</span>, <label for="r186" class="ident">p</label>, <span class="lit-string">" endp="</span>, <label for="r189" class="ident">endp</label>, <span class="lit-string">" endnb="</span>, <label for="r190" class="ident">endnb</label>, <span class="lit-string">" pbits="</span>, <a href="print.go.html#line-15" class="ident">hex</a>(<label for="r191" class="ident">pbits</label>), <span class="lit-string">" b="</span>, <a href="print.go.html#line-15" class="ident">hex</a>(<label for="r187" class="ident">b</label>), <span class="lit-string">" nb="</span>, <label for="r188" class="ident">nb</label>, <span class="lit-string">"\n"</span>)
				<a href="../../pkg/builtin.html#name-println" class="ident">println</a>(<span class="lit-string">"at word"</span>, <label for="r215" class="ident">i</label>, <span class="lit-string">"offset"</span>, <label for="r215" class="ident">i</label>*<a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a>, <span class="lit-string">"have"</span>, <a href="print.go.html#line-15" class="ident">hex</a>(<label for="r217" class="ident">have</label>), <span class="lit-string">"want"</span>, <a href="print.go.html#line-15" class="ident">hex</a>(<label for="r218" class="ident">want</label>))
				<span class="keyword">if</span> <label for="r173" class="ident">typ</label>.<a href="type.go.html#line-38" class="ident">kind</a>&amp;<a href="typekind.go.html#line-36" class="ident">kindGCProg</a> != <span class="lit-number">0</span> {
					<a href="../../pkg/builtin.html#name-println" class="ident">println</a>(<span class="lit-string">"GC program:"</span>)
					<a href="#line-1879" class="ident">dumpGCProg</a>(<a href="#line-69" class="ident">addb</a>(<label for="r173" class="ident">typ</label>.<a href="type.go.html#line-45" class="ident">gcdata</a>, <span class="lit-number">4</span>))
				}
				<a href="panic.go.html#line-1107" class="ident">throw</a>(<span class="lit-string">"bad heapBitsSetType"</span>)
			}
			<label for="r210" class="ident">h</label> = <label for="r210" class="ident">h</label>.<a href="#line-418" class="ident">next</a>()
		}
		<span class="keyword">if</span> <label for="r180" class="ident">ptrmask</label> == <a href="#line-1457" class="ident">debugPtrmask</a>.<a href="#line-1459" class="ident">data</a> {
			<a href="lock_sema.go.html#line-96" class="ident">unlock</a>(&amp;<a href="#line-1457" class="ident">debugPtrmask</a>.<a href="#line-1458" class="ident">lock</a>)
		}
	}
}

<span class="keyword">var</span> <a href="../../pkg/runtime.html#name-debugPtrmask" class="ident">debugPtrmask</a> <span class="keyword">struct</span> {
	lock <a href="runtime2.go.html#line-162" class="ident">mutex</a>
	data *<a href="../../pkg/builtin.html#name-byte" class="ident">byte</a>
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> heapBitsSetTypeGCProg implements heapBitsSetType using a GC program.</span><span class="comment"> progSize is the size of the memory described by the program.</span><span class="comment"> elemSize is the size of the element that the GC program describes (a prefix of).</span><span class="comment"> dataSize is the total size of the intended data, a multiple of elemSize.</span><span class="comment"> allocSize is the total size of the allocated memory.</span><span class="comment"></span><span class="comment"> GC programs are only used for large allocations.</span><span class="comment"> heapBitsSetType requires that allocSize is a multiple of 4 words,</span><span class="comment"> so that the relevant bitmap bytes are not shared with surrounding</span><span class="comment"> objects.</span></div>
<div class="code"><pre><code><span class="keyword">func</span> <label for="r220" class="ident"><a href="../../pkg/runtime.html#name-heapBitsSetTypeGCProg" class="ident">heapBitsSetTypeGCProg</a></label>(<label for="r221" class="ident">h</label> <a href="#line-112" class="ident">heapBits</a>, <label for="r222" class="ident">progSize</label>, <label for="r223" class="ident">elemSize</label>, <label for="r224" class="ident">dataSize</label>, <label for="r225" class="ident">allocSize</label> <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>, <label for="r226" class="ident">prog</label> *<a href="../../pkg/builtin.html#name-byte" class="ident">byte</a>) {
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Alignment will be wrong.</span></div>
<div class="code"><pre><code>		<a href="panic.go.html#line-1107" class="ident">throw</a>(<span class="lit-string">"heapBitsSetTypeGCProg: small allocation"</span>)
	}
	<span class="keyword">var</span> <label for="r227" class="ident">totalBits</label> <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>
	<span class="keyword">if</span> <label for="r223" class="ident">elemSize</label> == <label for="r224" class="ident">dataSize</label> {
		<label for="r227" class="ident">totalBits</label> = <a href="#line-1584" class="ident">runGCProg</a>(<label for="r226" class="ident">prog</label>, <a href="../../pkg/builtin.html#name-nil" class="ident">nil</a>, <label for="r221" class="ident">h</label>.<a href="#line-113" class="ident">bitp</a>, <span class="lit-number">2</span>)
		<span class="keyword">if</span> <label for="r227" class="ident">totalBits</label>*<a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a> != <label for="r222" class="ident">progSize</label> {
			<a href="../../pkg/builtin.html#name-println" class="ident">println</a>(<span class="lit-string">"runtime: heapBitsSetTypeGCProg: total bits"</span>, <label for="r227" class="ident">totalBits</label>, <span class="lit-string">"but progSize"</span>, <label for="r222" class="ident">progSize</label>)
			<a href="panic.go.html#line-1107" class="ident">throw</a>(<span class="lit-string">"heapBitsSetTypeGCProg: unexpected bit count"</span>)
		}
	} <span class="keyword">else</span> {
		<label for="r228" class="ident">count</label> := <label for="r224" class="ident">dataSize</label> / <label for="r223" class="ident">elemSize</label>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Piece together program trailer to run after prog that does:</span><span class="comment">			literal(0)</span><span class="comment">			repeat(1, elemSize-progSize-1) // zeros to fill element size</span><span class="comment">			repeat(elemSize, count-1) // repeat that element for count</span><span class="comment">		 This zero-pads the data remaining in the first element and then</span><span class="comment">		 repeats that first element to fill the array.</span></div>
<div class="code"><pre><code>		<span class="keyword">var</span> <label for="r229" class="ident">trailer</label> [<span class="lit-number">40</span>]<a href="../../pkg/builtin.html#name-byte" class="ident">byte</a> <span class="comment">// 3 varints (max 10 each) + some bytes</span>
		<label for="r230" class="ident">i</label> := <span class="lit-number">0</span>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> literal(0)</span></div>
<div class="code"><pre><code>			<label for="r229" class="ident">trailer</label>[<label for="r230" class="ident">i</label>] = <span class="lit-number">0x01</span>
			<label for="r230" class="ident">i</label>++
			<label for="r229" class="ident">trailer</label>[<label for="r230" class="ident">i</label>] = <span class="lit-number">0</span>
			<label for="r230" class="ident">i</label>++
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> repeat(1, n-1)</span></div>
<div class="code"><pre><code>				<label for="r229" class="ident">trailer</label>[<label for="r230" class="ident">i</label>] = <span class="lit-number">0x81</span>
				<label for="r230" class="ident">i</label>++
				<label for="r231" class="ident">n</label>--
				<span class="keyword">for</span> ; <label for="r231" class="ident">n</label> &gt;= <span class="lit-number">0x80</span>; <label for="r231" class="ident">n</label> &gt;&gt;= <span class="lit-number">7</span> {
					<label for="r229" class="ident">trailer</label>[<label for="r230" class="ident">i</label>] = <a href="../../pkg/builtin.html#name-byte" class="ident">byte</a>(<label for="r231" class="ident">n</label> | <span class="lit-number">0x80</span>)
					<label for="r230" class="ident">i</label>++
				}
				<label for="r229" class="ident">trailer</label>[<label for="r230" class="ident">i</label>] = <a href="../../pkg/builtin.html#name-byte" class="ident">byte</a>(<label for="r231" class="ident">n</label>)
				<label for="r230" class="ident">i</label>++
			}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> repeat(elemSize/ptrSize, count-1)</span></div>
<div class="code"><pre><code>		<label for="r229" class="ident">trailer</label>[<label for="r230" class="ident">i</label>] = <span class="lit-number">0x80</span>
		<label for="r230" class="ident">i</label>++
		<label for="r232" class="ident">n</label> := <label for="r223" class="ident">elemSize</label> / <a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a>
		<span class="keyword">for</span> ; <label for="r232" class="ident">n</label> &gt;= <span class="lit-number">0x80</span>; <label for="r232" class="ident">n</label> &gt;&gt;= <span class="lit-number">7</span> {
			<label for="r229" class="ident">trailer</label>[<label for="r230" class="ident">i</label>] = <a href="../../pkg/builtin.html#name-byte" class="ident">byte</a>(<label for="r232" class="ident">n</label> | <span class="lit-number">0x80</span>)
			<label for="r230" class="ident">i</label>++
		}
		<label for="r229" class="ident">trailer</label>[<label for="r230" class="ident">i</label>] = <a href="../../pkg/builtin.html#name-byte" class="ident">byte</a>(<label for="r232" class="ident">n</label>)
		<label for="r230" class="ident">i</label>++
		<label for="r232" class="ident">n</label> = <label for="r228" class="ident">count</label> - <span class="lit-number">1</span>
		<span class="keyword">for</span> ; <label for="r232" class="ident">n</label> &gt;= <span class="lit-number">0x80</span>; <label for="r232" class="ident">n</label> &gt;&gt;= <span class="lit-number">7</span> {
			<label for="r229" class="ident">trailer</label>[<label for="r230" class="ident">i</label>] = <a href="../../pkg/builtin.html#name-byte" class="ident">byte</a>(<label for="r232" class="ident">n</label> | <span class="lit-number">0x80</span>)
			<label for="r230" class="ident">i</label>++
		}
		<label for="r229" class="ident">trailer</label>[<label for="r230" class="ident">i</label>] = <a href="../../pkg/builtin.html#name-byte" class="ident">byte</a>(<label for="r232" class="ident">n</label>)
		<label for="r230" class="ident">i</label>++
		<label for="r229" class="ident">trailer</label>[<label for="r230" class="ident">i</label>] = <span class="lit-number">0</span>
		<label for="r230" class="ident">i</label>++

		<a href="#line-1584" class="ident">runGCProg</a>(<label for="r226" class="ident">prog</label>, &amp;<label for="r229" class="ident">trailer</label>[<span class="lit-number">0</span>], <label for="r221" class="ident">h</label>.<a href="#line-113" class="ident">bitp</a>, <span class="lit-number">2</span>)
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Even though we filled in the full array just now,</span><span class="comment">		 record that we only filled in up to the ptrdata of the</span><span class="comment">		 last element. This will cause the code below to</span><span class="comment">		 memclr the dead section of the final array element,</span><span class="comment">		 so that scanobject can stop early in the final element.</span></div>
<div class="code"><pre><code>		<label for="r227" class="ident">totalBits</label> = (<label for="r223" class="ident">elemSize</label>*(<label for="r228" class="ident">count</label>-<span class="lit-number">1</span>) + <label for="r222" class="ident">progSize</label>) / <a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a>
	}
	<label for="r233" class="ident">endProg</label> := <a href="../../pkg/unsafe.html" class="ident i2">unsafe</a>.<a href="../../pkg/unsafe.html#name-Pointer" class="ident">Pointer</a>(<a href="#line-69" class="ident">addb</a>(<label for="r221" class="ident">h</label>.<a href="#line-113" class="ident">bitp</a>, (<label for="r227" class="ident">totalBits</label>+<span class="lit-number">3</span>)/<span class="lit-number">4</span>))
	<label for="r234" class="ident">endAlloc</label> := <a href="../../pkg/unsafe.html" class="ident i2">unsafe</a>.<a href="../../pkg/unsafe.html#name-Pointer" class="ident">Pointer</a>(<a href="#line-69" class="ident">addb</a>(<label for="r221" class="ident">h</label>.<a href="#line-113" class="ident">bitp</a>, <label for="r225" class="ident">allocSize</label>/<a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a>/<a href="#line-59" class="ident">wordsPerBitmapByte</a>))
	<a href="stubs.go.html#line-86" class="ident">memclrNoHeapPointers</a>(<label for="r233" class="ident">endProg</label>, <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<label for="r234" class="ident">endAlloc</label>)-<a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<label for="r233" class="ident">endProg</label>))
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> progToPointerMask returns the 1-bit pointer mask output by the GC program prog.</span><span class="comment"> size the size of the region described by prog, in bytes.</span><span class="comment"> The resulting bitvector will have no more than size/sys.PtrSize bits.</span></div>
<div class="code"><pre><code><span class="keyword">func</span> <label for="r235" class="ident"><a href="../../pkg/runtime.html#name-progToPointerMask" class="ident">progToPointerMask</a></label>(<label for="r236" class="ident">prog</label> *<a href="../../pkg/builtin.html#name-byte" class="ident">byte</a>, <label for="r237" class="ident">size</label> <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>) <a href="stack.go.html#line-562" class="ident">bitvector</a> {
	<label for="r238" class="ident">n</label> := (<label for="r237" class="ident">size</label>/<a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a> + <span class="lit-number">7</span>) / <span class="lit-number">8</span>
	<label for="r239" class="ident">x</label> := (*[<span class="lit-number">1</span> &lt;&lt; <span class="lit-number">30</span>]<a href="../../pkg/builtin.html#name-byte" class="ident">byte</a>)(<a href="malloc.go.html#line-1311" class="ident">persistentalloc</a>(<label for="r238" class="ident">n</label>+<span class="lit-number">1</span>, <span class="lit-number">1</span>, &amp;<a href="mstats.go.html#line-170" class="ident">memstats</a>.<a href="mstats.go.html#line-53" class="ident">buckhash_sys</a>))[:<label for="r238" class="ident">n</label>+<span class="lit-number">1</span>]
	<label for="r239" class="ident">x</label>[<a href="../../pkg/builtin.html#name-len" class="ident">len</a>(<label for="r239" class="ident">x</label>)-<span class="lit-number">1</span>] = <span class="lit-number">0xa1</span> <span class="comment">// overflow check sentinel</span>
	<label for="r238" class="ident">n</label> = <a href="#line-1584" class="ident">runGCProg</a>(<label for="r236" class="ident">prog</label>, <a href="../../pkg/builtin.html#name-nil" class="ident">nil</a>, &amp;<label for="r239" class="ident">x</label>[<span class="lit-number">0</span>], <span class="lit-number">1</span>)
	<span class="keyword">if</span> <label for="r239" class="ident">x</label>[<a href="../../pkg/builtin.html#name-len" class="ident">len</a>(<label for="r239" class="ident">x</label>)-<span class="lit-number">1</span>] != <span class="lit-number">0xa1</span> {
		<a href="panic.go.html#line-1107" class="ident">throw</a>(<span class="lit-string">"progToPointerMask: overflow"</span>)
	}
	<span class="keyword">return</span> <a href="stack.go.html#line-562" class="ident">bitvector</a>{<a href="../../pkg/builtin.html#name-int32" class="ident">int32</a>(<label for="r238" class="ident">n</label>), &amp;<label for="r239" class="ident">x</label>[<span class="lit-number">0</span>]}
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Packed GC pointer bitmaps, aka GC programs.</span><span class="comment"></span><span class="comment"> For large types containing arrays, the type information has a</span><span class="comment"> natural repetition that can be encoded to save space in the</span><span class="comment"> binary and in the memory representation of the type information.</span><span class="comment"></span><span class="comment"> The encoding is a simple Lempel-Ziv style bytecode machine</span><span class="comment"> with the following instructions:</span><span class="comment"></span><span class="comment">	00000000: stop</span><span class="comment">	0nnnnnnn: emit n bits copied from the next (n+7)/8 bytes</span><span class="comment">	10000000 n c: repeat the previous n bits c times; n, c are varints</span><span class="comment">	1nnnnnnn c: repeat the previous n bits c times; c is a varint</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> runGCProg executes the GC program prog, and then trailer if non-nil,</span><span class="comment"> writing to dst with entries of the given size.</span><span class="comment"> If size == 1, dst is a 1-bit pointer mask laid out moving forward from dst.</span><span class="comment"> If size == 2, dst is the 2-bit heap bitmap, and writes move backward</span><span class="comment"> starting at dst (because the heap bitmap does). In this case, the caller guarantees</span><span class="comment"> that only whole bytes in dst need to be written.</span><span class="comment"></span><span class="comment"> runGCProg returns the number of 1- or 2-bit entries written to memory.</span></div>
<div class="code"><pre><code><span class="keyword">func</span> <label for="r240" class="ident"><a href="../../pkg/runtime.html#name-runGCProg" class="ident">runGCProg</a></label>(<label for="r241" class="ident">prog</label>, <label for="r242" class="ident">trailer</label>, <label for="r243" class="ident">dst</label> *<a href="../../pkg/builtin.html#name-byte" class="ident">byte</a>, <label for="r244" class="ident">size</label> <a href="../../pkg/builtin.html#name-int" class="ident">int</a>) <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a> {
	<label for="r245" class="ident">dstStart</label> := <label for="r243" class="ident">dst</label>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Bits waiting to be written to memory.</span></div>
<div class="code"><pre><code>	<span class="keyword">var</span> <label for="r246" class="ident">bits</label> <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>
	<span class="keyword">var</span> <label for="r247" class="ident">nbits</label> <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>

	<label for="r248" class="ident">p</label> := <label for="r241" class="ident">prog</label>
<label for="r249" class="ident">Run</label>:
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Flush accumulated full bytes.</span><span class="comment">		 The rest of the loop assumes that nbits &lt;= 7.</span></div>
<div class="code"><pre><code>		<span class="keyword">for</span> ; <label for="r247" class="ident">nbits</label> &gt;= <span class="lit-number">8</span>; <label for="r247" class="ident">nbits</label> -= <span class="lit-number">8</span> {
			<span class="keyword">if</span> <label for="r244" class="ident">size</label> == <span class="lit-number">1</span> {
				*<label for="r243" class="ident">dst</label> = <a href="../../pkg/builtin.html#name-uint8" class="ident">uint8</a>(<label for="r246" class="ident">bits</label>)
				<label for="r243" class="ident">dst</label> = <a href="#line-89" class="ident">add1</a>(<label for="r243" class="ident">dst</label>)
				<label for="r246" class="ident">bits</label> &gt;&gt;= <span class="lit-number">8</span>
			} <span class="keyword">else</span> {
				<label for="r250" class="ident">v</label> := <label for="r246" class="ident">bits</label>&amp;<a href="#line-63" class="ident">bitPointerAll</a> | <a href="#line-62" class="ident">bitScanAll</a>
				*<label for="r243" class="ident">dst</label> = <a href="../../pkg/builtin.html#name-uint8" class="ident">uint8</a>(<label for="r250" class="ident">v</label>)
				<label for="r243" class="ident">dst</label> = <a href="#line-89" class="ident">add1</a>(<label for="r243" class="ident">dst</label>)
				<label for="r246" class="ident">bits</label> &gt;&gt;= <span class="lit-number">4</span>
				<label for="r250" class="ident">v</label> = <label for="r246" class="ident">bits</label>&amp;<a href="#line-63" class="ident">bitPointerAll</a> | <a href="#line-62" class="ident">bitScanAll</a>
				*<label for="r243" class="ident">dst</label> = <a href="../../pkg/builtin.html#name-uint8" class="ident">uint8</a>(<label for="r250" class="ident">v</label>)
				<label for="r243" class="ident">dst</label> = <a href="#line-89" class="ident">add1</a>(<label for="r243" class="ident">dst</label>)
				<label for="r246" class="ident">bits</label> &gt;&gt;= <span class="lit-number">4</span>
			}
		}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Process one instruction.</span></div>
<div class="code"><pre><code>		<label for="r251" class="ident">inst</label> := <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(*<label for="r248" class="ident">p</label>)
		<label for="r248" class="ident">p</label> = <a href="#line-89" class="ident">add1</a>(<label for="r248" class="ident">p</label>)
		<label for="r252" class="ident">n</label> := <label for="r251" class="ident">inst</label> &amp; <span class="lit-number">0x7F</span>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Literal bits; n == 0 means end of program.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Program is over; continue in trailer if present.</span></div>
<div class="code"><pre><code>				<span class="keyword">if</span> <label for="r242" class="ident">trailer</label> != <a href="../../pkg/builtin.html#name-nil" class="ident">nil</a> {
					<label for="r248" class="ident">p</label> = <label for="r242" class="ident">trailer</label>
					<label for="r242" class="ident">trailer</label> = <a href="../../pkg/builtin.html#name-nil" class="ident">nil</a>
					<span class="keyword">continue</span>
				}
				<span class="keyword">break</span> <label for="r249" class="ident">Run</label>
			}
			<label for="r253" class="ident">nbyte</label> := <label for="r252" class="ident">n</label> / <span class="lit-number">8</span>
			<span class="keyword">for</span> <label for="r254" class="ident">i</label> := <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<span class="lit-number">0</span>); <label for="r254" class="ident">i</label> &lt; <label for="r253" class="ident">nbyte</label>; <label for="r254" class="ident">i</label>++ {
				<label for="r246" class="ident">bits</label> |= <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(*<label for="r248" class="ident">p</label>) &lt;&lt; <label for="r247" class="ident">nbits</label>
				<label for="r248" class="ident">p</label> = <a href="#line-89" class="ident">add1</a>(<label for="r248" class="ident">p</label>)
				<span class="keyword">if</span> <label for="r244" class="ident">size</label> == <span class="lit-number">1</span> {
					*<label for="r243" class="ident">dst</label> = <a href="../../pkg/builtin.html#name-uint8" class="ident">uint8</a>(<label for="r246" class="ident">bits</label>)
					<label for="r243" class="ident">dst</label> = <a href="#line-89" class="ident">add1</a>(<label for="r243" class="ident">dst</label>)
					<label for="r246" class="ident">bits</label> &gt;&gt;= <span class="lit-number">8</span>
				} <span class="keyword">else</span> {
					<label for="r255" class="ident">v</label> := <label for="r246" class="ident">bits</label>&amp;<span class="lit-number">0xf</span> | <a href="#line-62" class="ident">bitScanAll</a>
					*<label for="r243" class="ident">dst</label> = <a href="../../pkg/builtin.html#name-uint8" class="ident">uint8</a>(<label for="r255" class="ident">v</label>)
					<label for="r243" class="ident">dst</label> = <a href="#line-89" class="ident">add1</a>(<label for="r243" class="ident">dst</label>)
					<label for="r246" class="ident">bits</label> &gt;&gt;= <span class="lit-number">4</span>
					<label for="r255" class="ident">v</label> = <label for="r246" class="ident">bits</label>&amp;<span class="lit-number">0xf</span> | <a href="#line-62" class="ident">bitScanAll</a>
					*<label for="r243" class="ident">dst</label> = <a href="../../pkg/builtin.html#name-uint8" class="ident">uint8</a>(<label for="r255" class="ident">v</label>)
					<label for="r243" class="ident">dst</label> = <a href="#line-89" class="ident">add1</a>(<label for="r243" class="ident">dst</label>)
					<label for="r246" class="ident">bits</label> &gt;&gt;= <span class="lit-number">4</span>
				}
			}
			<span class="keyword">if</span> <label for="r252" class="ident">n</label> %= <span class="lit-number">8</span>; <label for="r252" class="ident">n</label> &gt; <span class="lit-number">0</span> {
				<label for="r246" class="ident">bits</label> |= <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(*<label for="r248" class="ident">p</label>) &lt;&lt; <label for="r247" class="ident">nbits</label>
				<label for="r248" class="ident">p</label> = <a href="#line-89" class="ident">add1</a>(<label for="r248" class="ident">p</label>)
				<label for="r247" class="ident">nbits</label> += <label for="r252" class="ident">n</label>
			}
			<span class="keyword">continue</span> <label for="r249" class="ident">Run</label>
		}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Repeat. If n == 0, it is encoded in a varint in the next bytes.</span></div>
<div class="code"><pre><code>		<span class="keyword">if</span> <label for="r252" class="ident">n</label> == <span class="lit-number">0</span> {
			<span class="keyword">for</span> <label for="r256" class="ident">off</label> := <a href="../../pkg/builtin.html#name-uint" class="ident">uint</a>(<span class="lit-number">0</span>); ; <label for="r256" class="ident">off</label> += <span class="lit-number">7</span> {
				<label for="r257" class="ident">x</label> := <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(*<label for="r248" class="ident">p</label>)
				<label for="r248" class="ident">p</label> = <a href="#line-89" class="ident">add1</a>(<label for="r248" class="ident">p</label>)
				<label for="r252" class="ident">n</label> |= (<label for="r257" class="ident">x</label> &amp; <span class="lit-number">0x7F</span>) &lt;&lt; <label for="r256" class="ident">off</label>
				<span class="keyword">if</span> <label for="r257" class="ident">x</label>&amp;<span class="lit-number">0x80</span> == <span class="lit-number">0</span> {
					<span class="keyword">break</span>
				}
			}
		}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Count is encoded in a varint in the next bytes.</span></div>
<div class="code"><pre><code>		<label for="r258" class="ident">c</label> := <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<span class="lit-number">0</span>)
		<span class="keyword">for</span> <label for="r259" class="ident">off</label> := <a href="../../pkg/builtin.html#name-uint" class="ident">uint</a>(<span class="lit-number">0</span>); ; <label for="r259" class="ident">off</label> += <span class="lit-number">7</span> {
			<label for="r260" class="ident">x</label> := <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(*<label for="r248" class="ident">p</label>)
			<label for="r248" class="ident">p</label> = <a href="#line-89" class="ident">add1</a>(<label for="r248" class="ident">p</label>)
			<label for="r258" class="ident">c</label> |= (<label for="r260" class="ident">x</label> &amp; <span class="lit-number">0x7F</span>) &lt;&lt; <label for="r259" class="ident">off</label>
			<span class="keyword">if</span> <label for="r260" class="ident">x</label>&amp;<span class="lit-number">0x80</span> == <span class="lit-number">0</span> {
				<span class="keyword">break</span>
			}
		}
		<label for="r258" class="ident">c</label> *= <label for="r252" class="ident">n</label> <span class="comment">// now total number of bits to copy</span>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> If the number of bits being repeated is small, load them</span><span class="comment">		 into a register and use that register for the entire loop</span><span class="comment">		 instead of repeatedly reading from memory.</span><span class="comment">		 Handling fewer than 8 bits here makes the general loop simpler.</span><span class="comment">		 The cutoff is sys.PtrSize*8 - 7 to guarantee that when we add</span><span class="comment">		 the pattern to a bit buffer holding at most 7 bits (a partial byte)</span><span class="comment">		 it will not overflow.</span></div>
<div class="code"><pre><code>		<label for="r261" class="ident">src</label> := <label for="r243" class="ident">dst</label>
		<span class="keyword">const</span> <label for="r262" class="ident">maxBits</label> = <a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a>*<span class="lit-number">8</span> - <span class="lit-number">7</span>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Start with bits in output buffer.</span></div>
<div class="code"><pre><code>			<label for="r263" class="ident">pattern</label> := <label for="r246" class="ident">bits</label>
			<label for="r264" class="ident">npattern</label> := <label for="r247" class="ident">nbits</label>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> If we need more bits, fetch them from memory.</span></div>
<div class="code"><pre><code>			<span class="keyword">if</span> <label for="r244" class="ident">size</label> == <span class="lit-number">1</span> {
				<label for="r261" class="ident">src</label> = <a href="#line-101" class="ident">subtract1</a>(<label for="r261" class="ident">src</label>)
				<span class="keyword">for</span> <label for="r264" class="ident">npattern</label> &lt; <label for="r252" class="ident">n</label> {
					<label for="r263" class="ident">pattern</label> &lt;&lt;= <span class="lit-number">8</span>
					<label for="r263" class="ident">pattern</label> |= <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(*<label for="r261" class="ident">src</label>)
					<label for="r261" class="ident">src</label> = <a href="#line-101" class="ident">subtract1</a>(<label for="r261" class="ident">src</label>)
					<label for="r264" class="ident">npattern</label> += <span class="lit-number">8</span>
				}
			} <span class="keyword">else</span> {
				<label for="r261" class="ident">src</label> = <a href="#line-101" class="ident">subtract1</a>(<label for="r261" class="ident">src</label>)
				<span class="keyword">for</span> <label for="r264" class="ident">npattern</label> &lt; <label for="r252" class="ident">n</label> {
					<label for="r263" class="ident">pattern</label> &lt;&lt;= <span class="lit-number">4</span>
					<label for="r263" class="ident">pattern</label> |= <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(*<label for="r261" class="ident">src</label>) &amp; <span class="lit-number">0xf</span>
					<label for="r261" class="ident">src</label> = <a href="#line-101" class="ident">subtract1</a>(<label for="r261" class="ident">src</label>)
					<label for="r264" class="ident">npattern</label> += <span class="lit-number">4</span>
				}
			}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> We started with the whole bit output buffer,</span><span class="comment">			 and then we loaded bits from whole bytes.</span><span class="comment">			 Either way, we might now have too many instead of too few.</span><span class="comment">			 Discard the extra.</span></div>
<div class="code"><pre><code>			<span class="keyword">if</span> <label for="r264" class="ident">npattern</label> &gt; <label for="r252" class="ident">n</label> {
				<label for="r263" class="ident">pattern</label> &gt;&gt;= <label for="r264" class="ident">npattern</label> - <label for="r252" class="ident">n</label>
				<label for="r264" class="ident">npattern</label> = <label for="r252" class="ident">n</label>
			}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Replicate pattern to at most maxBits.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> One bit being repeated.</span><span class="comment">				 If the bit is 1, make the pattern all 1s.</span><span class="comment">				 If the bit is 0, the pattern is already all 0s,</span><span class="comment">				 but we can claim that the number of bits</span><span class="comment">				 in the word is equal to the number we need (c),</span><span class="comment">				 because right shift of bits will zero fill.</span></div>
<div class="code"><pre><code>				<span class="keyword">if</span> <label for="r263" class="ident">pattern</label> == <span class="lit-number">1</span> {
					<label for="r263" class="ident">pattern</label> = <span class="lit-number">1</span>&lt;&lt;<label for="r262" class="ident">maxBits</label> - <span class="lit-number">1</span>
					<label for="r264" class="ident">npattern</label> = <label for="r262" class="ident">maxBits</label>
				} <span class="keyword">else</span> {
					<label for="r264" class="ident">npattern</label> = <label for="r258" class="ident">c</label>
				}
			} <span class="keyword">else</span> {
				<label for="r265" class="ident">b</label> := <label for="r263" class="ident">pattern</label>
				<label for="r266" class="ident">nb</label> := <label for="r264" class="ident">npattern</label>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Double pattern until the whole uintptr is filled.</span></div>
<div class="code"><pre><code>					<span class="keyword">for</span> <label for="r266" class="ident">nb</label> &lt;= <a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a>*<span class="lit-number">8</span> {
						<label for="r265" class="ident">b</label> |= <label for="r265" class="ident">b</label> &lt;&lt; <label for="r266" class="ident">nb</label>
						<label for="r266" class="ident">nb</label> += <label for="r266" class="ident">nb</label>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Trim away incomplete copy of original pattern in high bits.</span><span class="comment">					 TODO(rsc): Replace with table lookup or loop on systems without divide?</span></div>
<div class="code"><pre><code>					<label for="r266" class="ident">nb</label> = <label for="r262" class="ident">maxBits</label> / <label for="r264" class="ident">npattern</label> * <label for="r264" class="ident">npattern</label>
					<label for="r265" class="ident">b</label> &amp;= <span class="lit-number">1</span>&lt;&lt;<label for="r266" class="ident">nb</label> - <span class="lit-number">1</span>
					<label for="r263" class="ident">pattern</label> = <label for="r265" class="ident">b</label>
					<label for="r264" class="ident">npattern</label> = <label for="r266" class="ident">nb</label>
				}
			}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Add pattern to bit buffer and flush bit buffer, c/npattern times.</span><span class="comment">			 Since pattern contains &gt;8 bits, there will be full bytes to flush</span><span class="comment">			 on each iteration.</span></div>
<div class="code"><pre><code>			<span class="keyword">for</span> ; <label for="r258" class="ident">c</label> &gt;= <label for="r264" class="ident">npattern</label>; <label for="r258" class="ident">c</label> -= <label for="r264" class="ident">npattern</label> {
				<label for="r246" class="ident">bits</label> |= <label for="r263" class="ident">pattern</label> &lt;&lt; <label for="r247" class="ident">nbits</label>
				<label for="r247" class="ident">nbits</label> += <label for="r264" class="ident">npattern</label>
				<span class="keyword">if</span> <label for="r244" class="ident">size</label> == <span class="lit-number">1</span> {
					<span class="keyword">for</span> <label for="r247" class="ident">nbits</label> &gt;= <span class="lit-number">8</span> {
						*<label for="r243" class="ident">dst</label> = <a href="../../pkg/builtin.html#name-uint8" class="ident">uint8</a>(<label for="r246" class="ident">bits</label>)
						<label for="r243" class="ident">dst</label> = <a href="#line-89" class="ident">add1</a>(<label for="r243" class="ident">dst</label>)
						<label for="r246" class="ident">bits</label> &gt;&gt;= <span class="lit-number">8</span>
						<label for="r247" class="ident">nbits</label> -= <span class="lit-number">8</span>
					}
				} <span class="keyword">else</span> {
					<span class="keyword">for</span> <label for="r247" class="ident">nbits</label> &gt;= <span class="lit-number">4</span> {
						*<label for="r243" class="ident">dst</label> = <a href="../../pkg/builtin.html#name-uint8" class="ident">uint8</a>(<label for="r246" class="ident">bits</label>&amp;<span class="lit-number">0xf</span> | <a href="#line-62" class="ident">bitScanAll</a>)
						<label for="r243" class="ident">dst</label> = <a href="#line-89" class="ident">add1</a>(<label for="r243" class="ident">dst</label>)
						<label for="r246" class="ident">bits</label> &gt;&gt;= <span class="lit-number">4</span>
						<label for="r247" class="ident">nbits</label> -= <span class="lit-number">4</span>
					}
				}
			}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Add final fragment to bit buffer.</span></div>
<div class="code"><pre><code>			<span class="keyword">if</span> <label for="r258" class="ident">c</label> &gt; <span class="lit-number">0</span> {
				<label for="r263" class="ident">pattern</label> &amp;= <span class="lit-number">1</span>&lt;&lt;<label for="r258" class="ident">c</label> - <span class="lit-number">1</span>
				<label for="r246" class="ident">bits</label> |= <label for="r263" class="ident">pattern</label> &lt;&lt; <label for="r247" class="ident">nbits</label>
				<label for="r247" class="ident">nbits</label> += <label for="r258" class="ident">c</label>
			}
			<span class="keyword">continue</span> <label for="r249" class="ident">Run</label>
		}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Repeat; n too large to fit in a register.</span><span class="comment">		 Since nbits &lt;= 7, we know the first few bytes of repeated data</span><span class="comment">		 are already written to memory.</span></div>
<div class="code"><pre><code>		<label for="r267" class="ident">off</label> := <label for="r252" class="ident">n</label> - <label for="r247" class="ident">nbits</label> <span class="comment">// n &gt; nbits because n &gt; maxBits and nbits &lt;= 7</span>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Leading src fragment.</span></div>
<div class="code"><pre><code>			<label for="r261" class="ident">src</label> = <a href="#line-79" class="ident">subtractb</a>(<label for="r261" class="ident">src</label>, (<label for="r267" class="ident">off</label>+<span class="lit-number">7</span>)/<span class="lit-number">8</span>)
			<span class="keyword">if</span> <label for="r268" class="ident">frag</label> := <label for="r267" class="ident">off</label> &amp; <span class="lit-number">7</span>; <label for="r268" class="ident">frag</label> != <span class="lit-number">0</span> {
				<label for="r246" class="ident">bits</label> |= <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(*<label for="r261" class="ident">src</label>) &gt;&gt; (<span class="lit-number">8</span> - <label for="r268" class="ident">frag</label>) &lt;&lt; <label for="r247" class="ident">nbits</label>
				<label for="r261" class="ident">src</label> = <a href="#line-89" class="ident">add1</a>(<label for="r261" class="ident">src</label>)
				<label for="r247" class="ident">nbits</label> += <label for="r268" class="ident">frag</label>
				<label for="r258" class="ident">c</label> -= <label for="r268" class="ident">frag</label>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Main loop: load one byte, write another.</span><span class="comment">			 The bits are rotating through the bit buffer.</span></div>
<div class="code"><pre><code>			<span class="keyword">for</span> <label for="r269" class="ident">i</label> := <label for="r258" class="ident">c</label> / <span class="lit-number">8</span>; <label for="r269" class="ident">i</label> &gt; <span class="lit-number">0</span>; <label for="r269" class="ident">i</label>-- {
				<label for="r246" class="ident">bits</label> |= <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(*<label for="r261" class="ident">src</label>) &lt;&lt; <label for="r247" class="ident">nbits</label>
				<label for="r261" class="ident">src</label> = <a href="#line-89" class="ident">add1</a>(<label for="r261" class="ident">src</label>)
				*<label for="r243" class="ident">dst</label> = <a href="../../pkg/builtin.html#name-uint8" class="ident">uint8</a>(<label for="r246" class="ident">bits</label>)
				<label for="r243" class="ident">dst</label> = <a href="#line-89" class="ident">add1</a>(<label for="r243" class="ident">dst</label>)
				<label for="r246" class="ident">bits</label> &gt;&gt;= <span class="lit-number">8</span>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Final src fragment.</span></div>
<div class="code"><pre><code>			<span class="keyword">if</span> <label for="r258" class="ident">c</label> %= <span class="lit-number">8</span>; <label for="r258" class="ident">c</label> &gt; <span class="lit-number">0</span> {
				<label for="r246" class="ident">bits</label> |= (<a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(*<label for="r261" class="ident">src</label>) &amp; (<span class="lit-number">1</span>&lt;&lt;<label for="r258" class="ident">c</label> - <span class="lit-number">1</span>)) &lt;&lt; <label for="r247" class="ident">nbits</label>
				<label for="r247" class="ident">nbits</label> += <label for="r258" class="ident">c</label>
			}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Leading src fragment.</span></div>
<div class="code"><pre><code>			<label for="r261" class="ident">src</label> = <a href="#line-79" class="ident">subtractb</a>(<label for="r261" class="ident">src</label>, (<label for="r267" class="ident">off</label>+<span class="lit-number">3</span>)/<span class="lit-number">4</span>)
			<span class="keyword">if</span> <label for="r270" class="ident">frag</label> := <label for="r267" class="ident">off</label> &amp; <span class="lit-number">3</span>; <label for="r270" class="ident">frag</label> != <span class="lit-number">0</span> {
				<label for="r246" class="ident">bits</label> |= (<a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(*<label for="r261" class="ident">src</label>) &amp; <span class="lit-number">0xf</span>) &gt;&gt; (<span class="lit-number">4</span> - <label for="r270" class="ident">frag</label>) &lt;&lt; <label for="r247" class="ident">nbits</label>
				<label for="r261" class="ident">src</label> = <a href="#line-89" class="ident">add1</a>(<label for="r261" class="ident">src</label>)
				<label for="r247" class="ident">nbits</label> += <label for="r270" class="ident">frag</label>
				<label for="r258" class="ident">c</label> -= <label for="r270" class="ident">frag</label>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Main loop: load one byte, write another.</span><span class="comment">			 The bits are rotating through the bit buffer.</span></div>
<div class="code"><pre><code>			<span class="keyword">for</span> <label for="r271" class="ident">i</label> := <label for="r258" class="ident">c</label> / <span class="lit-number">4</span>; <label for="r271" class="ident">i</label> &gt; <span class="lit-number">0</span>; <label for="r271" class="ident">i</label>-- {
				<label for="r246" class="ident">bits</label> |= (<a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(*<label for="r261" class="ident">src</label>) &amp; <span class="lit-number">0xf</span>) &lt;&lt; <label for="r247" class="ident">nbits</label>
				<label for="r261" class="ident">src</label> = <a href="#line-89" class="ident">add1</a>(<label for="r261" class="ident">src</label>)
				*<label for="r243" class="ident">dst</label> = <a href="../../pkg/builtin.html#name-uint8" class="ident">uint8</a>(<label for="r246" class="ident">bits</label>&amp;<span class="lit-number">0xf</span> | <a href="#line-62" class="ident">bitScanAll</a>)
				<label for="r243" class="ident">dst</label> = <a href="#line-89" class="ident">add1</a>(<label for="r243" class="ident">dst</label>)
				<label for="r246" class="ident">bits</label> &gt;&gt;= <span class="lit-number">4</span>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Final src fragment.</span></div>
<div class="code"><pre><code>			<span class="keyword">if</span> <label for="r258" class="ident">c</label> %= <span class="lit-number">4</span>; <label for="r258" class="ident">c</label> &gt; <span class="lit-number">0</span> {
				<label for="r246" class="ident">bits</label> |= (<a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(*<label for="r261" class="ident">src</label>) &amp; (<span class="lit-number">1</span>&lt;&lt;<label for="r258" class="ident">c</label> - <span class="lit-number">1</span>)) &lt;&lt; <label for="r247" class="ident">nbits</label>
				<label for="r247" class="ident">nbits</label> += <label for="r258" class="ident">c</label>
			}
		}
	}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Write any final bits out, using full-byte writes, even for the final byte.</span></div>
<div class="code"><pre><code>	<span class="keyword">var</span> <label for="r272" class="ident">totalBits</label> <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>
	<span class="keyword">if</span> <label for="r244" class="ident">size</label> == <span class="lit-number">1</span> {
		<label for="r272" class="ident">totalBits</label> = (<a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<a href="../../pkg/unsafe.html" class="ident i2">unsafe</a>.<a href="../../pkg/unsafe.html#name-Pointer" class="ident">Pointer</a>(<label for="r243" class="ident">dst</label>))-<a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<a href="../../pkg/unsafe.html" class="ident i2">unsafe</a>.<a href="../../pkg/unsafe.html#name-Pointer" class="ident">Pointer</a>(<label for="r245" class="ident">dstStart</label>)))*<span class="lit-number">8</span> + <label for="r247" class="ident">nbits</label>
		<label for="r247" class="ident">nbits</label> += -<label for="r247" class="ident">nbits</label> &amp; <span class="lit-number">7</span>
		<span class="keyword">for</span> ; <label for="r247" class="ident">nbits</label> &gt; <span class="lit-number">0</span>; <label for="r247" class="ident">nbits</label> -= <span class="lit-number">8</span> {
			*<label for="r243" class="ident">dst</label> = <a href="../../pkg/builtin.html#name-uint8" class="ident">uint8</a>(<label for="r246" class="ident">bits</label>)
			<label for="r243" class="ident">dst</label> = <a href="#line-89" class="ident">add1</a>(<label for="r243" class="ident">dst</label>)
			<label for="r246" class="ident">bits</label> &gt;&gt;= <span class="lit-number">8</span>
		}
	} <span class="keyword">else</span> {
		<label for="r272" class="ident">totalBits</label> = (<a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<a href="../../pkg/unsafe.html" class="ident i2">unsafe</a>.<a href="../../pkg/unsafe.html#name-Pointer" class="ident">Pointer</a>(<label for="r243" class="ident">dst</label>))-<a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<a href="../../pkg/unsafe.html" class="ident i2">unsafe</a>.<a href="../../pkg/unsafe.html#name-Pointer" class="ident">Pointer</a>(<label for="r245" class="ident">dstStart</label>)))*<span class="lit-number">4</span> + <label for="r247" class="ident">nbits</label>
		<label for="r247" class="ident">nbits</label> += -<label for="r247" class="ident">nbits</label> &amp; <span class="lit-number">3</span>
		<span class="keyword">for</span> ; <label for="r247" class="ident">nbits</label> &gt; <span class="lit-number">0</span>; <label for="r247" class="ident">nbits</label> -= <span class="lit-number">4</span> {
			<label for="r273" class="ident">v</label> := <label for="r246" class="ident">bits</label>&amp;<span class="lit-number">0xf</span> | <a href="#line-62" class="ident">bitScanAll</a>
			*<label for="r243" class="ident">dst</label> = <a href="../../pkg/builtin.html#name-uint8" class="ident">uint8</a>(<label for="r273" class="ident">v</label>)
			<label for="r243" class="ident">dst</label> = <a href="#line-89" class="ident">add1</a>(<label for="r243" class="ident">dst</label>)
			<label for="r246" class="ident">bits</label> &gt;&gt;= <span class="lit-number">4</span>
		}
	}
	<span class="keyword">return</span> <label for="r272" class="ident">totalBits</label>
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> materializeGCProg allocates space for the (1-bit) pointer bitmask</span><span class="comment"> for an object of size ptrdata.  Then it fills that space with the</span><span class="comment"> pointer bitmask specified by the program prog.</span><span class="comment"> The bitmask starts at s.startAddr.</span><span class="comment"> The result must be deallocated with dematerializeGCProg.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Each word of ptrdata needs one bit in the bitmap.</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Compute the number of pages needed for bitmapBytes.</span></div>
<div class="code"><pre><code>	<label for="r278" class="ident">pages</label> := <a href="stubs.go.html#line-328" class="ident">divRoundUp</a>(<label for="r277" class="ident">bitmapBytes</label>, <a href="malloc.go.html#line-118" class="ident">pageSize</a>)
	<label for="r279" class="ident">s</label> := <a href="mheap.go.html#line-221" class="ident">mheap_</a>.<a href="mheap.go.html#line-939" class="ident">allocManual</a>(<label for="r278" class="ident">pages</label>, <a href="mheap.go.html#line-885" class="ident">spanAllocPtrScalarBits</a>)
	<a href="#line-1584" class="ident">runGCProg</a>(<a href="#line-69" class="ident">addb</a>(<label for="r276" class="ident">prog</label>, <span class="lit-number">4</span>), <a href="../../pkg/builtin.html#name-nil" class="ident">nil</a>, (*<a href="../../pkg/builtin.html#name-byte" class="ident">byte</a>)(<a href="../../pkg/unsafe.html" class="ident i2">unsafe</a>.<a href="../../pkg/unsafe.html#name-Pointer" class="ident">Pointer</a>(<label for="r279" class="ident">s</label>.<a href="mheap.go.html#line-387" class="ident">startAddr</a>)), <span class="lit-number">1</span>)
	<span class="keyword">return</span> <label for="r279" class="ident">s</label>
}
<span class="keyword">func</span> <label for="r280" class="ident"><a href="../../pkg/runtime.html#name-dematerializeGCProg" class="ident">dematerializeGCProg</a></label>(<label for="r281" class="ident">s</label> *<a href="mheap.go.html#line-382" class="ident">mspan</a>) {
	<a href="mheap.go.html#line-221" class="ident">mheap_</a>.<a href="mheap.go.html#line-1433" class="ident">freeManual</a>(<label for="r281" class="ident">s</label>, <a href="mheap.go.html#line-885" class="ident">spanAllocPtrScalarBits</a>)
}

<span class="keyword">func</span> <label for="r282" class="ident"><a href="../../pkg/runtime.html#name-dumpGCProg" class="ident">dumpGCProg</a></label>(<label for="r283" class="ident">p</label> *<a href="../../pkg/builtin.html#name-byte" class="ident">byte</a>) {
	<label for="r284" class="ident">nptr</label> := <span class="lit-number">0</span>
	<span class="keyword">for</span> {
		<label for="r285" class="ident">x</label> := *<label for="r283" class="ident">p</label>
		<label for="r283" class="ident">p</label> = <a href="#line-89" class="ident">add1</a>(<label for="r283" class="ident">p</label>)
		<span class="keyword">if</span> <label for="r285" class="ident">x</label> == <span class="lit-number">0</span> {
			<a href="../../pkg/builtin.html#name-print" class="ident">print</a>(<span class="lit-string">"\t"</span>, <label for="r284" class="ident">nptr</label>, <span class="lit-string">" end\n"</span>)
			<span class="keyword">break</span>
		}
		<span class="keyword">if</span> <label for="r285" class="ident">x</label>&amp;<span class="lit-number">0x80</span> == <span class="lit-number">0</span> {
			<a href="../../pkg/builtin.html#name-print" class="ident">print</a>(<span class="lit-string">"\t"</span>, <label for="r284" class="ident">nptr</label>, <span class="lit-string">" lit "</span>, <label for="r285" class="ident">x</label>, <span class="lit-string">":"</span>)
			<label for="r286" class="ident">n</label> := <a href="../../pkg/builtin.html#name-int" class="ident">int</a>(<label for="r285" class="ident">x</label>+<span class="lit-number">7</span>) / <span class="lit-number">8</span>
			<span class="keyword">for</span> <label for="r287" class="ident">i</label> := <span class="lit-number">0</span>; <label for="r287" class="ident">i</label> &lt; <label for="r286" class="ident">n</label>; <label for="r287" class="ident">i</label>++ {
				<a href="../../pkg/builtin.html#name-print" class="ident">print</a>(<span class="lit-string">" "</span>, <a href="print.go.html#line-15" class="ident">hex</a>(*<label for="r283" class="ident">p</label>))
				<label for="r283" class="ident">p</label> = <a href="#line-89" class="ident">add1</a>(<label for="r283" class="ident">p</label>)
			}
			<a href="../../pkg/builtin.html#name-print" class="ident">print</a>(<span class="lit-string">"\n"</span>)
			<label for="r284" class="ident">nptr</label> += <a href="../../pkg/builtin.html#name-int" class="ident">int</a>(<label for="r285" class="ident">x</label>)
		} <span class="keyword">else</span> {
			<label for="r288" class="ident">nbit</label> := <a href="../../pkg/builtin.html#name-int" class="ident">int</a>(<label for="r285" class="ident">x</label> &amp;^ <span class="lit-number">0x80</span>)
			<span class="keyword">if</span> <label for="r288" class="ident">nbit</label> == <span class="lit-number">0</span> {
				<span class="keyword">for</span> <label for="r289" class="ident">nb</label> := <a href="../../pkg/builtin.html#name-uint" class="ident">uint</a>(<span class="lit-number">0</span>); ; <label for="r289" class="ident">nb</label> += <span class="lit-number">7</span> {
					<label for="r290" class="ident">x</label> := *<label for="r283" class="ident">p</label>
					<label for="r283" class="ident">p</label> = <a href="#line-89" class="ident">add1</a>(<label for="r283" class="ident">p</label>)
					<label for="r288" class="ident">nbit</label> |= <a href="../../pkg/builtin.html#name-int" class="ident">int</a>(<label for="r290" class="ident">x</label>&amp;<span class="lit-number">0x7f</span>) &lt;&lt; <label for="r289" class="ident">nb</label>
					<span class="keyword">if</span> <label for="r290" class="ident">x</label>&amp;<span class="lit-number">0x80</span> == <span class="lit-number">0</span> {
						<span class="keyword">break</span>
					}
				}
			}
			<label for="r291" class="ident">count</label> := <span class="lit-number">0</span>
			<span class="keyword">for</span> <label for="r292" class="ident">nb</label> := <a href="../../pkg/builtin.html#name-uint" class="ident">uint</a>(<span class="lit-number">0</span>); ; <label for="r292" class="ident">nb</label> += <span class="lit-number">7</span> {
				<label for="r293" class="ident">x</label> := *<label for="r283" class="ident">p</label>
				<label for="r283" class="ident">p</label> = <a href="#line-89" class="ident">add1</a>(<label for="r283" class="ident">p</label>)
				<label for="r291" class="ident">count</label> |= <a href="../../pkg/builtin.html#name-int" class="ident">int</a>(<label for="r293" class="ident">x</label>&amp;<span class="lit-number">0x7f</span>) &lt;&lt; <label for="r292" class="ident">nb</label>
				<span class="keyword">if</span> <label for="r293" class="ident">x</label>&amp;<span class="lit-number">0x80</span> == <span class="lit-number">0</span> {
					<span class="keyword">break</span>
				}
			}
			<a href="../../pkg/builtin.html#name-print" class="ident">print</a>(<span class="lit-string">"\t"</span>, <label for="r284" class="ident">nptr</label>, <span class="lit-string">" repeat "</span>, <label for="r288" class="ident">nbit</label>, <span class="lit-string">"  "</span>, <label for="r291" class="ident">count</label>, <span class="lit-string">"\n"</span>)
			<label for="r284" class="ident">nptr</label> += <label for="r288" class="ident">nbit</label> * <label for="r291" class="ident">count</label>
		}
	}
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Testing.</span></div>
<div class="code"><pre><code>
<span class="keyword">func</span> <label for="r294" class="ident"><a href="../../pkg/runtime.html#name-getgcmaskcb" class="ident">getgcmaskcb</a></label>(<label for="r295" class="ident">frame</label> *<a href="runtime2.go.html#line-954" class="ident">stkframe</a>, <label for="r296" class="ident">ctxt</label> <a href="../../pkg/unsafe.html" class="ident i2">unsafe</a>.<a href="../../pkg/unsafe.html#name-Pointer" class="ident">Pointer</a>) <a href="../../pkg/builtin.html#name-bool" class="ident">bool</a> {
	<label for="r297" class="ident">target</label> := (*<a href="runtime2.go.html#line-954" class="ident">stkframe</a>)(<label for="r296" class="ident">ctxt</label>)
	<span class="keyword">if</span> <label for="r295" class="ident">frame</label>.<a href="runtime2.go.html#line-959" class="ident">sp</a> &lt;= <label for="r297" class="ident">target</label>.<a href="runtime2.go.html#line-959" class="ident">sp</a> &amp;&amp; <label for="r297" class="ident">target</label>.<a href="runtime2.go.html#line-959" class="ident">sp</a> &lt; <label for="r295" class="ident">frame</label>.<a href="runtime2.go.html#line-961" class="ident">varp</a> {
		*<label for="r297" class="ident">target</label> = *<label for="r295" class="ident">frame</label>
		<span class="keyword">return</span> <a href="../../pkg/builtin.html#name-false" class="ident">false</a>
	}
	<span class="keyword">return</span> <a href="../../pkg/builtin.html#name-true" class="ident">true</a>
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> gcbits returns the GC type info for x, for testing.</span><span class="comment"> The result is the bitmap entries (0 or 1), one entry per byte.</span><span class="comment">go:linkname reflect_gcbits reflect.gcbits</span></div>
<div class="code"><pre><code><span class="keyword">func</span> <label for="r298" class="ident"><a href="../../pkg/runtime.html#name-reflect_gcbits" class="ident">reflect_gcbits</a></label>(<label for="r299" class="ident">x</label> <span class="keyword">interface</span>{}) []<a href="../../pkg/builtin.html#name-byte" class="ident">byte</a> {
	<label for="r300" class="ident">ret</label> := <a href="#line-1951" class="ident">getgcmask</a>(<label for="r299" class="ident">x</label>)
	<label for="r301" class="ident">typ</label> := (*<a href="type.go.html#line-427" class="ident">ptrtype</a>)(<a href="../../pkg/unsafe.html" class="ident i2">unsafe</a>.<a href="../../pkg/unsafe.html#name-Pointer" class="ident">Pointer</a>(<a href="runtime2.go.html#line-213" class="ident">efaceOf</a>(&amp;<label for="r299" class="ident">x</label>).<a href="runtime2.go.html#line-209" class="ident">_type</a>)).<a href="type.go.html#line-429" class="ident">elem</a>
	<label for="r302" class="ident">nptr</label> := <label for="r301" class="ident">typ</label>.<a href="type.go.html#line-33" class="ident">ptrdata</a> / <a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a>
	<span class="keyword">for</span> <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<a href="../../pkg/builtin.html#name-len" class="ident">len</a>(<label for="r300" class="ident">ret</label>)) &gt; <label for="r302" class="ident">nptr</label> &amp;&amp; <label for="r300" class="ident">ret</label>[<a href="../../pkg/builtin.html#name-len" class="ident">len</a>(<label for="r300" class="ident">ret</label>)-<span class="lit-number">1</span>] == <span class="lit-number">0</span> {
		<label for="r300" class="ident">ret</label> = <label for="r300" class="ident">ret</label>[:<a href="../../pkg/builtin.html#name-len" class="ident">len</a>(<label for="r300" class="ident">ret</label>)-<span class="lit-number">1</span>]
	}
	<span class="keyword">return</span> <label for="r300" class="ident">ret</label>
}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> Returns GC type info for the pointer stored in ep for testing.</span><span class="comment"> If ep points to the stack, only static live information will be returned</span><span class="comment"> (i.e. not for objects which are only dynamically live stack objects).</span></div>
<div class="code"><pre><code><span class="keyword">func</span> <label for="r303" class="ident"><a href="../../pkg/runtime.html#name-getgcmask" class="ident">getgcmask</a></label>(<label for="r304" class="ident">ep</label> <span class="keyword">interface</span>{}) (<label for="r305" class="ident">mask</label> []<a href="../../pkg/builtin.html#name-byte" class="ident">byte</a>) {
	<label for="r306" class="ident">e</label> := *<a href="runtime2.go.html#line-213" class="ident">efaceOf</a>(&amp;<label for="r304" class="ident">ep</label>)
	<label for="r307" class="ident">p</label> := <label for="r306" class="ident">e</label>.<a href="runtime2.go.html#line-210" class="ident">data</a>
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> data or bss</span></div>
<div class="code"><pre><code></code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> data</span></div>
<div class="code"><pre><code>		<span class="keyword">if</span> <label for="r310" class="ident">datap</label>.<a href="symtab.go.html#line-370" class="ident">data</a> &lt;= <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<label for="r307" class="ident">p</label>) &amp;&amp; <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<label for="r307" class="ident">p</label>) &lt; <label for="r310" class="ident">datap</label>.<a href="symtab.go.html#line-370" class="ident">edata</a> {
			<label for="r311" class="ident">bitmap</label> := <label for="r310" class="ident">datap</label>.<a href="symtab.go.html#line-390" class="ident">gcdatamask</a>.<a href="stack.go.html#line-564" class="ident">bytedata</a>
			<label for="r312" class="ident">n</label> := (*<a href="type.go.html#line-427" class="ident">ptrtype</a>)(<a href="../../pkg/unsafe.html" class="ident i2">unsafe</a>.<a href="../../pkg/unsafe.html#name-Pointer" class="ident">Pointer</a>(<label for="r308" class="ident">t</label>)).<a href="type.go.html#line-429" class="ident">elem</a>.<a href="type.go.html#line-32" class="ident">size</a>
			<label for="r305" class="ident">mask</label> = <a href="../../pkg/builtin.html#name-make" class="ident">make</a>([]<a href="../../pkg/builtin.html#name-byte" class="ident">byte</a>, <label for="r312" class="ident">n</label>/<a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a>)
			<span class="keyword">for</span> <label for="r313" class="ident">i</label> := <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<span class="lit-number">0</span>); <label for="r313" class="ident">i</label> &lt; <label for="r312" class="ident">n</label>; <label for="r313" class="ident">i</label> += <a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a> {
				<label for="r314" class="ident">off</label> := (<a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<label for="r307" class="ident">p</label>) + <label for="r313" class="ident">i</label> - <label for="r310" class="ident">datap</label>.<a href="symtab.go.html#line-370" class="ident">data</a>) / <a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a>
				<label for="r305" class="ident">mask</label>[<label for="r313" class="ident">i</label>/<a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a>] = (*<a href="#line-69" class="ident">addb</a>(<label for="r311" class="ident">bitmap</label>, <label for="r314" class="ident">off</label>/<span class="lit-number">8</span>) &gt;&gt; (<label for="r314" class="ident">off</label> % <span class="lit-number">8</span>)) &amp; <span class="lit-number">1</span>
			}
			<span class="keyword">return</span>
		}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> bss</span></div>
<div class="code"><pre><code>		<span class="keyword">if</span> <label for="r310" class="ident">datap</label>.<a href="symtab.go.html#line-371" class="ident">bss</a> &lt;= <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<label for="r307" class="ident">p</label>) &amp;&amp; <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<label for="r307" class="ident">p</label>) &lt; <label for="r310" class="ident">datap</label>.<a href="symtab.go.html#line-371" class="ident">ebss</a> {
			<label for="r315" class="ident">bitmap</label> := <label for="r310" class="ident">datap</label>.<a href="symtab.go.html#line-390" class="ident">gcbssmask</a>.<a href="stack.go.html#line-564" class="ident">bytedata</a>
			<label for="r316" class="ident">n</label> := (*<a href="type.go.html#line-427" class="ident">ptrtype</a>)(<a href="../../pkg/unsafe.html" class="ident i2">unsafe</a>.<a href="../../pkg/unsafe.html#name-Pointer" class="ident">Pointer</a>(<label for="r308" class="ident">t</label>)).<a href="type.go.html#line-429" class="ident">elem</a>.<a href="type.go.html#line-32" class="ident">size</a>
			<label for="r305" class="ident">mask</label> = <a href="../../pkg/builtin.html#name-make" class="ident">make</a>([]<a href="../../pkg/builtin.html#name-byte" class="ident">byte</a>, <label for="r316" class="ident">n</label>/<a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a>)
			<span class="keyword">for</span> <label for="r317" class="ident">i</label> := <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<span class="lit-number">0</span>); <label for="r317" class="ident">i</label> &lt; <label for="r316" class="ident">n</label>; <label for="r317" class="ident">i</label> += <a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a> {
				<label for="r318" class="ident">off</label> := (<a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<label for="r307" class="ident">p</label>) + <label for="r317" class="ident">i</label> - <label for="r310" class="ident">datap</label>.<a href="symtab.go.html#line-371" class="ident">bss</a>) / <a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a>
				<label for="r305" class="ident">mask</label>[<label for="r317" class="ident">i</label>/<a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a>] = (*<a href="#line-69" class="ident">addb</a>(<label for="r315" class="ident">bitmap</label>, <label for="r318" class="ident">off</label>/<span class="lit-number">8</span>) &gt;&gt; (<label for="r318" class="ident">off</label> % <span class="lit-number">8</span>)) &amp; <span class="lit-number">1</span>
			}
			<span class="keyword">return</span>
		}
	}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> heap</span></div>
<div class="code"><pre><code>	<span class="keyword">if</span> <label for="r319" class="ident">base</label>, <label for="r320" class="ident">s</label>, <label for="r321" class="ident">_</label> := <a href="#line-368" class="ident">findObject</a>(<a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<label for="r307" class="ident">p</label>), <span class="lit-number">0</span>, <span class="lit-number">0</span>); <label for="r319" class="ident">base</label> != <span class="lit-number">0</span> {
		<label for="r322" class="ident">hbits</label> := <a href="#line-308" class="ident">heapBitsForAddr</a>(<label for="r319" class="ident">base</label>)
		<label for="r323" class="ident">n</label> := <label for="r320" class="ident">s</label>.<a href="mheap.go.html#line-462" class="ident">elemsize</a>
		<label for="r305" class="ident">mask</label> = <a href="../../pkg/builtin.html#name-make" class="ident">make</a>([]<a href="../../pkg/builtin.html#name-byte" class="ident">byte</a>, <label for="r323" class="ident">n</label>/<a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a>)
		<span class="keyword">for</span> <label for="r324" class="ident">i</label> := <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<span class="lit-number">0</span>); <label for="r324" class="ident">i</label> &lt; <label for="r323" class="ident">n</label>; <label for="r324" class="ident">i</label> += <a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a> {
			<span class="keyword">if</span> <label for="r322" class="ident">hbits</label>.<a href="#line-521" class="ident">isPointer</a>() {
				<label for="r305" class="ident">mask</label>[<label for="r324" class="ident">i</label>/<a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a>] = <span class="lit-number">1</span>
			}
			<span class="keyword">if</span> !<label for="r322" class="ident">hbits</label>.<a href="#line-513" class="ident">morePointers</a>() {
				<label for="r305" class="ident">mask</label> = <label for="r305" class="ident">mask</label>[:<label for="r324" class="ident">i</label>/<a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a>]
				<span class="keyword">break</span>
			}
			<label for="r322" class="ident">hbits</label> = <label for="r322" class="ident">hbits</label>.<a href="#line-418" class="ident">next</a>()
		}
		<span class="keyword">return</span>
	}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> stack</span></div>
<div class="code"><pre><code>	<span class="keyword">if</span> <label for="r325" class="ident">_g_</label> := <a href="stubs.go.html#line-18" class="ident">getg</a>(); <label for="r325" class="ident">_g_</label>.<a href="runtime2.go.html#line-418" class="ident">m</a>.<a href="runtime2.go.html#line-498" class="ident">curg</a>.<a href="runtime2.go.html#line-412" class="ident">stack</a>.<a href="runtime2.go.html#line-394" class="ident">lo</a> &lt;= <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<label for="r307" class="ident">p</label>) &amp;&amp; <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<label for="r307" class="ident">p</label>) &lt; <label for="r325" class="ident">_g_</label>.<a href="runtime2.go.html#line-418" class="ident">m</a>.<a href="runtime2.go.html#line-498" class="ident">curg</a>.<a href="runtime2.go.html#line-412" class="ident">stack</a>.<a href="runtime2.go.html#line-395" class="ident">hi</a> {
		<span class="keyword">var</span> <label for="r326" class="ident">frame</label> <a href="runtime2.go.html#line-954" class="ident">stkframe</a>
		<label for="r326" class="ident">frame</label>.<a href="runtime2.go.html#line-959" class="ident">sp</a> = <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<label for="r307" class="ident">p</label>)
		<label for="r327" class="ident">_g_</label> := <a href="stubs.go.html#line-18" class="ident">getg</a>()
		<a href="traceback.go.html#line-86" class="ident">gentraceback</a>(<label for="r327" class="ident">_g_</label>.<a href="runtime2.go.html#line-418" class="ident">m</a>.<a href="runtime2.go.html#line-498" class="ident">curg</a>.<a href="runtime2.go.html#line-419" class="ident">sched</a>.<a href="runtime2.go.html#line-327" class="ident">pc</a>, <label for="r327" class="ident">_g_</label>.<a href="runtime2.go.html#line-418" class="ident">m</a>.<a href="runtime2.go.html#line-498" class="ident">curg</a>.<a href="runtime2.go.html#line-419" class="ident">sched</a>.<a href="runtime2.go.html#line-326" class="ident">sp</a>, <span class="lit-number">0</span>, <label for="r327" class="ident">_g_</label>.<a href="runtime2.go.html#line-418" class="ident">m</a>.<a href="runtime2.go.html#line-498" class="ident">curg</a>, <span class="lit-number">0</span>, <a href="../../pkg/builtin.html#name-nil" class="ident">nil</a>, <span class="lit-number">1000</span>, <a href="#line-1926" class="ident">getgcmaskcb</a>, <a href="stubs.go.html#line-157" class="ident">noescape</a>(<a href="../../pkg/unsafe.html" class="ident i2">unsafe</a>.<a href="../../pkg/unsafe.html#name-Pointer" class="ident">Pointer</a>(&amp;<label for="r326" class="ident">frame</label>)), <span class="lit-number">0</span>)
		<span class="keyword">if</span> <label for="r326" class="ident">frame</label>.<a href="runtime2.go.html#line-955" class="ident">fn</a>.<a href="symtab.go.html#line-663" class="ident">valid</a>() {
			<label for="r328" class="ident">locals</label>, <label for="r329" class="ident">_</label>, <label for="r330" class="ident">_</label> := <a href="stack.go.html#line-1219" class="ident">getStackMap</a>(&amp;<label for="r326" class="ident">frame</label>, <a href="../../pkg/builtin.html#name-nil" class="ident">nil</a>, <a href="../../pkg/builtin.html#name-false" class="ident">false</a>)
			<span class="keyword">if</span> <label for="r328" class="ident">locals</label>.<a href="stack.go.html#line-563" class="ident">n</a> == <span class="lit-number">0</span> {
				<span class="keyword">return</span>
			}
			<label for="r331" class="ident">size</label> := <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<label for="r328" class="ident">locals</label>.<a href="stack.go.html#line-563" class="ident">n</a>) * <a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a>
			<label for="r332" class="ident">n</label> := (*<a href="type.go.html#line-427" class="ident">ptrtype</a>)(<a href="../../pkg/unsafe.html" class="ident i2">unsafe</a>.<a href="../../pkg/unsafe.html#name-Pointer" class="ident">Pointer</a>(<label for="r308" class="ident">t</label>)).<a href="type.go.html#line-429" class="ident">elem</a>.<a href="type.go.html#line-32" class="ident">size</a>
			<label for="r305" class="ident">mask</label> = <a href="../../pkg/builtin.html#name-make" class="ident">make</a>([]<a href="../../pkg/builtin.html#name-byte" class="ident">byte</a>, <label for="r332" class="ident">n</label>/<a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a>)
			<span class="keyword">for</span> <label for="r333" class="ident">i</label> := <a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<span class="lit-number">0</span>); <label for="r333" class="ident">i</label> &lt; <label for="r332" class="ident">n</label>; <label for="r333" class="ident">i</label> += <a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a> {
				<label for="r334" class="ident">off</label> := (<a href="../../pkg/builtin.html#name-uintptr" class="ident">uintptr</a>(<label for="r307" class="ident">p</label>) + <label for="r333" class="ident">i</label> - <label for="r326" class="ident">frame</label>.<a href="runtime2.go.html#line-961" class="ident">varp</a> + <label for="r331" class="ident">size</label>) / <a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a>
				<label for="r305" class="ident">mask</label>[<label for="r333" class="ident">i</label>/<a href="../../pkg/runtime/internal/sys.html" class="ident i1">sys</a>.<a href="internal/sys/stubs.go.html#line-9" class="ident">PtrSize</a>] = <label for="r328" class="ident">locals</label>.<a href="stack.go.html#line-571" class="ident">ptrbit</a>(<label for="r334" class="ident">off</label>)
			}
		}
		<span class="keyword">return</span>
	}
</code></pre></div></div>
<div class="section">
<div class="doc">
<span class="comment"> otherwise, not something the GC knows about.</span><span class="comment">	 possibly read-only data, like malloc(0).</span><span class="comment">	 must not have pointers</span></div>
<div class="code"><pre><code>	<span class="keyword">return</span>
</code></pre></div></div>

</div><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/article/tool-golds.html"><b>Golds</b></a> <i>v0.3.2-preview</i>. (GOOS=darwin GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>